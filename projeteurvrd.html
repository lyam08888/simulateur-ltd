<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Simulateur pour découvrir le métier de projeteur VRD.">
    <title>LTD Simulator - Projeteur VRD</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500&family=Poppins:wght@700;800&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <style>
        /* --- THÈME GLOBAL (issu du site principal) --- */
        :root {
            /* Colors */
            --primary: #6366f1;
            --primary-dark: #4f46e5;
            --primary-light: #a5b4fc;
            --secondary: #10b981;
            --secondary-dark: #059669;
            --accent: #f59e0b;
            --accent-dark: #d97706;
            --correct: #22c55e;
            --incorrect: #ef4444;
            
            /* Surfaces */
            --background: #0f172a;
            --surface: #1e293b;
            --surface-elevated: #334155;
            --surface-hover: #475569;
            --glass: rgba(255, 255, 255, 0.05);
            --glass-border: rgba(255, 255, 255, 0.15);
            
            /* Text */
            --text-primary: #f8fafc;
            --text-secondary: #cbd5e1;
            --text-muted: #94a3b8;
            
            /* Shadows */
            --shadow-glow: 0 0 15px 0px rgba(99, 102, 241, 0.3);
            --shadow-lg: 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);
            --shadow-xl: 0 25px 50px -12px rgb(0 0 0 / 0.25);

            /* Animation */
            --transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            --transition-slow: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            
            /* Spacing */
            --spacing-xs: 0.5rem;
            --spacing-sm: 1rem;
            --spacing-md: 1.5rem;
            --spacing-lg: 2rem;
            --spacing-xl: 3rem;
            
            /* Borders */
            --radius-sm: 0.375rem;
            --radius: 0.5rem;
            --radius-md: 0.75rem;
            --radius-lg: 1rem;
            --radius-xl: 1.5rem;
            --radius-full: 9999px;
        }

        body.light-mode {
            --background: #f1f5f9;
            --surface: #ffffff;
            --surface-elevated: #e2e8f0;
            --surface-hover: #cbd5e1;
            --glass: rgba(0, 0, 0, 0.05);
            --glass-border: rgba(0, 0, 0, 0.1);
            --text-primary: #1e293b;
            --text-secondary: #475569;
            --text-muted: #64748b;
            --shadow-glow: 0 0 15px 0px rgba(99, 102, 241, 0.2);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }
        html { scroll-behavior: smooth; }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--background);
            color: var(--text-primary);
            line-height: 1.6;
            overflow-x: hidden;
            transition: var(--transition-slow);
        }

        body::before {
            content: ''; position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: radial-gradient(circle at 15% 50%, rgba(99, 102, 241, 0.15) 0%, transparent 40%), radial-gradient(circle at 85% 30%, rgba(16, 185, 129, 0.15) 0%, transparent 40%), radial-gradient(circle at 50% 85%, rgba(245, 158, 11, 0.1) 0%, transparent 40%);
            pointer-events: none; z-index: -1; animation: background-pan 30s linear infinite;
        }
        
        @keyframes background-pan { 0% { background-position: 0% 50%; } 50% { background-position: 100% 50%; } 100% { background-position: 0% 50%; } }
        
        [onclick], .nav-link, .mobile-nav-item, .theme-toggle, .mobile-toggle { cursor: pointer; }

        .header { position: fixed; top: 0; left: 0; right: 0; z-index: 1000; backdrop-filter: blur(20px) saturate(180%); background: rgba(15, 23, 42, 0.8); border-bottom: 1px solid var(--glass-border); transition: var(--transition); }
        body.light-mode .header { background: rgba(255, 255, 255, 0.8); }
        .nav-container { max-width: 1400px; margin: 0 auto; padding: 0 var(--spacing-sm); display: flex; align-items: center; justify-content: space-between; height: 4.5rem; gap: var(--spacing-md); }
        .logo { display: flex; align-items: center; gap: var(--spacing-sm); text-decoration: none; color: var(--text-primary); font-weight: 800; font-size: 1.2rem; transition: var(--transition); }
        .logo:hover { transform: scale(1.05); text-shadow: 0 0 10px var(--primary-light); }
        .logo-icon { height: 1.8rem; width: auto; vertical-align: -0.4rem; }
        .logo-text-extended { display: none; }
        .nav-desktop { display: none; }
        .nav-menu { display: flex; align-items: center; gap: var(--spacing-xs); list-style: none; }
        .nav-item { position: relative; }
        .nav-link { display: flex; align-items: center; gap: var(--spacing-xs); padding: var(--spacing-xs) var(--spacing-sm); color: var(--text-secondary); text-decoration: none; font-weight: 500; border-radius: var(--radius); transition: var(--transition); }
        .nav-link:hover { color: var(--text-primary); background: var(--glass); }
        .nav-link.active { color: var(--text-primary); background: linear-gradient(45deg, rgba(99, 102, 241, 0.1), rgba(99, 102, 241, 0.2)); font-weight: 600; }
        .header-search { position: relative; }
        .header-search input { width: 100%; background-color: var(--surface); border: 1px solid var(--glass-border); color: var(--text-secondary); border-radius: var(--radius); padding: 0.5rem 1rem 0.5rem 2.5rem; font-size: 0.9rem; transition: var(--transition); }
        .header-search input::placeholder { color: var(--text-muted); }
        .header-search input:focus { background-color: var(--surface-elevated); border-color: var(--primary); color: var(--text-primary); box-shadow: 0 0 0 2px var(--primary-dark); outline: none; }
        .header-search .fa-search { position: absolute; left: 1rem; top: 50%; transform: translateY(-50%); color: var(--text-muted); }
        .nav-actions { display: flex; align-items: center; gap: var(--spacing-sm); }
        .theme-toggle { display: flex; align-items: center; justify-content: center; width: 2.5rem; height: 2.5rem; background: var(--glass); border: 1px solid var(--glass-border); border-radius: var(--radius); color: var(--text-secondary); transition: var(--transition); }
        .theme-toggle:hover { background: var(--surface-elevated); color: var(--text-primary); transform: rotate(15deg); }
        .mobile-toggle { display: flex; flex-direction: column; justify-content: center; align-items: center; width: 2.5rem; height: 2.5rem; background: var(--glass); border: 1px solid var(--glass-border); border-radius: var(--radius); transition: var(--transition); }
        .hamburger { position: relative; width: 1.25rem; height: 1rem; }
        .hamburger span { position: absolute; left: 0; width: 100%; height: 2px; background: var(--text-primary); border-radius: 1px; transition: var(--transition); }
        .hamburger span:nth-child(1) { top: 0; }
        .hamburger span:nth-child(2) { top: 50%; transform: translateY(-50%); }
        .hamburger span:nth-child(3) { bottom: 0; }
        .mobile-toggle.active .hamburger span:nth-child(1) { top: 50%; transform: translateY(-50%) rotate(45deg); }
        .mobile-toggle.active .hamburger span:nth-child(2) { opacity: 0; }
        .mobile-toggle.active .hamburger span:nth-child(3) { bottom: 50%; transform: translateY(50%) rotate(-45deg); }
        .mobile-menu { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: var(--background); z-index: 999; display: flex; flex-direction: column; opacity: 0; visibility: hidden; transition: var(--transition-slow); }
        .mobile-menu.active { opacity: 1; visibility: visible; }
        .mobile-menu-header { display: flex; align-items: center; justify-content: space-between; padding: 0 var(--spacing-sm); height: 4.5rem; border-bottom: 1px solid var(--glass-border); }
        .mobile-menu-close { width: 2.5rem; height: 2.5rem; display: flex; align-items: center; justify-content: center; background: var(--glass); border: 1px solid var(--glass-border); border-radius: var(--radius); color: var(--text-primary); }
        .mobile-menu-content { flex: 1; padding: var(--spacing-lg) var(--spacing-sm); overflow-y: auto; }
        .mobile-search-wrapper { padding-bottom: var(--spacing-lg); margin-bottom: var(--spacing-lg); border-bottom: 1px solid var(--glass-border); }
        .mobile-search-wrapper .header-search { width: 100%; }
        .mobile-nav-section h3 { color: var(--text-muted); font-size: 0.75rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.1em; margin-bottom: var(--spacing-md); }
        .mobile-nav-items { display: flex; flex-direction: column; gap: var(--spacing-xs); }
        .mobile-nav-item { display: flex; align-items: center; gap: var(--spacing-sm); padding: var(--spacing-md); color: var(--text-secondary); text-decoration: none; border-radius: var(--radius-md); }
        .mobile-nav-item-icon { font-size: 1.25rem; width: 2.5rem; height: 2.5rem; display: flex; align-items: center; justify-content: center; background: var(--glass); border-radius: var(--radius); }
        .mobile-nav-item:hover { background: var(--glass); color: var(--text-primary); }
        .main-content { margin-top: 4.5rem; padding: var(--spacing-lg) var(--spacing-sm); max-width: 1400px; margin-left: auto; margin-right: auto; }
        @media (min-width: 768px) { .nav-container { padding: 0 var(--spacing-md); } .main-content { padding: var(--spacing-xl) var(--spacing-md); } }
        @media (min-width: 1024px) { .mobile-toggle { display: none; } .nav-desktop { display: flex; align-items: center; flex-grow: 1; justify-content: flex-end; gap: var(--spacing-sm); } .header-search { width: 280px; } .nav-menu { gap: var(--spacing-xs); } }
        @media (min-width: 1280px) { .logo-text-extended { display: inline; } }

        /* --- STYLES SPÉCIFIQUES AU JEU VRD (adaptés au thème) --- */
        .game-card {
            background: var(--surface); border: 1px solid var(--glass-border); border-radius: var(--radius-lg);
            padding: var(--spacing-lg); width: 100%; box-shadow: var(--shadow-xl);
            backdrop-filter: blur(10px); text-align: center; animation: fadeIn 0.5s ease-out;
            max-width: 1000px; margin: 0 auto;
        }
        @keyframes fadeIn { from { opacity: 0; transform: scale(0.98); } to { opacity: 1; transform: scale(1); } }
        
        .screen { display: none; flex: 1; }
        .screen.active { display: flex; flex-direction: column; align-items: center; justify-content: center; }

        .game-card h1 {
            font-family: 'Poppins', sans-serif; font-size: clamp(2rem, 5vw, 3rem);
            font-weight: 800; color: var(--primary-light); margin-bottom: var(--spacing-sm);
        }
        .game-card h2 {
            font-family: 'Poppins', sans-serif; font-size: clamp(1.2rem, 4vw, 1.8rem);
            font-weight: 700; color: var(--text-primary); margin-bottom: var(--spacing-md);
            line-height: 1.4; max-width: 800px;
        }
        .game-card p { font-size: 1.1rem; color: var(--text-secondary); margin-bottom: var(--spacing-md); max-width: 600px; }
        
        .btn {
            display: inline-flex; align-items: center; justify-content: center; gap: 0.5rem;
            background: var(--primary); color: white; border: none; padding: 0.8rem 1.8rem;
            border-radius: var(--radius-full); font-size: 1rem; font-weight: 600;
            cursor: pointer; transition: var(--transition); box-shadow: 0 4px 10px rgba(99, 102, 241, 0.2);
        }
        .btn:hover { background: var(--primary-dark); transform: translateY(-2px); box-shadow: var(--shadow-glow); }
        .btn:active { transform: translateY(0); }
        .btn:disabled { opacity: 0.7; cursor: not-allowed; background: var(--surface-hover); box-shadow: none; }

        .game-header-stats { display: flex; gap: var(--spacing-md); align-items: center; justify-content: center; margin-bottom: var(--spacing-md); }
        .game-header-item { display: flex; align-items: center; gap: var(--spacing-xs); font-size: 1.25rem; font-weight: 700; font-family: 'JetBrains Mono', monospace; background: var(--surface-elevated); padding: 0.5rem 1.25rem; border-radius: var(--radius-full); }
        .timer-display.warning { animation: pulse 1s infinite; color: var(--incorrect); }
        @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.05); } }
        
        .answer-grid { display: grid; grid-template-columns: 1fr; gap: var(--spacing-sm); width: 100%; max-width: 1000px; margin-top: var(--spacing-md); }
        @media (min-width: 640px) { .answer-grid { grid-template-columns: 1fr 1fr; } }

        .answer-btn {
            width: 100%; background: var(--surface-elevated); color: var(--text-secondary);
            padding: 1rem; border: 1px solid var(--glass-border); border-radius: var(--radius-md);
            text-align: center; font-size: 1rem; cursor: pointer; transition: var(--transition);
        }
        .answer-btn:not(:disabled):hover { background: var(--surface-hover); border-color: var(--primary); color: var(--text-primary); }
        .answer-btn.correct { background: var(--correct) !important; color: var(--text-primary) !important; border-color: var(--correct) !important; animation: bounce 0.5s ease; }
        .answer-btn.incorrect { background: var(--incorrect) !important; color: var(--text-primary) !important; border-color: var(--incorrect) !important; animation: shake 0.5s ease; }
        .answer-btn:disabled { cursor: not-allowed; }

        @keyframes bounce { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-6px); } }
        @keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-5px); } 75% { transform: translateX(5px); } }

        .feedback-text { margin-top: var(--spacing-md); font-size: 1.2rem; font-weight: bold; }
        .feedback-solution { font-size: 1rem; font-weight: normal; color: var(--text-secondary); margin-top: var(--spacing-xs); }

        .material-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 1rem; width: 100%; max-width: 1000px; margin-top: 2rem; }
        .material-card { background: var(--surface-elevated); border: 2px solid var(--glass-border); color: var(--text-secondary); border-radius: 1rem; padding: 1.5rem; text-align: center; cursor: pointer; transition: all 0.3s ease; display: flex; flex-direction: column; align-items: center; gap: 1rem; }
        .material-icon { font-size: 3rem; line-height: 1; }
        .material-card:not(.disabled):hover { transform: translateY(-4px); border-color: var(--primary); color: var(--text-primary); }
        .material-card.selected { border-color: var(--secondary); box-shadow: 0 0 0 2px var(--secondary); }
        .material-card.correct { background: var(--correct) !important; color: white !important; border-color: var(--correct) !important; }
        .material-card.incorrect { background: var(--incorrect) !important; color: white !important; border-color: var(--incorrect) !important; }
        .material-card.disabled { cursor: not-allowed; opacity: 0.7; }

        .elevation-input, .text-input { font-size: 1.5rem; padding: 1rem 2rem; border: 1px solid var(--glass-border); border-radius: var(--radius-md); text-align: center; width: 100%; max-width: 400px; transition: all 0.3s ease; margin: 1rem 0; background-color: var(--surface-elevated); color: var(--text-primary); }
        .elevation-input:focus, .text-input:focus { outline: none; border-color: var(--primary); box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.3); }
        
        .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1.5rem; width: 100%; max-width: 800px; margin: 2rem 0; }
        .stat-card { background: var(--surface-elevated); padding: 1.5rem; border-radius: 1rem; text-align: center; border: 1px solid var(--glass-border); }
        .stat-label { font-weight: 500; color: var(--text-secondary); margin-bottom: 0.5rem; }
        .stat-number { font-weight: 800; font-size: 2.5rem; color: var(--primary); }

        .pipe-game-container { display: flex; flex-direction: column; align-items: center; gap: 1rem; width: 100%; }
        .pipe-tray { display: flex; gap: 1rem; background: var(--surface-elevated); padding: 1rem; border-radius: 1rem; flex-wrap: wrap; justify-content: center; }
        .pipe-piece-draggable { width: 50px; height: 50px; cursor: grab; position: relative; }
        .pipe-piece-draggable.dragging { opacity: 0.5; }
        .pipe-count { position: absolute; bottom: -5px; right: -5px; background: var(--primary); color: white; border-radius: 50%; width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 0.8rem; }
        .pipe-grid-container { display: grid; grid-template-columns: repeat(var(--grid-cols, 5), 1fr); border: 2px solid var(--glass-border); border-radius: 1rem; overflow: hidden; background: var(--background); width: 100%; max-width: 90vw; }
        .grid-cell { border: 1px solid var(--glass-border); display: flex; align-items: center; justify-content: center; position: relative; background-color: var(--surface); aspect-ratio: 1 / 1; }
        .grid-cell.start-node { background-color: var(--correct); color: white; font-weight: bold; font-size: 1.5rem; }
        .grid-cell.end-node { background-color: var(--incorrect); color: white; font-weight: bold; font-size: 1.5rem; }
        .pipe-piece-placed { width: 100%; height: 100%; transition: transform 0.2s ease; cursor: pointer; }
        .grid-cell.obstacle-node { background-color: var(--surface-hover); }

        .draggable { padding: 0.75rem; background: var(--surface-elevated); border: 1px solid var(--glass-border); border-radius: 0.5rem; cursor: grab; transition: all 0.2s ease; user-select: none; }
        .draggable:active { cursor: grabbing; background: var(--surface-hover); }
        .drop-zone { border: 2px dashed var(--glass-border); border-radius: 0.75rem; background: var(--surface); transition: all 0.2s ease; min-height: 100px; padding: 1rem; display: flex; flex-wrap: gap: 0.5rem; justify-content: center; align-items: center; }
        .drop-zone.hover { border-color: var(--primary); background: var(--surface-hover); }
        .drop-zone.filled { border-style: solid; }

        .confetti { position: fixed; width: 10px; height: 10px; top: -20px; animation: fall 3s linear forwards; }
        @keyframes fall { to { transform: translateY(100vh) rotate(360deg); } }
    </style>
</head>
<body>

    <!-- Header -->
    <header class="header" id="header">
        <nav class="nav-container">
            <a href="index.html" class="logo" onclick="event.preventDefault(); navigateTo('index.html');">
                <svg class="logo-icon" viewBox="20 10 60 75" xmlns="http://www.w3.org/2000/svg" fill="none">
                    <path d="M20 85V40C20 34.4772 24.4772 30 30 30H40C45.5228 30 50 34.4772 50 40V85H20Z" fill="var(--primary-light)" fill-opacity="0.7"></path>
                    <path d="M50 85V20C50 14.4772 54.4772 10 60 10H70C75.5228 10 80 14.4772 80 20V85H50Z" fill="var(--primary)"></path>
                </svg>
                <span class="logo-text">LTD<span class="logo-text-extended">&nbsp;Simulator</span></span>
            </a>
            <div class="nav-desktop">
                 <form action="recherche.html" method="GET" class="header-search">
                     <i class="fas fa-search"></i>
                     <input type="search" name="query" placeholder="Rechercher..." aria-label="Rechercher">
                 </form>
                 <ul class="nav-menu">
                     <li class="nav-item"><a href="index.html" class="nav-link" onclick="event.preventDefault(); navigateTo('index.html')"><i class="fas fa-home"></i>&nbsp;Accueil</a></li>
                     <li class="nav-item"><a href="simulateur.html" class="nav-link active" onclick="event.preventDefault(); navigateTo('simulateur.html')"><i class="fas fa-gamepad"></i>&nbsp;Simulateurs</a></li>
                     <li class="nav-item"><a href="test.html" class="nav-link" onclick="event.preventDefault(); navigateTo('test.html')"><i class="fas fa-brain"></i>&nbsp;Tests</a></li>
                     <li class="nav-item"><a href="challenges.html" class="nav-link" onclick="event.preventDefault(); navigateTo('challenges.html')"><i class="fas fa-trophy"></i>&nbsp;Challenges</a></li>
                     <li class="nav-item"><a href="emploi.html" class="nav-link" onclick="event.preventDefault(); navigateTo('emploi.html')"><i class="fas fa-briefcase"></i>&nbsp;Nos offres d'emploi</a></li>
                     <li class="nav-item"><a href="histoire.html" class="nav-link" onclick="event.preventDefault(); navigateTo('histoire.html')"><i class="fas fa-scroll"></i>&nbsp;Histoire du BTP</a></li>
                     <li class="nav-item"><a href="#" class="nav-link" onclick="event.preventDefault(); navigateTo('quiz.html')"><i class="fas fa-question-circle"></i>&nbsp;Quiz</a></li>
                 </ul>
                 <div class="nav-actions">
                     <button class="theme-toggle" id="themeToggle" onclick="toggleTheme()" title="Changer de thème">
                         <i class="fas fa-moon" id="themeIcon"></i>
                     </button>
                 </div>
            </div>
            <button class="mobile-toggle" id="mobileToggle" onclick="toggleMobileMenu()">
                <span class="hamburger"><span></span><span></span><span></span></span>
            </button>
        </nav>
    </header>

    <!-- Mobile Menu -->
    <div class="mobile-menu" id="mobileMenu">
        <div class="mobile-menu-header">
            <a href="index.html" class="logo" onclick="event.preventDefault(); toggleMobileMenu(); navigateTo('index.html');">
                <svg class="logo-icon" viewBox="20 10 60 75" xmlns="http://www.w3.org/2000/svg" fill="none">
                    <path d="M20 85V40C20 34.4772 24.4772 30 30 30H40C45.5228 30 50 34.4772 50 40V85H20Z" fill="var(--primary-light)" fill-opacity="0.7"></path>
                    <path d="M50 85V20C50 14.4772 54.4772 10 60 10H70C75.5228 10 80 14.4772 80 20V85H50Z" fill="var(--primary)"></path>
                </svg>
                <span class="logo-text">LTD<span class="logo-text-extended">&nbsp;Simulator</span></span>
            </a>
            <button class="mobile-menu-close" onclick="toggleMobileMenu()"><i class="fas fa-times"></i></button>
        </div>
        <div class="mobile-menu-content">
            <div class="mobile-search-wrapper">
                <form action="recherche.html" method="GET" class="header-search">
                    <i class="fas fa-search"></i>
                    <input type="search" name="query" placeholder="Rechercher..." aria-label="Rechercher">
                </form>
            </div>
            <div class="mobile-nav-section">
                <h3>Navigation</h3>
                <div class="mobile-nav-items">
                    <!-- Mobile nav items will be populated by JS -->
                </div>
            </div>
        </div>
    </div>

    <!-- Main Content -->
    <main class="main-content">
        <div id="game-container">
            <!-- Écran d'accueil -->
            <div id="homeScreen" class="screen active game-card">
                <h1>Simulateur Projeteur VRD</h1>
                <p>Testez vos connaissances et devenez un expert en Voirie et Réseaux Divers. Prêt à relever le défi ?</p>
                <button id="startBtn" class="btn">Démarrer la simulation</button>
            </div>

            <!-- Écran de question -->
            <div id="questionScreen" class="screen game-card">
                <div class="game-header-stats">
                    <div id="scoreDisplay" class="game-header-item">
                        <span>⭐</span>
                        <span id="score">0</span>
                    </div>
                    <div id="timerDisplay" class="game-header-item timer-display">
                        <span>⏰</span>
                        <span id="timer">--:--</span>
                    </div>
                </div>
                <h2 id="questionText"></h2>
                <div id="answerContainer"></div>
                <div id="feedbackText" class="feedback-text"></div>
                <div style="text-align: center; margin-top: 1.5rem;">
                    <button id="nextBtn" class="btn" style="display: none;">Question Suivante</button>
                </div>
            </div>

            <!-- Écran final -->
            <div id="finalScreen" class="screen game-card">
                <h1>Simulation Terminée !</h1>
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-label">Score Final</div>
                        <div id="finalScore" class="stat-number">0</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Bonnes Réponses</div>
                        <div id="correctAnswers" class="stat-number">0 / 0</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Temps Total</div>
                        <div id="totalTime" class="stat-number">00:00</div>
                    </div>
                </div>
                <p id="finalMessage" style="font-size: 1.5rem; margin-top: 1rem; margin-bottom: 2rem;"></p>
                <button id="restartBtnFinal" class="btn">Recommencer</button>
            </div>
        </div>
    </main>

    <script>
        // --- HEADER & NAVIGATION SCRIPT ---
        let currentTheme = localStorage.getItem('theme') || 'dark';
        function navigateTo(pageFile) { window.location.href = pageFile; }
        function updateThemeUI() {
            const themeIcon = document.getElementById('themeIcon');
            if (!themeIcon) return;
            document.body.classList.toggle('light-mode', currentTheme === 'light');
            themeIcon.className = currentTheme === 'light' ? 'fas fa-moon' : 'fas fa-sun';
        }
        function toggleTheme() {
            currentTheme = currentTheme === 'light' ? 'dark' : 'light';
            localStorage.setItem('theme', currentTheme);
            updateThemeUI();
        }
        function toggleMobileMenu() {
            const mobileToggle = document.getElementById('mobileToggle');
            const mobileMenu = document.getElementById('mobileMenu');
            mobileToggle.classList.toggle('active');
            mobileMenu.classList.toggle('active');
            document.body.style.overflow = mobileMenu.classList.contains('active') ? 'hidden' : '';
        }

        // --- VRD SIMULATOR SCRIPT ---
        document.addEventListener('DOMContentLoaded', () => {
            // --- Initialisation du Header ---
            updateThemeUI();
            const desktopNav = document.querySelector('.nav-desktop .nav-menu');
            const mobileNavContainer = document.querySelector('.mobile-menu .mobile-nav-items');
            if(desktopNav && mobileNavContainer) {
                mobileNavContainer.innerHTML = '';
                desktopNav.querySelectorAll('.nav-item').forEach(item => {
                    const link = item.querySelector('a');
                    const newNavItem = document.createElement('a');
                    newNavItem.href = link.href;
                    newNavItem.className = 'mobile-nav-item';
                    newNavItem.onclick = (e) => {
                        e.preventDefault();
                        toggleMobileMenu();
                        if (link.href && !link.href.endsWith('#')) {
                           navigateTo(link.getAttribute('href'));
                        }
                    };
                    const iconDiv = document.createElement('div');
                    iconDiv.className = 'mobile-nav-item-icon';
                    iconDiv.innerHTML = link.querySelector('i').outerHTML;
                    const textNode = document.createElement('h4');
                    textNode.textContent = link.textContent.trim();
                    newNavItem.appendChild(iconDiv);
                    newNavItem.appendChild(textNode);
                    mobileNavContainer.appendChild(newNavItem);
                });
            }

            // --- SÉLECTION DES ÉLÉMENTS DU DOM ---
            const dom = {
                screens: { home: document.getElementById('homeScreen'), question: document.getElementById('questionScreen'), final: document.getElementById('finalScreen'), },
                buttons: { start: document.getElementById('startBtn'), next: document.getElementById('nextBtn'), restartFinal: document.getElementById('restartBtnFinal'), },
                displays: { score: document.getElementById('score'), timer: document.getElementById('timer'), timerContainer: document.getElementById('timerDisplay'), questionText: document.getElementById('questionText'), answerContainer: document.getElementById('answerContainer'), feedback: document.getElementById('feedbackText'), finalScore: document.getElementById('finalScore'), correctAnswers: document.getElementById('correctAnswers'), totalTime: document.getElementById('totalTime'), finalMessage: document.getElementById('finalMessage'), },
            };

            // --- DONNÉES DU JEU ---
            const questions = [ { type: 'qcm', text: "Quel est le rôle principal d'un Projeteur VRD ?", answers: [{ text: "Concevoir les bâtiments", correct: false }, { text: "Aménager les espaces extérieurs et réseaux", correct: true }, { text: "Gérer la comptabilité du chantier", correct: false }, { text: "Peindre les murs", correct: false }], solution: "Le Projeteur VRD (Voirie et Réseaux Divers) conçoit les routes, les systèmes d'assainissement, les réseaux d'eau, de gaz, d'électricité et de télécommunications.", points: 100, time: 30, }, { type: 'multiple-choice', text: "Identifiez les matériaux adaptés pour une couche de fondation de chaussée. (Plusieurs réponses possibles)", answers: [{ text: "Terre végétale", correct: false, icon: "🌱" }, { text: "Grave non traitée (GNT)", correct: true, icon: "🪨" }, { text: "Sable", correct: false, icon: "🏖️" }, { text: "Grave-ciment", correct: true, icon: "🧱" }], solution: "La couche de fondation assure la portance de la chaussée. Les graves non traitées (GNT) et les graves traitées (comme le grave-ciment) sont des matériaux couramment utilisés.", points: 150, time: 45, }, { type: 'calculation', text: "Un regard A est à une altitude de 125.50m. Un regard B, distant de 50m, est à 124.75m. Quelle est la pente du réseau en % ?", solution: "Calcul : ((125.50 - 124.75) / 50) * 100 = 1.5%.", correctAnswer: 1.5, tolerance: 0.01, points: 200, time: 60, }, { type: 'pipe-connect', text: "Connectez le réseau d'eaux usées du point A au point B.", gridSize: { rows: 5, cols: 7 }, start: { row: 2, col: 0 }, end: { row: 2, col: 6 }, pieces: { straight: 5, corner: 4 }, solution: "Il faut créer un chemin continu de A à B en utilisant les pièces disponibles.", points: 350, time: 180, pipeColor: '#8B5CF6' }, { type: 'chronological-order', text: "Mettez dans l'ordre les étapes de la construction d'une voirie simple.", items: ["Terrassement", "Mise en place de la couche de fondation", "Pose des bordures et caniveaux", "Application du revêtement (enrobé)", "Signalisation et finitions"], solution: "L'ordre logique est : Terrassement > Couche de fondation > Bordures/Caniveaux > Revêtement > Signalisation.", points: 250, time: 90, }, { type: 'scenario', text: "Scénario : Erreur de conception", scenario: "Vous recevez un plan où un réseau d'eaux pluviales (EP) est connecté directement en amont d'une station d'épuration conçue uniquement pour les eaux usées (EU). Quelle est l'erreur majeure et que proposez-vous ?", answers: [{ text: "Aucune erreur, c'est une pratique standard.", correct: false }, { text: "L'erreur est le mélange des réseaux. Il faut créer un exutoire séparé pour les EP.", correct: true }, { text: "Il faut juste une plus grosse canalisation.", correct: false }, { text: "Il faut inverser le sens de la pente.", correct: false }], solution: "Les réseaux d'eaux pluviales et d'eaux usées doivent être séparatifs. Les EP n'ont pas besoin d'être traitées en station d'épuration et risqueraient de la saturer.", points: 300, time: 75, }, { type: 'qcm', text: "De quelle couleur est le grillage avertisseur pour un réseau électrique enterré ?", answers: [{ text: "Bleu", correct: false }, { text: "Jaune", correct: false }, { text: "Rouge", correct: true }, { text: "Vert", correct: false }], solution: "Le grillage avertisseur rouge signale la présence d'un câble ou d'une canalisation électrique.", points: 100, time: 25 }, { type: 'text-input', text: "Quel logiciel de CAO/DAO est le plus utilisé par les projeteurs VRD ?", correctAnswer: "AutoCAD", solution: "AutoCAD est le standard de l'industrie pour le dessin technique en 2D et 3D.", points: 120, time: 30 }, { type: 'calculation', text: "Une route de 6m de large a une pente en travers de 2.5% depuis l'axe. Quelle est la différence de niveau (en cm) entre l'axe et le bord ?", correctAnswer: 7.5, tolerance: 0.1, solution: "Calcul : (6m / 2) * 0.025 = 0.075m, soit 7.5 cm.", points: 200, time: 60 }, { type: 'multiple-choice', text: "Quels éléments font partie des 'réseaux secs' ?", answers: [{ text: "Adduction d'Eau Potable", correct: false, icon: "💧" }, { text: "Électricité (Basse Tension)", correct: true, icon: "⚡" }, { text: "Télécommunications (Fibre)", correct: true, icon: "📡" }, { text: "Assainissement EU", correct: false, icon: "🚽" }], solution: "Les réseaux secs transportent de l'énergie ou de l'information (électricité, télécom), par opposition aux réseaux humides (eau, assainissement).", points: 150, time: 40 }, { type: 'chronological-order', text: "Ordonnez les couches d'une structure de chaussée, de la plus profonde à la surface.", items: ["Couche de forme", "Couche de fondation", "Couche de base", "Couche de roulement"], solution: "La structure est bâtie depuis le terrain naturel (couche de forme) jusqu'à la surface (couche de roulement).", points: 250, time: 70 }, { type: 'qcm', text: "Que signifie 'DT-DICT' ?", answers: [{ text: "Document Technique - Dessin Industriel et Commercial", correct: false }, { text: "Déclaration de Travaux - Demande d'Intervention sur la Chaussée", correct: false }, { text: "Déclaration de projet de Travaux - Déclaration d'Intention de Commencement de Travaux", correct: true }, { text: "Dossier Technique - Directive Interne de Chantier", correct: false }], solution: "La DT-DICT est une procédure obligatoire pour s'informer sur la présence de réseaux enterrés avant de commencer des travaux.", points: 180, time: 45 }, { type: 'calculation', text: "Un bassin de rétention a une surface de 200m². Il pleut 30 litres/m². Quel volume d'eau (en m³) le bassin doit-il stocker ?", correctAnswer: 6, tolerance: 0.1, solution: "Calcul : 200 m² * 30 L/m² = 6000 Litres. Comme 1000L = 1m³, le volume est de 6 m³.", points: 220, time: 75 }, { type: 'text-input', text: "Comment nomme-t-on le plan représentant les altitudes du terrain le long d'un axe ?", correctAnswer: "Profil en long", solution: "Le profil en long est une coupe verticale qui montre le relief du terrain et le projet le long d'un axe.", points: 150, time: 40 }, { type: 'scenario', text: "Scénario : Réseau inconnu", scenario: "En creusant une tranchée, vous découvrez une canalisation non répertoriée. Quelle est la première action à entreprendre ?", answers: [{ text: "Continuer en faisant attention.", correct: false }, { text: "Arrêter les travaux dans la zone et alerter le conducteur de travaux.", correct: true }, { text: "Essayer d'identifier le réseau en le perçant légèrement.", correct: false }, { text: "Recouvrir et ne rien dire.", correct: false }], solution: "La sécurité prime. Il faut immédiatement arrêter les travaux, sécuriser la zone et informer la hiérarchie.", points: 300, time: 60 }, { type: 'pipe-connect', text: "Connectez le réseau de gaz. Le chemin doit passer par la vanne de coupure.", gridSize: { rows: 6, cols: 8 }, start: { row: 5, col: 3 }, end: { row: 0, col: 7 }, obstacles: [{row: 2, col: 4, type: 'valve'}], pieces: { straight: 8, corner: 6 }, solution: "Le chemin doit être continu de A à B et obligatoirement passer par la case 'valve'.", points: 400, time: 200, bonus: true, pipeColor: '#FBBF24' } ];
            
            let gameState = {};
            
            // --- GESTION AUDIO ---
            let isSoundOn = false; // Le son est désactivé par défaut
            const sounds = {
                start: new Tone.Synth({ oscillator: { type: "fatsawtooth" }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.3 } }).toDestination(),
                correct: new Tone.Synth({ oscillator: { type: "triangle" }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.2 } }).toDestination(),
                incorrect: new Tone.Synth({ oscillator: { type: "square" }, envelope: { attack: 0.01, decay: 0.3, sustain: 0, release: 0.2 } }).toDestination(),
                finish: new Tone.Synth({ oscillator: { type: "sine" }, envelope: { attack: 0.1, decay: 0.5, sustain: 0.3, release: 1 } }).toDestination(),
                click: new Tone.MembraneSynth({ pitchDecay: 0.01, octaves: 2, envelope: { attack: 0.001, decay: 0.2, sustain: 0 } }).toDestination(),
                timer_tick: new Tone.Synth({ oscillator: { type: 'sine' }, volume: -10, envelope: { attack: 0.001, decay: 0.1, sustain: 0, release: 0.1 } }).toDestination(),
                drag: new Tone.NoiseSynth({ noise: { type: 'pink' }, envelope: { attack: 0.005, decay: 0.1, sustain: 0 } }).toDestination(),
                drop: new Tone.MembraneSynth({ pitchDecay: 0.008, octaves: 4, envelope: { attack: 0.001, decay: 0.3, sustain: 0 } }).toDestination(),
                confetti: new Tone.PluckSynth({ attackNoise: 1, dampening: 4000, resonance: 0.7 }).toDestination()
            };
            
            function playSound(sound, ...args) {
                if (isSoundOn && sound && typeof sound.triggerAttackRelease === 'function') {
                    sound.triggerAttackRelease(...args);
                }
            }

            // --- FONCTIONS PRINCIPALES DU JEU ---
            function initGame() {
                gameState = { score: 0, currentQuestionIndex: -1, timeLeft: 0, timerInterval: null, totalTime: 0, totalTimeInterval: null, questions: shuffleArray([...questions]), answeredQuestions: [], isQuestionAnswered: false, };
                updateScore(0);
                switchScreen('home');
                dom.displays.timer.textContent = '--:--';
                dom.displays.timerContainer.classList.remove('warning');
            }

            function startGame() {
                // Demande à l'utilisateur d'interagir pour activer l'audio
                Tone.start();
                isSoundOn = true; // Activer le son au démarrage du jeu
                playSound(sounds.start, "C4", "8n");
                gameState.answeredQuestions = new Array(gameState.questions.length).fill(null);
                startTotalTimer();
                nextQuestion();
            }

            function nextQuestion() {
                if (gameState.currentQuestionIndex >= gameState.questions.length - 1) { endGame(); return; }
                gameState.currentQuestionIndex++;
                displayQuestion();
            }

            function displayQuestion() {
                clearTimeout(gameState.timerInterval);
                dom.displays.feedback.innerHTML = '';
                dom.buttons.next.style.display = 'none';
                const question = gameState.questions[gameState.currentQuestionIndex];
                gameState.isQuestionAnswered = false;
                dom.displays.questionText.innerHTML = `Question ${gameState.currentQuestionIndex + 1}/${gameState.questions.length}: ${question.text}`;
                dom.displays.answerContainer.innerHTML = '';
                const interfaceBuilder = { 'qcm': createQCMInterface, 'scenario': createQCMInterface, 'multiple-choice': createMultipleChoiceInterface, 'calculation': createCalculationInterface, 'text-input': createTextInputInterface, 'chronological-order': createChronologicalOrderInterface, 'pipe-connect': createPipeConnectInterface, }[question.type];
                if (interfaceBuilder) interfaceBuilder(question);
                startTimer(question.time);
                switchScreen('question');
            }

            function endGame() {
                clearInterval(gameState.timerInterval);
                clearInterval(gameState.totalTimeInterval);
                playSound(sounds.finish, "C5", "1n", Tone.now() + 0.1);
                launchConfetti();
                const correctCount = gameState.answeredQuestions.filter(a => a && a.isCorrect).length;
                const totalQuestions = gameState.questions.length;
                dom.displays.finalScore.textContent = gameState.score;
                dom.displays.correctAnswers.textContent = `${correctCount} / ${totalQuestions}`;
                dom.displays.totalTime.textContent = formatTime(gameState.totalTime);
                let message = "Excellent travail ! Vous avez l'étoffe d'un expert !";
                if (correctCount / totalQuestions < 0.5) message = "C'est un bon début, continuez à vous entraîner !";
                else if (correctCount / totalQuestions < 0.8) message = "Très bon score, vous progressez bien !";
                dom.displays.finalMessage.textContent = message;
                switchScreen('final');
            }

            function createQCMInterface(question) {
                const answerGrid = document.createElement('div');
                answerGrid.className = 'answer-grid';
                question.answers.forEach((answer, index) => {
                    const btn = document.createElement('button');
                    btn.className = 'answer-btn';
                    btn.innerHTML = answer.text;
                    btn.onclick = () => handleAnswer(index, index);
                    answerGrid.appendChild(btn);
                });
                dom.displays.answerContainer.appendChild(answerGrid);
            }

            function createMultipleChoiceInterface(question) {
                const materialGrid = document.createElement('div');
                materialGrid.className = 'material-grid';
                question.answers.forEach((answer, index) => {
                    const card = document.createElement('div');
                    card.className = 'material-card';
                    card.dataset.index = index;
                    card.innerHTML = `<div class="material-icon">${answer.icon || '❔'}</div><p>${answer.text}</p>`;
                    card.onclick = () => { if (!gameState.isQuestionAnswered) card.classList.toggle('selected'); };
                    materialGrid.appendChild(card);
                });
                dom.displays.answerContainer.appendChild(materialGrid);
                addSubmitButton(() => {
                    const selectedCards = dom.displays.answerContainer.querySelectorAll('.material-card.selected');
                    const selectedIndices = Array.from(selectedCards).map(c => parseInt(c.dataset.index));
                    handleAnswer(selectedIndices, selectedIndices);
                });
            }

            function createCalculationInterface(question) {
                const input = document.createElement('input');
                input.type = 'number';
                input.step = 'any';
                input.className = 'elevation-input';
                input.placeholder = 'Votre réponse...';
                dom.displays.answerContainer.appendChild(input);
                addSubmitButton(() => { const value = parseFloat(input.value); if (!isNaN(value)) handleAnswer(value, value); });
            }

            function createTextInputInterface(question) {
                const input = document.createElement('input');
                input.type = 'text';
                input.className = 'text-input';
                input.placeholder = 'Votre réponse...';
                dom.displays.answerContainer.appendChild(input);
                addSubmitButton(() => { const value = input.value.trim(); if (value) handleAnswer(value, value); });
            }

            function createChronologicalOrderInterface(question) {
                const container = document.createElement('div');
                container.style.width = '100%';
                container.style.maxWidth = '800px';
                const dropZone = document.createElement('div');
                dropZone.className = 'drop-zone';
                dropZone.textContent = 'Déposez les étapes ici';
                const draggableContainer = document.createElement('div');
                draggableContainer.className = 'mt-6 p-4 flex flex-wrap gap-2 justify-center';
                shuffleArray([...question.items]).forEach((item) => {
                    const el = document.createElement('div');
                    el.className = 'draggable';
                    el.textContent = item;
                    el.draggable = true;
                    el.dataset.id = item;
                    el.addEventListener('dragstart', e => { playSound(sounds.drag, "8n"); e.dataTransfer.setData('text/plain', item); setTimeout(() => el.style.opacity = '0.5', 0); });
                    el.addEventListener('dragend', () => el.style.opacity = '1');
                    draggableContainer.appendChild(el);
                });
                container.appendChild(dropZone);
                container.appendChild(draggableContainer);
                dom.displays.answerContainer.appendChild(container);
                [dropZone, draggableContainer].forEach(zone => {
                    zone.addEventListener('dragover', e => { e.preventDefault(); zone.classList.add('hover'); });
                    zone.addEventListener('dragleave', () => zone.classList.remove('hover'));
                    zone.addEventListener('drop', e => {
                        e.preventDefault();
                        playSound(sounds.drop, "C3", "8n");
                        zone.classList.remove('hover');
                        if (dropZone.textContent === 'Déposez les étapes ici') { dropZone.textContent = ''; dropZone.classList.add('filled'); }
                        const data = e.dataTransfer.getData('text/plain');
                        const draggable = document.querySelector(`.draggable[data-id="${data}"]`);
                        if (draggable) zone.appendChild(draggable);
                        if (dropZone.children.length === 0) { dropZone.textContent = 'Déposez les étapes ici'; dropZone.classList.remove('filled'); }
                    });
                });
                addSubmitButton(() => { const droppedItems = Array.from(dropZone.children).map(child => child.dataset.id); handleAnswer(droppedItems, droppedItems); });
            }
            
            function createPipeConnectInterface(question) {
                const container = document.createElement('div');
                container.className = 'pipe-game-container';
                const pipeTray = document.createElement('div');
                pipeTray.className = 'pipe-tray';
                const createDraggablePipe = (type, count) => {
                    const piece = document.createElement('div');
                    piece.className = 'pipe-piece-draggable';
                    piece.draggable = true;
                    piece.dataset.pipeType = type;
                    piece.innerHTML = getPipeSVG(type, 0, question.pipeColor) + `<span class="pipe-count" id="pipe-count-${type}">${count}</span>`;
                    piece.addEventListener('dragstart', e => { if (parseInt(document.getElementById(`pipe-count-${type}`).textContent) > 0) { playSound(sounds.drag, "8n"); e.dataTransfer.setData('text/plain', type); piece.classList.add('dragging'); } else { e.preventDefault(); } });
                    piece.addEventListener('dragend', () => piece.classList.remove('dragging'));
                    return piece;
                };
                Object.keys(question.pieces).forEach(type => pipeTray.appendChild(createDraggablePipe(type, question.pieces[type])));
                const gridContainer = document.createElement('div');
                gridContainer.className = 'pipe-grid-container';
                gridContainer.style.setProperty('--grid-cols', question.gridSize.cols);
                gridContainer.id = 'pipe-grid';
                for (let r = 0; r < question.gridSize.rows; r++) {
                    for (let c = 0; c < question.gridSize.cols; c++) {
                        const cell = document.createElement('div');
                        cell.className = 'grid-cell';
                        cell.dataset.row = r;
                        cell.dataset.col = c;
                        if (r === question.start.row && c === question.start.col) cell.classList.add('start-node');
                        else if (r === question.end.row && c === question.end.col) cell.classList.add('end-node');
                        else if (question.obstacles?.some(o => o.row === r && o.col === c)) {
                            cell.classList.add('obstacle-node');
                            cell.innerHTML = `<div style="width: 66%; height: 66%; color: var(--text-primary);"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 3v18M3 12h18M12 12a4 4 0 1 0 0-0.001 4 4 0 0 0 0 0.001z"/><path d="m16 8-4-4-4 4"/></svg></div>`;
                            cell.dataset.obstacle = true;
                        }
                        cell.addEventListener('dragover', e => e.preventDefault());
                        cell.addEventListener('drop', e => {
                            e.preventDefault();
                            if (cell.innerHTML !== '' || cell.classList.contains('start-node') || cell.classList.contains('end-node')) return;
                            const type = e.dataTransfer.getData('text/plain');
                            const countEl = document.getElementById(`pipe-count-${type}`);
                            let count = parseInt(countEl.textContent);
                            if (count > 0) {
                                playSound(sounds.drop, "C3", "8n");
                                count--;
                                countEl.textContent = count;
                                const placedPiece = document.createElement('div');
                                placedPiece.className = 'pipe-piece-placed';
                                placedPiece.dataset.pipeType = type;
                                placedPiece.dataset.rotation = 0;
                                placedPiece.innerHTML = getPipeSVG(type, 0, question.pipeColor);
                                placedPiece.addEventListener('click', () => {
                                    if (gameState.isQuestionAnswered) return;
                                    let currentRotation = parseInt(placedPiece.dataset.rotation);
                                    currentRotation = (currentRotation + 90) % 360;
                                    placedPiece.dataset.rotation = currentRotation;
                                    placedPiece.style.transform = `rotate(${currentRotation}deg)`;
                                });
                                placedPiece.addEventListener('contextmenu', (ev) => {
                                    ev.preventDefault();
                                    if (gameState.isQuestionAnswered) return;
                                    cell.innerHTML = '';
                                    const typeToRemove = placedPiece.dataset.pipeType;
                                    const countElToRemove = document.getElementById(`pipe-count-${typeToRemove}`);
                                    countElToRemove.textContent = parseInt(countElToRemove.textContent) + 1;
                                });
                                cell.appendChild(placedPiece);
                            }
                        });
                        gridContainer.appendChild(cell);
                    }
                }
                container.appendChild(pipeTray);
                container.appendChild(gridContainer);
                dom.displays.answerContainer.appendChild(container);
                addSubmitButton(() => {
                    const placedPipes = [];
                    gridContainer.querySelectorAll('.pipe-piece-placed').forEach(p => {
                        const cell = p.parentElement;
                        placedPipes.push({ row: parseInt(cell.dataset.row), col: parseInt(cell.dataset.col), type: p.dataset.pipeType, rotation: parseInt(p.dataset.rotation) });
                    });
                    handleAnswer(placedPipes, placedPipes);
                }, 'Vérifier');
            }

            function addSubmitButton(callback, text = 'Valider') {
                const submitBtn = document.createElement('button');
                submitBtn.textContent = text;
                submitBtn.className = 'btn';
                submitBtn.style.marginTop = '2rem';
                submitBtn.onclick = callback;
                dom.displays.answerContainer.appendChild(submitBtn);
            }

            function handleAnswer(userAnswer, answerForStorage) {
                if (gameState.isQuestionAnswered) return;
                clearInterval(gameState.timerInterval);
                gameState.isQuestionAnswered = true;
                const question = gameState.questions[gameState.currentQuestionIndex];
                let isCorrect = false;
                switch (question.type) {
                    case 'qcm': case 'scenario': isCorrect = userAnswer !== null && question.answers[userAnswer].correct; break;
                    case 'multiple-choice':
                        const correctIndices = question.answers.map((a, i) => a.correct ? i : -1).filter(i => i !== -1);
                        isCorrect = userAnswer && userAnswer.length === correctIndices.length && userAnswer.every(index => correctIndices.includes(index));
                        break;
                    case 'calculation': isCorrect = userAnswer !== null && Math.abs(userAnswer - question.correctAnswer) <= (question.tolerance || 0.01); break;
                    case 'text-input': isCorrect = userAnswer && userAnswer.toLowerCase().trim() === question.correctAnswer.toLowerCase().trim(); break;
                    case 'chronological-order': isCorrect = userAnswer && userAnswer.length === question.items.length && userAnswer.every((item, index) => item === question.items[index]); break;
                    case 'pipe-connect': isCorrect = checkPipeConnection(userAnswer, question); break;
                }
                gameState.answeredQuestions[gameState.currentQuestionIndex] = { answer: answerForStorage, isCorrect: isCorrect };
                if (isCorrect) {
                    playSound(sounds.correct, "C5", "8n", Tone.now() + 0.1);
                    dom.displays.feedback.innerHTML = "Bonne réponse !";
                    dom.displays.feedback.style.color = 'var(--correct)';
                    let pointsGained = question.points;
                    if (question.bonus) pointsGained *= 2;
                    updateScore(gameState.score + pointsGained);
                } else {
                    playSound(sounds.incorrect, "C3", "8n", Tone.now() + 0.1);
                    dom.displays.feedback.innerHTML = `Réponse incorrecte. <br><span class="feedback-solution">${question.solution}</span>`;
                    dom.displays.feedback.style.color = 'var(--incorrect)';
                }
                showSolutionVisuals(question, isCorrect);
                dom.buttons.next.style.display = 'inline-flex';
            }

            function showSolutionVisuals(question, isCorrect) {
                 const answerElements = dom.displays.answerContainer.querySelectorAll('.answer-btn, .material-card, .draggable, .pipe-piece-placed, input, button');
                 answerElements.forEach(el => { el.style.pointerEvents = 'none'; el.disabled = true; if(el.classList.contains('material-card')) el.classList.add('disabled'); });
                 switch (question.type) {
                    case 'qcm': case 'scenario': dom.displays.answerContainer.querySelectorAll('.answer-btn').forEach((btn, index) => { if (question.answers[index].correct) btn.classList.add('correct'); }); break;
                    case 'multiple-choice':
                        dom.displays.answerContainer.querySelectorAll('.material-card').forEach((card, index) => {
                            const isSelected = card.classList.contains('selected');
                            const isCorrectAnswer = question.answers[index].correct;
                            if (isCorrectAnswer) card.classList.add('correct');
                            else if (isSelected && !isCorrectAnswer) card.classList.add('incorrect');
                        });
                        break;
                 }
            }
            
            function getPipeSVG(type, rotation, color) {
                let path = '';
                if (type === 'straight') path = `<path d="M0 50 L100 50" stroke="${color}" stroke-width="12" stroke-linecap="round" />`;
                else if (type === 'corner') path = `<path d="M0 50 L50 50 L50 100" stroke="${color}" stroke-width="12" stroke-linecap="round" fill="none" />`;
                return `<svg class="w-full h-full" viewBox="0 0 100 100" style="transform: rotate(${rotation}deg);">${path}</svg>`;
            }

            function getPipeExits(pipe) {
                if (!pipe) return [];
                const { type, rotation } = pipe;
                const r = (parseInt(rotation, 10) + 360) % 360;
                if (type === 'straight') return (r === 90 || r === 270) ? ['up', 'down'] : ['left', 'right'];
                if (type === 'corner') { if (r === 0) return ['left', 'down']; if (r === 90) return ['down', 'right']; if (r === 180) return ['right', 'up']; if (r === 270) return ['up', 'left']; }
                return [];
            }
            
            function checkPipeConnection(placedPipes, question) {
                if (!Array.isArray(placedPipes)) return false;
                const { gridSize, start, end, obstacles } = question;
                const grid = Array(gridSize.rows).fill(null).map(() => Array(gridSize.cols).fill(null));
                placedPipes.forEach(p => { grid[p.row][p.col] = p; });
                let queue = [];
                let visited = new Set();
                const directions = { up: { r: -1, c: 0, opp: 'down' }, down: { r: 1, c: 0, opp: 'up' }, left: { r: 0, c: -1, opp: 'right' }, right: { r: 0, c: 1, opp: 'left' } };
                for (const dirName in directions) {
                    const { r, c, opp } = directions[dirName];
                    const nextR = start.row + r;
                    const nextC = start.col + c;
                    const key = `${nextR},${nextC}`;
                    if (nextR >= 0 && nextR < gridSize.rows && nextC >= 0 && nextC < gridSize.cols) {
                        const nextPipe = grid[nextR]?.[nextC];
                        if (nextPipe && getPipeExits(nextPipe).includes(opp)) { visited.add(key); queue.push({ row: nextR, col: nextC, path: [`${start.row},${start.col}`, key] }); }
                    }
                }
                while (queue.length > 0) {
                    const current = queue.shift();
                    const currentPipe = grid[current.row][current.col];
                    const currentExits = getPipeExits(currentPipe);
                    for (const dirName in directions) {
                        const { r, c } = directions[dirName];
                        if (currentExits.includes(dirName)) {
                            const neighborR = current.row + r;
                            const neighborC = current.col + c;
                            if (neighborR === end.row && neighborC === end.col) {
                                const finalPath = [...current.path, `${end.row},${end.col}`];
                                const pathSet = new Set(finalPath);
                                const allObstaclesOnPath = obstacles?.every(o => pathSet.has(`${o.row},${o.col}`)) ?? true;
                                if (allObstaclesOnPath) return true;
                            }
                        }
                    }
                    for (const dirName in directions) {
                        const { r, c, opp } = directions[dirName];
                        if (currentExits.includes(dirName)) {
                            const nextR = current.row + r;
                            const nextC = current.col + c;
                            const key = `${nextR},${nextC}`;
                            if (nextR >= 0 && nextR < gridSize.rows && nextC >= 0 && nextC < gridSize.cols && !visited.has(key)) {
                                const nextPipe = grid[nextR]?.[nextC];
                                if (nextPipe && getPipeExits(nextPipe).includes(opp)) { visited.add(key); queue.push({ row: nextR, col: nextC, path: [...current.path, key] }); }
                            }
                        }
                    }
                }
                return false;
            }

            function switchScreen(screenName) { Object.values(dom.screens).forEach(s => s.classList.remove('active')); dom.screens[screenName].classList.add('active'); }
            function updateScore(newScore) { gameState.score = newScore; dom.displays.score.textContent = newScore; }
            function startTimer(duration) {
                gameState.timeLeft = duration;
                dom.displays.timerContainer.classList.remove('warning');
                function update() {
                    dom.displays.timer.textContent = formatTime(gameState.timeLeft);
                    if (gameState.timeLeft <= 10 && gameState.timeLeft > 0) {
                        dom.displays.timerContainer.classList.add('warning');
                        playSound(sounds.timer_tick, 'C6', '16n');
                    }
                    if (gameState.timeLeft <= 0) { clearInterval(gameState.timerInterval); handleAnswer(null, 'timeout'); }
                    gameState.timeLeft--;
                }
                update();
                gameState.timerInterval = setInterval(update, 1000);
            }
            function startTotalTimer() { gameState.totalTime = 0; if(gameState.totalTimeInterval) clearInterval(gameState.totalTimeInterval); gameState.totalTimeInterval = setInterval(() => { gameState.totalTime++; }, 1000); }
            function formatTime(seconds) { const mins = Math.floor(seconds / 60); const secs = seconds % 60; return `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`; }
            function shuffleArray(array) { for (let i = array.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [array[i], array[j]] = [array[j], array[i]]; } return array; }
            function launchConfetti() {
                playSound(sounds.confetti, "C4", "8n", Tone.now());
                playSound(sounds.confetti, "G4", "8n", Tone.now() + 0.1);
                playSound(sounds.confetti, "E5", "8n", Tone.now() + 0.2);
                for (let i = 0; i < 100; i++) { const c = document.createElement('div'); c.className = 'confetti'; c.style.left = `${Math.random()*100}vw`; c.style.animationDelay = `${Math.random()*2}s`; c.style.backgroundColor=`hsl(${Math.random()*360},100%,50%)`; c.style.transform=`scale(${Math.random()*.5+.5})`; document.body.appendChild(c); setTimeout(()=>c.remove(),3000);}
            }

            dom.buttons.start.addEventListener('click', () => { startGame(); playSound(sounds.click, "C2", "8n"); });
            dom.buttons.next.addEventListener('click', () => { nextQuestion(); playSound(sounds.click, "C2", "8n"); });
            dom.buttons.restartFinal.addEventListener('click', () => { initGame(); playSound(sounds.click, "C2", "8n"); });

            initGame();
        });
    </script>
</body>
</html>
