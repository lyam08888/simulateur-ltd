<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Simulateur pour d√©couvrir le m√©tier de projeteur VRD avec deux modes de jeu.">
    <title>LTD Simulator - Projeteur VRD</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500&family=Poppins:wght@700;800&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <style>
        /* --- TH√àME GLOBAL (issu du site principal) --- */
        :root {
            /* Colors */
            --primary: #6366f1;
            --primary-dark: #4f46e5;
            --primary-light: #a5b4fc;
            --secondary: #10b981;
            --secondary-dark: #059669;
            --accent: #f59e0b;
            --accent-dark: #d97706;
            --correct: #22c55e;
            --incorrect: #ef4444;
            
            /* Surfaces */
            --background: #0f172a;
            --surface: #1e293b;
            --surface-elevated: #334155;
            --surface-hover: #475569;
            --glass: rgba(255, 255, 255, 0.05);
            --glass-border: rgba(255, 255, 255, 0.15);
            
            /* Text */
            --text-primary: #f8fafc;
            --text-secondary: #cbd5e1;
            --text-muted: #94a3b8;
            
            /* Shadows */
            --shadow-glow: 0 0 15px 0px rgba(99, 102, 241, 0.3);
            --shadow-lg: 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);
            --shadow-xl: 0 25px 50px -12px rgb(0 0 0 / 0.25);

            /* Animation */
            --transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            --transition-slow: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            
            /* Spacing */
            --spacing-xs: 0.5rem;
            --spacing-sm: 1rem;
            --spacing-md: 1.5rem;
            --spacing-lg: 2rem;
            --spacing-xl: 3rem;
            
            /* Borders */
            --radius-sm: 0.375rem;
            --radius: 0.5rem;
            --radius-md: 0.75rem;
            --radius-lg: 1rem;
            --radius-xl: 1.5rem;
            --radius-full: 9999px;
        }

        body.light-mode {
            --background: #f1f5f9;
            --surface: #ffffff;
            --surface-elevated: #e2e8f0;
            --surface-hover: #cbd5e1;
            --glass: rgba(0, 0, 0, 0.05);
            --glass-border: rgba(0, 0, 0, 0.1);
            --text-primary: #1e293b;
            --text-secondary: #475569;
            --text-muted: #64748b;
            --shadow-glow: 0 0 15px 0px rgba(99, 102, 241, 0.2);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }
        html { scroll-behavior: smooth; }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--background);
            color: var(--text-primary);
            line-height: 1.6;
            overflow-x: hidden;
            transition: var(--transition-slow);
        }

        body::before {
            content: ''; position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: radial-gradient(circle at 15% 50%, rgba(99, 102, 241, 0.15) 0%, transparent 40%), radial-gradient(circle at 85% 30%, rgba(16, 185, 129, 0.15) 0%, transparent 40%), radial-gradient(circle at 50% 85%, rgba(245, 158, 11, 0.1) 0%, transparent 40%);
            pointer-events: none; z-index: -1; animation: background-pan 30s linear infinite;
        }
        
        @keyframes background-pan { 0% { background-position: 0% 50%; } 50% { background-position: 100% 50%; } 100% { background-position: 0% 50%; } }
        
        [onclick], .nav-link, .mobile-nav-item, .theme-toggle, .mobile-toggle, .btn { cursor: pointer; }

        .header { position: fixed; top: 0; left: 0; right: 0; z-index: 1000; backdrop-filter: blur(20px) saturate(180%); background: rgba(15, 23, 42, 0.8); border-bottom: 1px solid var(--glass-border); transition: var(--transition); }
        body.light-mode .header { background: rgba(255, 255, 255, 0.8); }
        .nav-container { max-width: 1400px; margin: 0 auto; padding: 0 var(--spacing-sm); display: flex; align-items: center; justify-content: space-between; height: 4.5rem; gap: var(--spacing-md); }
        .logo { display: flex; align-items: center; gap: var(--spacing-sm); text-decoration: none; color: var(--text-primary); font-weight: 800; font-size: 1.2rem; transition: var(--transition); }
        .logo:hover { transform: scale(1.05); text-shadow: 0 0 10px var(--primary-light); }
        .logo-icon { height: 1.8rem; width: auto; vertical-align: -0.4rem; }
        .logo-text-extended { display: none; }
        .nav-desktop { display: none; }
        .nav-menu { display: flex; align-items: center; gap: var(--spacing-xs); list-style: none; }
        .nav-item { position: relative; }
        .nav-link { display: flex; align-items: center; gap: var(--spacing-xs); padding: var(--spacing-xs) var(--spacing-sm); color: var(--text-secondary); text-decoration: none; font-weight: 500; border-radius: var(--radius); transition: var(--transition); }
        .nav-link:hover { color: var(--text-primary); background: var(--glass); }
        .nav-link.active { color: var(--text-primary); background: linear-gradient(45deg, rgba(99, 102, 241, 0.1), rgba(99, 102, 241, 0.2)); font-weight: 600; }
        .header-search { position: relative; }
        .header-search input { width: 100%; background-color: var(--surface); border: 1px solid var(--glass-border); color: var(--text-secondary); border-radius: var(--radius); padding: 0.5rem 1rem 0.5rem 2.5rem; font-size: 0.9rem; transition: var(--transition); }
        .header-search input::placeholder { color: var(--text-muted); }
        .header-search input:focus { background-color: var(--surface-elevated); border-color: var(--primary); color: var(--text-primary); box-shadow: 0 0 0 2px var(--primary-dark); outline: none; }
        .header-search .fa-search { position: absolute; left: 1rem; top: 50%; transform: translateY(-50%); color: var(--text-muted); }
        .nav-actions { display: flex; align-items: center; gap: var(--spacing-sm); }
        .theme-toggle { display: flex; align-items: center; justify-content: center; width: 2.5rem; height: 2.5rem; background: var(--glass); border: 1px solid var(--glass-border); border-radius: var(--radius); color: var(--text-secondary); transition: var(--transition); }
        .theme-toggle:hover { background: var(--surface-elevated); color: var(--text-primary); transform: rotate(15deg); }
        .mobile-toggle { display: flex; flex-direction: column; justify-content: center; align-items: center; width: 2.5rem; height: 2.5rem; background: var(--glass); border: 1px solid var(--glass-border); border-radius: var(--radius); transition: var(--transition); }
        .hamburger { position: relative; width: 1.25rem; height: 1rem; }
        .hamburger span { position: absolute; left: 0; width: 100%; height: 2px; background: var(--text-primary); border-radius: 1px; transition: var(--transition); }
        .hamburger span:nth-child(1) { top: 0; }
        .hamburger span:nth-child(2) { top: 50%; transform: translateY(-50%); }
        .hamburger span:nth-child(3) { bottom: 0; }
        .mobile-toggle.active .hamburger span:nth-child(1) { top: 50%; transform: translateY(-50%) rotate(45deg); }
        .mobile-toggle.active .hamburger span:nth-child(2) { opacity: 0; }
        .mobile-toggle.active .hamburger span:nth-child(3) { bottom: 50%; transform: translateY(50%) rotate(-45deg); }
        .mobile-menu { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: var(--background); z-index: 999; display: flex; flex-direction: column; opacity: 0; visibility: hidden; transition: var(--transition-slow); }
        .mobile-menu.active { opacity: 1; visibility: visible; }
        .mobile-menu-header { display: flex; align-items: center; justify-content: space-between; padding: 0 var(--spacing-sm); height: 4.5rem; border-bottom: 1px solid var(--glass-border); }
        .mobile-menu-close { width: 2.5rem; height: 2.5rem; display: flex; align-items: center; justify-content: center; background: var(--glass); border: 1px solid var(--glass-border); border-radius: var(--radius); color: var(--text-primary); }
        .mobile-menu-content { flex: 1; padding: var(--spacing-lg) var(--spacing-sm); overflow-y: auto; }
        .mobile-search-wrapper { padding-bottom: var(--spacing-lg); margin-bottom: var(--spacing-lg); border-bottom: 1px solid var(--glass-border); }
        .mobile-search-wrapper .header-search { width: 100%; }
        .mobile-nav-section h3 { color: var(--text-muted); font-size: 0.75rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.1em; margin-bottom: var(--spacing-md); }
        .mobile-nav-items { display: flex; flex-direction: column; gap: var(--spacing-xs); }
        .mobile-nav-item { display: flex; align-items: center; gap: var(--spacing-sm); padding: var(--spacing-md); color: var(--text-secondary); text-decoration: none; border-radius: var(--radius-md); }
        .mobile-nav-item-icon { font-size: 1.25rem; width: 2.5rem; height: 2.5rem; display: flex; align-items: center; justify-content: center; background: var(--glass); border-radius: var(--radius); }
        .mobile-nav-item:hover { background: var(--glass); color: var(--text-primary); }
        .main-content { margin-top: 4.5rem; padding: var(--spacing-lg) var(--spacing-sm); max-width: 1400px; margin-left: auto; margin-right: auto; }
        @media (min-width: 768px) { .nav-container { padding: 0 var(--spacing-md); } .main-content { padding: var(--spacing-xl) var(--spacing-md); } }
        @media (min-width: 1024px) { .mobile-toggle { display: none; } .nav-desktop { display: flex; align-items: center; flex-grow: 1; justify-content: flex-end; gap: var(--spacing-sm); } .header-search { width: 280px; } .nav-menu { gap: var(--spacing-xs); } }
        @media (min-width: 1280px) { .logo-text-extended { display: inline; } }

        /* --- STYLES SP√âCIFIQUES AU JEU VRD (adapt√©s au th√®me) --- */
        .game-card {
            background: var(--surface); border: 1px solid var(--glass-border); border-radius: var(--radius-xl);
            padding: var(--spacing-lg); width: 100%; box-shadow: var(--shadow-xl);
            backdrop-filter: blur(10px); text-align: center; animation: fadeIn 0.5s ease-out;
            max-width: 1200px; margin: 0 auto;
        }
        @media (min-width: 768px) { .game-card { padding: var(--spacing-xl); } }
        @keyframes fadeIn { from { opacity: 0; transform: scale(0.98); } to { opacity: 1; transform: scale(1); } }
        
        .screen { display: none; flex: 1; }
        .screen.active { display: flex; flex-direction: column; align-items: center; justify-content: center; }

        .game-card h1 {
            font-family: 'Poppins', sans-serif; font-size: clamp(2.2rem, 6vw, 3.5rem);
            font-weight: 800; color: var(--primary-light); margin-bottom: var(--spacing-sm);
        }
        .game-card h2 {
            font-family: 'Poppins', sans-serif; font-size: clamp(1.5rem, 4vw, 2rem);
            font-weight: 700; color: var(--text-primary); margin-bottom: var(--spacing-md);
            line-height: 1.4; max-width: 900px;
        }
        .game-card p { font-size: 1.2rem; color: var(--text-secondary); margin-bottom: var(--spacing-md); max-width: 700px; }
        
        .btn {
            display: inline-flex; align-items: center; justify-content: center; gap: 0.5rem;
            background: var(--primary); color: white; border: none; padding: 1rem 2rem;
            border-radius: var(--radius-full); font-size: 1.1rem; font-weight: 600;
            transition: var(--transition); box-shadow: 0 4px 10px rgba(99, 102, 241, 0.2);
        }
        .btn:hover { background: var(--primary-dark); transform: translateY(-2px); box-shadow: var(--shadow-glow); }
        .btn:active { transform: translateY(0); }
        .btn:disabled { opacity: 0.7; cursor: not-allowed; background: var(--surface-hover); box-shadow: none; }
        .btn.secondary { background: var(--surface-elevated); color: var(--text-primary); }
        .btn.secondary:hover { background: var(--surface-hover); }

        .mode-selection { display: flex; flex-direction: column; gap: var(--spacing-md); margin-top: var(--spacing-lg); width: 100%; max-width: 600px; }
        @media (min-width: 640px) { .mode-selection { flex-direction: row; } }
        .mode-selection .btn { flex: 1; flex-direction: column; height: auto; padding: 1.5rem; }
        .mode-selection .btn span { font-size: 0.9rem; font-weight: 400; color: var(--text-secondary); margin-top: 0.5rem; }
        body.light-mode .mode-selection .btn span { color: var(--text-muted); }

        .game-header { display: flex; justify-content: space-between; align-items: center; width: 100%; margin-bottom: var(--spacing-md); }
        .game-header-stats { display: flex; gap: var(--spacing-md); align-items: center; justify-content: center; flex-wrap: wrap; }
        .game-header-item { display: flex; align-items: center; gap: var(--spacing-xs); font-size: 1.3rem; font-weight: 700; font-family: 'JetBrains Mono', monospace; background: var(--surface-elevated); padding: 0.6rem 1.5rem; border-radius: var(--radius-full); }
        .timer-display.warning { animation: pulse 1s infinite; color: var(--incorrect); }
        @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.05); } }
        
        .answer-grid { display: grid; grid-template-columns: 1fr; gap: var(--spacing-sm); width: 100%; max-width: 1000px; margin-top: var(--spacing-md); }
        @media (min-width: 640px) { .answer-grid { grid-template-columns: 1fr 1fr; gap: var(--spacing-md); } }

        .answer-btn {
            width: 100%; background: var(--surface-elevated); color: var(--text-secondary);
            padding: 1.2rem; border: 1px solid var(--glass-border); border-radius: var(--radius-md);
            text-align: center; font-size: 1.1rem; transition: var(--transition);
        }
        .answer-btn:not(:disabled):hover { background: var(--surface-hover); border-color: var(--primary); color: var(--text-primary); transform: translateY(-2px); }
        .answer-btn.correct { background: var(--correct) !important; color: var(--text-primary) !important; border-color: var(--correct) !important; animation: bounce 0.5s ease; }
        .answer-btn.incorrect { background: var(--incorrect) !important; color: var(--text-primary) !important; border-color: var(--incorrect) !important; animation: shake 0.5s ease; }
        .answer-btn:disabled { cursor: not-allowed; }

        @keyframes bounce { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-6px); } }
        @keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-5px); } 75% { transform: translateX(5px); } }

        .feedback-text { margin-top: var(--spacing-md); font-size: 1.2rem; font-weight: bold; }
        .feedback-solution { font-size: 1rem; font-weight: normal; color: var(--text-secondary); margin-top: var(--spacing-xs); }

        .material-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 1.5rem; width: 100%; max-width: 1100px; margin-top: 2rem; }
        .material-card { background: var(--surface-elevated); border: 2px solid var(--glass-border); color: var(--text-secondary); border-radius: 1rem; padding: 1.5rem; text-align: center; cursor: pointer; transition: all 0.3s ease; display: flex; flex-direction: column; align-items: center; gap: 1rem; }
        .material-icon { font-size: 3.5rem; line-height: 1; }
        .material-card:not(.disabled):hover { transform: translateY(-5px); border-color: var(--primary); color: var(--text-primary); box-shadow: var(--shadow-glow); }
        .material-card.selected { border-color: var(--secondary); box-shadow: 0 0 0 3px var(--secondary); }
        .material-card.correct { background: var(--correct) !important; color: white !important; border-color: var(--correct) !important; }
        .material-card.incorrect { background: var(--incorrect) !important; color: white !important; border-color: var(--incorrect) !important; }
        .material-card.disabled { cursor: not-allowed; opacity: 0.7; }

        .elevation-input, .text-input { font-size: 1.8rem; padding: 1rem 2rem; border: 1px solid var(--glass-border); border-radius: var(--radius-md); text-align: center; width: 100%; max-width: 450px; transition: all 0.3s ease; margin: 1rem 0; background-color: var(--surface-elevated); color: var(--text-primary); }
        .elevation-input:focus, .text-input:focus { outline: none; border-color: var(--primary); box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.3); }
        
        .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1.5rem; width: 100%; max-width: 800px; margin: 2rem 0; }
        .stat-card { background: var(--surface-elevated); padding: 1.5rem; border-radius: 1rem; text-align: center; border: 1px solid var(--glass-border); }
        .stat-label { font-weight: 500; color: var(--text-secondary); margin-bottom: 0.5rem; }
        .stat-number { font-weight: 800; font-size: 2.5rem; color: var(--primary); }

        .pipe-game-container { display: flex; flex-direction: column; align-items: center; gap: 1.5rem; width: 100%; }
        .pipe-tray { display: flex; gap: 1rem; background: var(--surface-elevated); padding: 1rem; border-radius: 1rem; flex-wrap: wrap; justify-content: center; }
        .pipe-piece-draggable { width: 60px; height: 60px; cursor: grab; position: relative; }
        .pipe-piece-draggable.dragging { opacity: 0.5; }
        .pipe-count { position: absolute; bottom: -5px; right: -5px; background: var(--primary); color: white; border-radius: 50%; width: 22px; height: 22px; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 0.9rem; }
        .pipe-grid-container { 
            display: grid; 
            grid-template-columns: repeat(var(--grid-cols, 5), 1fr); 
            border: 2px solid var(--glass-border); 
            border-radius: 1rem; 
            overflow: hidden; 
            background: var(--background); 
            width: clamp(320px, 90vw, 800px);
            margin-left: auto;
            margin-right: auto;
        }
        .grid-cell { border: 1px solid var(--glass-border); display: flex; align-items: center; justify-content: center; position: relative; background-color: var(--surface); aspect-ratio: 1 / 1; }
        .grid-cell.start-node { background-color: var(--correct); color: white; font-weight: bold; font-size: 1.5rem; }
        .grid-cell.end-node { background-color: var(--incorrect); color: white; font-weight: bold; font-size: 1.5rem; }
        .pipe-piece-placed { width: 100%; height: 100%; transition: transform 0.2s ease; cursor: pointer; }
        .grid-cell.obstacle-node { background-color: var(--surface-hover); display: flex; align-items: center; justify-content: center; }

        .draggable { padding: 0.75rem 1.25rem; background: var(--surface-elevated); border: 1px solid var(--glass-border); border-radius: 0.5rem; cursor: grab; transition: all 0.2s ease; user-select: none; text-align: center; }
        .draggable:active { cursor: grabbing; background: var(--surface-hover); }
        .draggable.correct { background: var(--correct) !important; color: white !important; }
        .draggable.incorrect { background: var(--incorrect) !important; color: white !important; }

        .drop-zone-container { display: flex; flex-direction: column; align-items: center; gap: 2rem; width: 100%; }
        .draggable-container { display: flex; flex-wrap: wrap; gap: 0.75rem; justify-content: center; background: var(--surface); padding: 1rem; border-radius: 1rem; width: 100%; max-width: 1000px; }
        .category-container { display: flex; gap: 1.5rem; width: 100%; justify-content: space-around; flex-direction: column; max-width: 1100px; }
        @media (min-width: 768px) { .category-container { flex-direction: row; } }
        .category-zone { border: 2px dashed var(--glass-border); border-radius: 1rem; background: var(--surface); transition: all 0.2s ease; min-height: 200px; padding: 1rem; display: flex; flex-direction: column; gap: 0.75rem; align-items: center; flex: 1; width: 100%; }
        .category-zone h4 { color: var(--text-secondary); margin-bottom: 1rem; font-size: 1.2rem; border-bottom: 2px solid var(--glass-border); padding-bottom: 0.5rem; width: 100%; }
        .category-zone.hover { border-color: var(--primary); background: var(--surface-hover); }

        .confetti { position: fixed; width: 10px; height: 10px; top: -20px; animation: fall 3s linear forwards; }
        @keyframes fall { to { transform: translateY(100vh) rotate(360deg); } }
    </style>
</head>
<body>

    <!-- Header -->
    <header class="header" id="header">
        <nav class="nav-container">
            <a href="index.html" class="logo" onclick="event.preventDefault(); navigateTo('index.html');">
                <svg class="logo-icon" viewBox="20 10 60 75" xmlns="http://www.w3.org/2000/svg" fill="none">
                    <path d="M20 85V40C20 34.4772 24.4772 30 30 30H40C45.5228 30 50 34.4772 50 40V85H20Z" fill="var(--primary-light)" fill-opacity="0.7"></path>
                    <path d="M50 85V20C50 14.4772 54.4772 10 60 10H70C75.5228 10 80 14.4772 80 20V85H50Z" fill="var(--primary)"></path>
                </svg>
                <span class="logo-text">LTD<span class="logo-text-extended">&nbsp;Simulator</span></span>
            </a>
            <div class="nav-desktop">
                 <form action="recherche.html" method="GET" class="header-search">
                     <i class="fas fa-search"></i>
                     <input type="search" name="query" placeholder="Rechercher..." aria-label="Rechercher">
                 </form>
                 <ul class="nav-menu">
                     <li class="nav-item"><a href="index.html" class="nav-link" onclick="event.preventDefault(); navigateTo('index.html')"><i class="fas fa-home"></i>&nbsp;Accueil</a></li>
                     <li class="nav-item"><a href="simulateur.html" class="nav-link active" onclick="event.preventDefault(); navigateTo('simulateur.html')"><i class="fas fa-gamepad"></i>&nbsp;Simulateurs</a></li>
                     <li class="nav-item"><a href="test.html" class="nav-link" onclick="event.preventDefault(); navigateTo('test.html')"><i class="fas fa-brain"></i>&nbsp;Tests</a></li>
                     <li class="nav-item"><a href="challenges.html" class="nav-link" onclick="event.preventDefault(); navigateTo('challenges.html')"><i class="fas fa-trophy"></i>&nbsp;Challenges</a></li>
                     <li class="nav-item"><a href="emploi.html" class="nav-link" onclick="event.preventDefault(); navigateTo('emploi.html')"><i class="fas fa-briefcase"></i>&nbsp;Nos offres d'emploi</a></li>
                     <li class="nav-item"><a href="histoire.html" class="nav-link" onclick="event.preventDefault(); navigateTo('histoire.html')"><i class="fas fa-scroll"></i>&nbsp;Histoire du BTP</a></li>
                     <li class="nav-item"><a href="#" class="nav-link" onclick="event.preventDefault(); navigateTo('quiz.html')"><i class="fas fa-question-circle"></i>&nbsp;Quiz</a></li>
                 </ul>
                 <div class="nav-actions">
                     <button class="theme-toggle" id="themeToggle" onclick="toggleTheme()" title="Changer de th√®me">
                         <i class="fas fa-moon" id="themeIcon"></i>
                     </button>
                 </div>
            </div>
            <button class="mobile-toggle" id="mobileToggle" onclick="toggleMobileMenu()">
                <span class="hamburger"><span></span><span></span><span></span></span>
            </button>
        </nav>
    </header>

    <!-- Mobile Menu -->
    <div class="mobile-menu" id="mobileMenu">
        <div class="mobile-menu-header">
            <a href="index.html" class="logo" onclick="event.preventDefault(); toggleMobileMenu(); navigateTo('index.html');">
                <svg class="logo-icon" viewBox="20 10 60 75" xmlns="http://www.w3.org/2000/svg" fill="none">
                    <path d="M20 85V40C20 34.4772 24.4772 30 30 30H40C45.5228 30 50 34.4772 50 40V85H20Z" fill="var(--primary-light)" fill-opacity="0.7"></path>
                    <path d="M50 85V20C50 14.4772 54.4772 10 60 10H70C75.5228 10 80 14.4772 80 20V85H50Z" fill="var(--primary)"></path>
                </svg>
                <span class="logo-text">LTD<span class="logo-text-extended">&nbsp;Simulator</span></span>
            </a>
            <button class="mobile-menu-close" onclick="toggleMobileMenu()"><i class="fas fa-times"></i></button>
        </div>
        <div class="mobile-menu-content">
            <div class="mobile-search-wrapper">
                <form action="recherche.html" method="GET" class="header-search">
                    <i class="fas fa-search"></i>
                    <input type="search" name="query" placeholder="Rechercher..." aria-label="Rechercher">
                </form>
            </div>
            <div class="mobile-nav-section">
                <h3>Navigation</h3>
                <div class="mobile-nav-items">
                    <!-- Mobile nav items will be populated by JS -->
                </div>
            </div>
        </div>
    </div>

    <!-- Main Content -->
    <main class="main-content">
        <div id="game-container">
            <!-- √âcran d'accueil -->
            <div id="homeScreen" class="screen active game-card">
                <h1>Simulateur Projeteur VRD</h1>
                <p>Choisissez votre mode de jeu pour commencer.</p>
                <div class="mode-selection">
                    <button id="startDiscoveryBtn" class="btn">
                        <i class="fas fa-search-plus fa-2x"></i>
                        Mode D√©couverte
                        <span>Apprenez les bases du m√©tier avec des jeux et explications.</span>
                    </button>
                    <button id="startProBtn" class="btn secondary">
                        <i class="fas fa-award fa-2x"></i>
                        Simulation Pro
                        <span>Testez vos connaissances avec des sc√©narios complexes.</span>
                    </button>
                </div>
            </div>

            <!-- √âcran de question -->
            <div id="questionScreen" class="screen game-card">
                <div class="game-header">
                    <button id="changeModeBtn" class="btn secondary" title="Retour √† l'accueil"><i class="fas fa-sign-out-alt"></i> Changer de Mode</button>
                    <div class="game-header-stats">
                        <div id="scoreDisplay" class="game-header-item">
                            <span>‚≠ê</span>
                            <span id="score">0</span>
                        </div>
                        <div id="timerDisplay" class="game-header-item timer-display">
                            <span>‚è∞</span>
                            <span id="timer">--:--</span>
                        </div>
                    </div>
                </div>
                <h2 id="questionText"></h2>
                <div id="answerContainer"></div>
                <div id="feedbackText" class="feedback-text"></div>
                <div style="text-align: center; margin-top: 1.5rem;">
                    <button id="nextBtn" class="btn" style="display: none;">Question Suivante <i class="fas fa-arrow-right"></i></button>
                </div>
            </div>

            <!-- √âcran final -->
            <div id="finalScreen" class="screen game-card">
                <h1>Simulation Termin√©e !</h1>
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-label">Score Final</div>
                        <div id="finalScore" class="stat-number">0</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Bonnes R√©ponses</div>
                        <div id="correctAnswers" class="stat-number">0 / 0</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Temps Total</div>
                        <div id="totalTime" class="stat-number">00:00</div>
                    </div>
                </div>
                <p id="finalMessage" style="font-size: 1.5rem; margin-top: 1rem; margin-bottom: 2rem;"></p>
                <button id="restartBtnFinal" class="btn">Recommencer le m√™me mode <i class="fas fa-redo"></i></button>
                <button id="homeBtnFinal" class="btn secondary" style="margin-top: 1rem;">Retour √† l'accueil</button>
            </div>
        </div>
    </main>

    <script>
        // --- HEADER & NAVIGATION SCRIPT ---
        let currentTheme = localStorage.getItem('theme') || 'dark';
        function navigateTo(pageFile) { window.location.href = pageFile; }
        function updateThemeUI() {
            const themeIcon = document.getElementById('themeIcon');
            if (!themeIcon) return;
            document.body.classList.toggle('light-mode', currentTheme === 'light');
            themeIcon.className = currentTheme === 'light' ? 'fas fa-sun' : 'fas fa-moon';
        }
        function toggleTheme() {
            currentTheme = currentTheme === 'light' ? 'dark' : 'light';
            localStorage.setItem('theme', currentTheme);
            updateThemeUI();
        }
        function toggleMobileMenu() {
            const mobileToggle = document.getElementById('mobileToggle');
            const mobileMenu = document.getElementById('mobileMenu');
            mobileToggle.classList.toggle('active');
            mobileMenu.classList.toggle('active');
            document.body.style.overflow = mobileMenu.classList.contains('active') ? 'hidden' : '';
        }

        // --- VRD SIMULATOR SCRIPT ---
        document.addEventListener('DOMContentLoaded', () => {
            // --- Initialisation du Header ---
            updateThemeUI();
            const desktopNav = document.querySelector('.nav-desktop .nav-menu');
            const mobileNavContainer = document.querySelector('.mobile-menu .mobile-nav-items');
            if(desktopNav && mobileNavContainer) {
                mobileNavContainer.innerHTML = '';
                desktopNav.querySelectorAll('.nav-item').forEach(item => {
                    const link = item.querySelector('a');
                    const newNavItem = document.createElement('a');
                    newNavItem.href = link.href;
                    newNavItem.className = 'mobile-nav-item';
                    newNavItem.onclick = (e) => {
                        e.preventDefault();
                        toggleMobileMenu();
                        if (link.href && !link.href.endsWith('#')) {
                            navigateTo(link.getAttribute('href'));
                        }
                    };
                    const iconDiv = document.createElement('div');
                    iconDiv.className = 'mobile-nav-item-icon';
                    iconDiv.innerHTML = link.querySelector('i').outerHTML;
                    const textNode = document.createElement('h4');
                    textNode.textContent = link.textContent.trim();
                    newNavItem.appendChild(iconDiv);
                    newNavItem.appendChild(textNode);
                    mobileNavContainer.appendChild(newNavItem);
                });
            }

            // --- S√âLECTION DES √âL√âMENTS DU DOM ---
            const dom = {
                screens: { home: document.getElementById('homeScreen'), question: document.getElementById('questionScreen'), final: document.getElementById('finalScreen'), },
                buttons: { 
                    startDiscovery: document.getElementById('startDiscoveryBtn'), 
                    startPro: document.getElementById('startProBtn'), 
                    next: document.getElementById('nextBtn'), 
                    restartFinal: document.getElementById('restartBtnFinal'),
                    homeFinal: document.getElementById('homeBtnFinal'),
                    changeMode: document.getElementById('changeModeBtn')
                },
                displays: { 
                    score: document.getElementById('score'), 
                    scoreContainer: document.getElementById('scoreDisplay'),
                    timer: document.getElementById('timer'), 
                    timerContainer: document.getElementById('timerDisplay'), 
                    questionText: document.getElementById('questionText'), 
                    answerContainer: document.getElementById('answerContainer'), 
                    feedback: document.getElementById('feedbackText'), 
                    finalScore: document.getElementById('finalScore'), 
                    correctAnswers: document.getElementById('correctAnswers'), 
                    totalTime: document.getElementById('totalTime'), 
                    finalMessage: document.getElementById('finalMessage'), 
                },
            };

            // --- DONN√âES DU JEU ---
            const proQuestions = [
                // Set 1 & 2
                { type: 'qcm', text: "Quel est le r√¥le principal d'un Projeteur VRD ?", answers: [{ text: "Concevoir les b√¢timents", correct: false }, { text: "Am√©nager les espaces ext√©rieurs et r√©seaux", correct: true }, { text: "G√©rer la comptabilit√© du chantier", correct: false }, { text: "Peindre les murs", correct: false }], solution: "Le Projeteur VRD (Voirie et R√©seaux Divers) con√ßoit les routes, les syst√®mes d'assainissement, les r√©seaux d'eau, de gaz, d'√©lectricit√© et de t√©l√©communications.", points: 100, time: 30, },
                { type: 'multiple-choice', text: "Identifiez les mat√©riaux adapt√©s pour une couche de fondation de chauss√©e. (Plusieurs r√©ponses possibles)", answers: [{ text: "Terre v√©g√©tale", correct: false, icon: "üå±" }, { text: "Grave non trait√©e (GNT)", correct: true, icon: "ü™®" }, { text: "Sable", correct: false, icon: "üèñÔ∏è" }, { text: "Grave-ciment", correct: true, icon: "üß±" }], solution: "La couche de fondation assure la portance de la chauss√©e. Les graves non trait√©es (GNT) et les graves trait√©es (comme le grave-ciment) sont des mat√©riaux couramment utilis√©s.", points: 150, time: 45, },
                { type: 'calculation', text: "Un regard A est √† une altitude de 125.50m. Un regard B, distant de 50m, est √† 124.75m. Quelle est la pente du r√©seau en % ?", solution: "Calcul : ((125.50 - 124.75) / 50) * 100 = 1.5%.", correctAnswer: 1.5, tolerance: 0.01, points: 200, time: 60, },
                { type: 'pipe-connect', text: "Connectez le r√©seau d'eaux us√©es du point A au point B.", gridSize: { rows: 5, cols: 7 }, start: { row: 2, col: 0 }, end: { row: 2, col: 6 }, pieces: { straight: 5, corner: 4 }, solution: "Il faut cr√©er un chemin continu de A √† B en utilisant les pi√®ces disponibles.", points: 350, time: 180, pipeColor: '#8B5CF6' },
                { type: 'chronological-order', text: "Mettez dans l'ordre les √©tapes de la construction d'une voirie simple.", items: ["Terrassement", "Mise en place de la couche de fondation", "Pose des bordures et caniveaux", "Application du rev√™tement (enrob√©)", "Signalisation et finitions"], solution: "L'ordre logique est : Terrassement > Couche de fondation > Bordures/Caniveaux > Rev√™tement > Signalisation.", points: 250, time: 90, },
                { type: 'scenario', text: "Sc√©nario : Erreur de conception", scenario: "Vous recevez un plan o√π un r√©seau d'eaux pluviales (EP) est connect√© directement en amont d'une station d'√©puration con√ßue uniquement pour les eaux us√©es (EU). Quelle est l'erreur majeure et que proposez-vous ?", answers: [{ text: "Aucune erreur, c'est une pratique standard.", correct: false }, { text: "L'erreur est le m√©lange des r√©seaux. Il faut cr√©er un exutoire s√©par√© pour les EP.", correct: true }, { text: "Il faut juste une plus grosse canalisation.", correct: false }, { text: "Il faut inverser le sens de la pente.", correct: false }], solution: "Les r√©seaux d'eaux pluviales et d'eaux us√©es doivent √™tre s√©paratifs. Les EP n'ont pas besoin d'√™tre trait√©es en station d'√©puration et risqueraient de la saturer.", points: 300, time: 75, },
                { type: 'qcm', text: "De quelle couleur est le grillage avertisseur pour un r√©seau √©lectrique enterr√© ?", answers: [{ text: "Bleu", correct: false }, { text: "Jaune", correct: false }, { text: "Rouge", correct: true }, { text: "Vert", correct: false }], solution: "Le grillage avertisseur rouge signale la pr√©sence d'un c√¢ble ou d'une canalisation √©lectrique.", points: 100, time: 25 },
                { type: 'text-input', text: "Quel logiciel de CAO/DAO est le plus utilis√© par les projeteurs VRD ?", correctAnswer: "AutoCAD", solution: "AutoCAD est le standard de l'industrie pour le dessin technique en 2D et 3D.", points: 120, time: 30 },
                { type: 'calculation', text: "Une route de 6m de large a une pente en travers de 2.5% depuis l'axe. Quelle est la diff√©rence de niveau (en cm) entre l'axe et le bord ?", correctAnswer: 7.5, tolerance: 0.1, solution: "Calcul : (6m / 2) * 0.025 = 0.075m, soit 7.5 cm.", points: 200, time: 60 },
                { type: 'multiple-choice', text: "Quels √©l√©ments font partie des 'r√©seaux secs' ?", answers: [{ text: "Adduction d'Eau Potable", correct: false, icon: "üíß" }, { text: "√âlectricit√© (Basse Tension)", correct: true, icon: "‚ö°" }, { text: "T√©l√©communications (Fibre)", correct: true, icon: "üì°" }, { text: "Assainissement EU", correct: false, icon: "üöΩ" }], solution: "Les r√©seaux secs transportent de l'√©nergie ou de l'information (√©lectricit√©, t√©l√©com), par opposition aux r√©seaux humides (eau, assainissement).", points: 150, time: 40 },
                { type: 'chronological-order', text: "Ordonnez les couches d'une structure de chauss√©e, de la plus profonde √† la surface.", items: ["Couche de forme", "Couche de fondation", "Couche de base", "Couche de roulement"], solution: "La structure est b√¢tie depuis le terrain naturel (couche de forme) jusqu'√† la surface (couche de roulement).", points: 250, time: 70 },
                { type: 'qcm', text: "Que signifie 'DT-DICT' ?", answers: [{ text: "Document Technique - Dessin Industriel et Commercial", correct: false }, { text: "D√©claration de Travaux - Demande d'Intervention sur la Chauss√©e", correct: false }, { text: "D√©claration de projet de Travaux - D√©claration d'Intention de Commencement de Travaux", correct: true }, { text: "Dossier Technique - Directive Interne de Chantier", correct: false }], solution: "La DT-DICT est une proc√©dure obligatoire pour s'informer sur la pr√©sence de r√©seaux enterr√©s avant de commencer des travaux.", points: 180, time: 45 },
                { type: 'calculation', text: "Un bassin de r√©tention a une surface de 200m¬≤. Il pleut 30 litres/m¬≤. Quel volume d'eau (en m¬≥) le bassin doit-il stocker ?", correctAnswer: 6, tolerance: 0.1, solution: "Calcul : 200 m¬≤ * 30 L/m¬≤ = 6000 Litres. Comme 1000L = 1m¬≥, le volume est de 6 m¬≥.", points: 220, time: 75 },
                { type: 'text-input', text: "Comment nomme-t-on le plan repr√©sentant les altitudes du terrain le long d'un axe ?", correctAnswer: "Profil en long", solution: "Le profil en long est une coupe verticale qui montre le relief du terrain et le projet le long d'un axe.", points: 150, time: 40 },
                { type: 'scenario', text: "Sc√©nario : R√©seau inconnu", scenario: "En creusant une tranch√©e, vous d√©couvrez une canalisation non r√©pertori√©e. Quelle est la premi√®re action √† entreprendre ?", answers: [{ text: "Continuer en faisant attention.", correct: false }, { text: "Arr√™ter les travaux dans la zone et alerter le conducteur de travaux.", correct: true }, { text: "Essayer d'identifier le r√©seau en le per√ßant l√©g√®rement.", correct: false }, { text: "Recouvrir et ne rien dire.", correct: false }], solution: "La s√©curit√© prime. Il faut imm√©diatement arr√™ter les travaux, s√©curiser la zone et informer la hi√©rarchie.", points: 300, time: 60 },
                { type: 'pipe-connect', text: "Connectez le r√©seau de gaz. Le chemin doit passer par la vanne de coupure.", gridSize: { rows: 6, cols: 8 }, start: { row: 5, col: 3 }, end: { row: 0, col: 7 }, obstacles: [{row: 2, col: 4, type: 'valve'}], pieces: { straight: 8, corner: 6 }, solution: "Le chemin doit √™tre continu de A √† B et obligatoirement passer par la case 'valve'.", points: 400, time: 200, bonus: true, pipeColor: '#FBBF24' },
                { type: 'qcm', text: "Que signifie l'acronyme 'PMR' dans le contexte de l'am√©nagement urbain ?", answers: [{ text: "Personne √† Mobilit√© R√©duite", correct: true }, { text: "Plan de Ma√Ætrise des Risques", correct: false }, { text: "Petit Mat√©riel Roulant", correct: false }, { text: "Poste Mobile de Raccordement", correct: false }], solution: "PMR signifie Personne √† Mobilit√© R√©duite. Les am√©nagements VRD doivent garantir l'accessibilit√© pour tous.", points: 100, time: 30 },
                { type: 'qcm', text: "Dans un profil en travers, que repr√©sente le 'd√©vers' ?", answers: [{ text: "La pente longitudinale de la route", correct: false }, { text: "La pente transversale pour l'√©vacuation de l'eau", correct: true }, { text: "La hauteur du trottoir", correct: false }, { text: "L'√©paisseur de la couche de roulement", correct: false }], solution: "Le d√©vers est la pente transversale d'une chauss√©e, essentielle pour √©vacuer les eaux de pluie vers les caniveaux.", points: 120, time: 35 },
                { type: 'calculation', text: "Un foss√© de 80m de long a une section trap√©zo√Ødale de 0.5m¬≤. Quel volume de d√©blai (en m¬≥) faut-il excaver ?", correctAnswer: 40, tolerance: 0.1, solution: "Calcul : Volume = Longueur √ó Section = 80m √ó 0.5m¬≤ = 40 m¬≥.", points: 180, time: 50 },
                { type: 'text-input', text: "Comment s'appelle la partie sup√©rieure int√©rieure d'une canalisation ?", correctAnswer: "G√©n√©ratrice sup√©rieure", solution: "La 'g√©n√©ratrice sup√©rieure' est le point le plus haut √† l'int√©rieur d'une conduite. Le point le plus bas est le 'fil d'eau'.", points: 150, time: 40 },
                { type: 'scenario', text: "Un plan montre une nouvelle canalisation de gaz passant √† moins de 20 cm sous un c√¢ble √©lectrique haute tension. Que faites-vous ?", answers: [{ text: "Valider le plan, la profondeur est suffisante.", correct: false }, { text: "Refuser le plan et exiger une distance de s√©curit√© r√©glementaire.", correct: true }, { text: "Proposer de mettre les deux dans la m√™me gaine.", correct: false }, { text: "Demander un grillage avertisseur plus √©pais.", correct: false }], solution: "Les r√®gles de s√©curit√© (norme NF P 98-332) imposent des distances minimales strictes entre les r√©seaux pour √©viter les accidents. Ce croisement est non conforme et dangereux.", points: 300, time: 70 },
                { type: 'multiple-choice', text: "Parmi ces √©l√©ments, lesquels sont typiquement indiqu√©s sur un plan de r√©seaux d'√©clairage public ?", answers: [{ text: "Cand√©labre", correct: true, icon: "üí°" }, { text: "Chambre de tirage", correct: true, icon: "üî≥" }, { text: "Armoire de commande", correct: true, icon: "üéõÔ∏è" }, { text: "Bouche √† cl√©", correct: false, icon: "üîë" }], solution: "Un plan d'√©clairage public d√©taille l'emplacement des cand√©labres, des armoires qui les alimentent et des chambres de tirage pour les c√¢bles. Les bouches √† cl√© concernent les r√©seaux d'eau.", points: 160, time: 50 },
                { type: 'chronological-order', text: "Ordonnez les phases d'un projet VRD, de l'id√©e √† la r√©alisation.", items: ["√âtudes pr√©liminaires (AVP)", "√âtudes de projet (PRO)", "Consultation des entreprises (DCE)", "Ex√©cution des travaux (EXE)", "R√©ception des ouvrages (AOR)"], solution: "L'ordre est : Avant-Projet (AVP) > Projet (PRO) > Dossier de Consultation des Entreprises (DCE) > Ex√©cution (EXE) > Assistance aux Op√©rations de R√©ception (AOR).", points: 280, time: 100 },
                { type: 'categorize', text: "Classez ces √©l√©ments dans les cat√©gories 'R√©seaux Humides' et 'R√©seaux Secs'.", items: [{ text: "Eau potable", category: "humides" }, { text: "Fibre optique", category: "secs" }, { text: "Assainissement pluvial", category: "humides" }, { text: "Gaz", category: "secs" }, { text: "Basse tension", category: "secs" }, { text: "Chauffage urbain", category: "humides" }], categories: [{ id: "humides", title: "R√©seaux Humides (fluides)" }, { id: "secs", title: "R√©seaux Secs (√©nergie/info)" }], solution: "Humides : Eau potable, Assainissement, Chauffage urbain. Secs : Fibre optique, Gaz, √âlectricit√©.", points: 300, time: 80 },
                { type: 'qcm', text: "Qu'est-ce que le 'fil d'eau' d'une canalisation ?", answers: [{ text: "Le niveau le plus haut de l'eau", correct: false }, { text: "L'axe central de la canalisation", correct: false }, { text: "Le niveau int√©rieur inf√©rieur o√π l'eau s'√©coule", correct: true }, { text: "Un fil de nylon pour le curage", correct: false }], solution: "Le fil d'eau (FE) est la ligne la plus basse √† l'int√©rieur d'un tuyau, d√©terminant le niveau de l'√©coulement. C'est une cote de r√©f√©rence cruciale.", points: 120, time: 35 },
                { type: 'calculation', text: "Une tranch√©e fait 2m de profondeur et 0.8m de large. Pour 50m de long, quel est le volume de remblai n√©cessaire (en m¬≥), en consid√©rant un foisonnement de 20% des terres excav√©es ?", correctAnswer: 96, tolerance: 0.1, solution: "Volume excav√© = 2 √ó 0.8 √ó 50 = 80 m¬≥. Volume √† remblayer avec foisonnement = 80 √ó 1.20 = 96 m¬≥.", points: 250, time: 90 },
                { type: 'text-input', text: "Quel document contractuel d√©crit pr√©cis√©ment les ouvrages √† r√©aliser et leurs sp√©cifications techniques ?", correctAnswer: "CCTP", solution: "Le CCTP (Cahier des Clauses Techniques Particuli√®res) est la 'recette' technique du chantier. Il est r√©dig√© par le projeteur ou l'ing√©nieur.", points: 180, time: 50 },
                { type: 'multiple-choice', text: "Quels types de bordures sont utilis√©s pour d√©limiter une chauss√©e d'un trottoir ?", answers: [{ text: "T2", correct: true, icon: "üìê" }, { text: "P1", correct: true, icon: "üìè" }, { text: "A2", correct: true, icon: "üó∫Ô∏è" }, { text: "Grave-bitume", correct: false, icon: "üß±" }], solution: "Les bordures de type T (Trottoir), P (Piste) et A (Accotement) sont con√ßues pour cet usage. La grave-bitume est un mat√©riau de structure de chauss√©e.", points: 160, time: 50 },
                { type: 'scenario', text: "Un client souhaite un enrob√© clair pour une place publique afin de lutter contre les √Ælots de chaleur. Quel est le principal inconv√©nient technique ?", answers: [{ text: "Son co√ªt est identique √† un enrob√© classique.", correct: false }, { text: "Il est moins r√©sistant au trafic lourd.", correct: false }, { text: "Il est plus sensible aux taches et plus √©blouissant.", correct: true }, { text: "Il n'existe pas d'enrob√© de couleur claire.", correct: false }], solution: "Les enrob√©s clairs, bien que thermiquement efficaces, se salissent plus vite (taches d'huile, etc.) et peuvent augmenter l'√©blouissement par r√©flexion de la lumi√®re (alb√©do √©lev√©).", points: 280, time: 70 },
                { type: 'chronological-order', text: "Mettez dans l'ordre les couches d'un trottoir standard, du bas vers le haut.", items: ["Fond de forme (terrain naturel)", "Couche de fondation (grave)", "Lit de pose (sable)", "Rev√™tement (pav√©s ou enrob√©)"], solution: "On construit un trottoir en partant du terrain compact√© (fond de forme), puis la fondation, le lit de pose pour r√©gler la surface, et enfin le rev√™tement final.", points: 250, time: 80 },
                { type: 'pipe-connect', text: "Raccordez le pluvial (A) √† l'exutoire (B) en √©vitant l'ancienne conduite (Obstacle).", gridSize: { rows: 7, cols: 7 }, start: { row: 0, col: 3 }, end: { row: 6, col: 3 }, obstacles: [{row: 3, col: 2}, {row: 3, col: 3}, {row: 3, col: 4}], pieces: { straight: 7, corner: 6 }, solution: "Il fallait contourner l'obstacle central pour relier le d√©part et l'arriv√©e.", points: 400, time: 220, bonus: true, pipeColor: '#3B82F6' },
                { type: 'qcm', text: "Quelle est la pente minimale recommand√©e pour un caniveau √† fente ?", answers: [{ text: "0.2%", correct: false }, { text: "0.5%", correct: true }, { text: "1.0%", correct: false }, { text: "Pas de pente minimale", correct: false }], solution: "Une pente d'au moins 0.5% est recommand√©e pour assurer un bon auto-curage et √©viter la stagnation de l'eau et des s√©diments dans les caniveaux √† fente.", points: 130, time: 40 },
                // Set 3 (New Pro Questions)
                { type: 'qcm', text: "Quelle est la pente maximale r√©glementaire pour une rampe d'acc√®s PMR sans palier de repos ?", answers: [{ text: "4%", correct: false }, { text: "5%", correct: true }, { text: "8%", correct: false }, { text: "10%", correct: false }], solution: "La r√©glementation sur l'accessibilit√© impose une pente maximale de 5% pour les rampes. Au-del√†, des paliers de repos sont obligatoires.", points: 180, time: 45 },
                { type: 'text-input', text: "Dans le logiciel COVADIS, quelle commande permet de cr√©er un profil en long √† partir d'un axe en plan et d'un MNT ?", correctAnswer: "Covadis 3D > Profils en long par axe", solution: "La fonctionnalit√© 'Profils en long par axe' est fondamentale dans Covadis pour g√©n√©rer la vue en coupe du terrain naturel.", points: 200, time: 60 },
                { type: 'calculation', text: "Un volume de 100 m¬≥ de terre en place (non remu√©e) a un coefficient de foisonnement de 1.25. Quel volume de transport (en m¬≥) faut-il pr√©voir ?", correctAnswer: 125, tolerance: 0.1, solution: "Le volume apr√®s excavation sera de 100 m¬≥ * 1.25 = 125 m¬≥. Il faut pr√©voir des camions pour ce volume foisonn√©.", points: 220, time: 70 },
                { type: 'scenario', text: "Vous devez concevoir une route dans une zone argileuse sensible au retrait-gonflement. Quelle pr√©caution est indispensable ?", answers: [{ text: "Utiliser un enrob√© plus √©pais.", correct: false }, { text: "R√©aliser un traitement de sol √† la chaux et/ou au ciment.", correct: true }, { text: "Augmenter la pente de la route.", correct: false }, { text: "Poser un g√©otextile simple.", correct: false }], solution: "Le traitement des sols argileux √† la chaux ou au ciment est une technique courante pour les rendre insensibles √† l'eau et garantir la stabilit√© de la chauss√©e.", points: 320, time: 80 },
                { type: 'multiple-choice', text: "Quels √©l√©ments sont obligatoires dans un Dossier de Consultation des Entreprises (DCE) ?", answers: [{ text: "Le CCTP", correct: true, icon: "üìú" }, { text: "L'Acte d'Engagement (AE)", correct: true, icon: "‚úçÔ∏è" }, { text: "Le planning pr√©visionnel des travaux", correct: true, icon: "üóìÔ∏è" }, { text: "La photo du terrain", correct: false, icon: "üñºÔ∏è" }], solution: "Le CCTP (sp√©cifications techniques), l'AE (contrat) et le planning sont des pi√®ces ma√Ætresses du DCE qui permettent aux entreprises de chiffrer le projet.", points: 250, time: 75 },
                { type: 'qcm', text: "Qu'est-ce qu'un 'g√©otextile' et quelle est sa fonction principale sous une voirie ?", answers: [{ text: "Une b√¢che plastique pour l'√©tanch√©it√©.", correct: false }, { text: "Un tissu technique qui s√©pare les couches de mat√©riaux.", correct: true }, { text: "Un filet m√©tallique pour armer le b√©ton.", correct: false }, { text: "Une couche de sable fin.", correct: false }], solution: "Le g√©otextile est un feutre qui emp√™che les mat√©riaux fins (sable, terre) de remonter et de 'polluer' la structure de la chauss√©e, assurant ainsi sa p√©rennit√©.", points: 150, time: 50 },
                { type: 'text-input', text: "Comment appelle-t-on l'ouvrage qui permet de retenir la terre sur une forte pente ?", correctAnswer: "Mur de sout√®nement", solution: "Un mur de sout√®nement est un ouvrage de g√©nie civil destin√© √† contenir les terres et √† pr√©venir les glissements de terrain.", points: 160, time: 40 },
                { type: 'calculation', text: "La vitesse de r√©f√©rence d'une route est de 80 km/h. Quel est le d√©vers minimal √† appliquer dans un virage de 200m de rayon pour assurer la s√©curit√© ?", correctAnswer: 4, tolerance: 0.5, solution: "Bien que la formule exacte soit complexe (formule de VATE), un ordre de grandeur commun pour cette situation est un d√©vers d'environ 4 √† 5%.", points: 280, time: 90 },
                { type: 'scenario', text: "Le plan topographique indique un arbre class√© 'Espace Bois√© Class√©' en plein milieu de votre projet de parking. Que faites-vous ?", answers: [{ text: "Vous pr√©voyez de l'abattre et de le remplacer.", correct: false }, { text: "Vous modifiez l'implantation du parking pour le pr√©server.", correct: true }, { text: "Vous demandez une d√©rogation pour l'enlever.", correct: false }, { text: "Vous ignorez l'information.", correct: false }], solution: "Un √©l√©ment class√© est prot√©g√© par la loi. Le projet doit imp√©rativement √™tre adapt√© pour le conserver. C'est une contrainte forte √† int√©grer d√®s le d√©but.", points: 300, time: 60 },
                { type: 'qcm', text: "√Ä quoi sert le 'blindage' d'une tranch√©e ?", answers: [{ text: "√Ä la prot√©ger de la pluie.", correct: false }, { text: "√Ä emp√™cher les parois de s'effondrer.", correct: true }, { text: "√Ä guider les canalisations.", correct: false }, { text: "√Ä la rendre invisible.", correct: false }], solution: "Le blindage est un dispositif de s√©curit√© essentiel qui soutient les parois d'une fouille pour prot√©ger les travailleurs contre les risques d'ensevelissement.", points: 170, time: 40 }
            ];

            const discoveryQuestions = [
                // Set 1
                { type: 'qcm', text: "Que signifie 'VRD' ?", answers: [{ text: "Vraiment Rapide et Dangereux", correct: false }, { text: "Voirie et R√©seaux Divers", correct: true }, { text: "Voitures, Rues, Domiciles", correct: false }], solution: "'VRD' est l'acronyme de Voirie et R√©seaux Divers. Cela concerne tout ce qui est construit sur l'espace public : routes, trottoirs, et r√©seaux souterrains.", points: 10, time: 60 },
                { type: 'multiple-choice', text: "Quels sont les deux grands types de r√©seaux souterrains ?", answers: [{ text: "R√©seaux Humides (eau)", correct: true, icon: "üíß" }, { text: "R√©seaux Secs (√©nergie/c√¢bles)", correct: true, icon: "‚ö°" }, { text: "R√©seaux Mous (sable)", correct: false, icon: "üèñÔ∏è" }, { text: "R√©seaux Durs (roche)", correct: false, icon: "ü™®" }], solution: "On classe les r√©seaux en 'humides' pour ceux qui transportent des liquides (eau, assainissement) et 'secs' pour ceux qui transportent de l'√©nergie ou de l'information (√©lectricit√©, gaz, fibre).", points: 10, time: 60 },
                { type: 'categorize', text: "Triez ces √©l√©ments : o√π vont-ils ?", items: [{ text: "Un pi√©ton", category: "trottoir" }, { text: "Une voiture", category: "chaussee" }, { text: "Un v√©lo", category: "chaussee" }, { text: "L'eau de pluie", category: "caniveau" }], categories: [{ id: "trottoir", title: "Trottoir" }, { id: "chaussee", title: "Chauss√©e (Route)" }, { id: "caniveau", title: "Caniveau" }], solution: "Chaque am√©nagement a un r√¥le : le trottoir pour les pi√©tons, la chauss√©e pour les v√©hicules, et le caniveau pour r√©cup√©rer l'eau.", points: 15, time: 90 },
                { type: 'qcm', text: "Pourquoi met-on une pente sur une route ?", answers: [{ text: "Pour que les voitures aillent plus vite", correct: false }, { text: "Pour √©vacuer l'eau de pluie sur les c√¥t√©s", correct: true }, { text: "C'est plus joli", correct: false }], solution: "La pente, appel√©e 'd√©vers', est cruciale pour que l'eau de pluie ne stagne pas sur la route, ce qui la rendrait glissante et dangereuse.", points: 10, time: 60 },
                { type: 'text-input', text: "Quel est le nom du grand plan qui montre tout le projet vu de dessus ?", correctAnswer: "Plan de masse", solution: "Le 'plan de masse' est une vue a√©rienne qui pr√©sente l'ensemble du projet d'am√©nagement et sa situation dans l'environnement.", points: 15, time: 75 },
                { type: 'pipe-connect', text: "Jeu : Reliez la maison (A) au r√©seau d'eau (B).", gridSize: { rows: 4, cols: 5 }, start: { row: 1, col: 0 }, end: { row: 3, col: 4 }, pieces: { straight: 4, corner: 3 }, solution: "Excellent ! Vous avez raccord√© la maison au r√©seau public d'eau potable.", points: 20, time: 120, pipeColor: '#3B82F6' },
                { type: 'qcm', text: "√Ä quoi sert un 'regard' sur un r√©seau d'assainissement ?", answers: [{ text: "√Ä regarder si l'eau est propre", correct: false }, { text: "√Ä permettre l'acc√®s pour nettoyer ou inspecter", correct: true }, { text: "√Ä d√©corer le trottoir", correct: false }], solution: "Les regards (les plaques que l'on voit au sol) sont des points d'acc√®s essentiels pour la maintenance des r√©seaux souterrains.", points: 10, time: 60 },
                { type: 'chronological-order', text: "Jeu : Mettez dans l'ordre ces 3 √©tapes simples pour faire un trottoir.", items: ["Creuser le sol", "Mettre une couche de cailloux", "Poser le rev√™tement (pav√©s)"], solution: "On pr√©pare le sol en creusant, on stabilise avec une couche de base (cailloux), puis on pose la surface sur laquelle on marche.", points: 15, time: 90 },
                // Set 2 (New Discovery Questions)
                { type: 'qcm', text: "Qu'est-ce qu'un 'caniveau' ?", answers: [{ text: "Un petit canal pour guider l'eau de pluie", correct: true }, { text: "Un type de banc public", correct: false }, { text: "Une barri√®re de s√©curit√©", correct: false }], solution: "Le caniveau, souvent situ√© le long du trottoir, est essentiel pour collecter l'eau de pluie et l'envoyer vers le r√©seau d'assainissement.", points: 10, time: 60 },
                { type: 'multiple-choice', text: "Quels √©l√©ments de signalisation trouve-t-on sur une route ?", answers: [{ text: "Panneaux de signalisation", correct: true, icon: "üõë" }, { text: "Marquage au sol (lignes blanches)", correct: true, icon: "‚ûñ" }, { text: "Feux tricolores", correct: true, icon: "üö¶" }, { text: "Arbres", correct: false, icon: "üå≥" }], solution: "La s√©curit√© routi√®re d√©pend de la signalisation : les panneaux, les lignes au sol et les feux guident les conducteurs.", points: 10, time: 60 },
                { type: 'text-input', text: "Comment s'appelle le plan qui montre une 'tranche' de la route pour voir les diff√©rentes couches ?", correctAnswer: "Profil en travers", solution: "Le 'profil en travers' est une coupe qui montre la structure de la chauss√©e, les trottoirs, les pentes, etc. C'est comme une tranche de g√¢teau !", points: 15, time: 75 },
                { type: 'qcm', text: "Pourquoi les plaques d'√©gout sont-elles rondes ?", answers: [{ text: "Pour qu'elles ne puissent pas tomber dans le trou", correct: true }, { text: "C'est plus facile √† fabriquer", correct: false }, { text: "Pour qu'elles roulent mieux", correct: false }], solution: "Une plaque ronde ne peut pas tomber √† travers son propre trou, quelle que soit son orientation. C'est une astuce de conception pour la s√©curit√© !", points: 10, time: 60 },
                { type: 'categorize', text: "Triez ces actions : qui fait quoi ?", items: [{ text: "Dessine les plans", category: "projeteur" }, { text: "Conduit la pelleteuse", category: "conducteur" }, { text: "Pose les tuyaux", category: "ouvrier" }], categories: [{ id: "projeteur", title: "Le Projeteur" }, { id: "conducteur", title: "Le Conducteur d'engins" }, { id: "ouvrier", title: "L'Ouvrier" }], solution: "Chacun a son r√¥le ! Le projeteur con√ßoit sur ordinateur, et les √©quipes sur le chantier r√©alisent les travaux.", points: 15, time: 90 },
                { type: 'pipe-connect', text: "Jeu : L'eau de pluie du toit (A) doit aller au caniveau (B). Connectez le tuyau !", gridSize: { rows: 4, cols: 4 }, start: { row: 0, col: 1 }, end: { row: 3, col: 3 }, pieces: { straight: 3, corner: 2 }, solution: "Parfait ! Vous avez cr√©√© une goutti√®re pour √©vacuer l'eau de pluie loin de la maison.", points: 20, time: 120, pipeColor: '#0EA5E9' },
                { type: 'qcm', text: "√Ä quoi sert un 'lampadaire' ?", answers: [{ text: "√Ä faire de l'ombre", correct: false }, { text: "√Ä d√©corer la ville", correct: false }, { text: "√Ä √©clairer les rues la nuit", correct: true }], solution: "L'√©clairage public, assur√© par les lampadaires (ou cand√©labres), est un r√©seau essentiel pour la s√©curit√© et le confort la nuit.", points: 10, time: 60 },
                { type: 'qcm', text: "Quel est l'outil principal d'un projeteur VRD aujourd'hui ?", answers: [{ text: "Une pelle et une pioche", correct: false }, { text: "Un ordinateur avec des logiciels de dessin", correct: true }, { text: "Un camion de chantier", correct: false }], solution: "Le projeteur est avant tout un technicien de bureau d'√©tudes. Son outil principal est l'ordinateur, avec des logiciels de Dessin Assist√© par Ordinateur (DAO) comme AutoCAD.", points: 10, time: 60 }
            ];
            
            let gameState = {};
            
            // --- GESTION AUDIO ---
            let isSoundOn = false; // Le son est d√©sactiv√© par d√©faut
            const sounds = {
                start: new Tone.Synth({ oscillator: { type: "fatsawtooth" }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.3 } }).toDestination(),
                correct: new Tone.Synth({ oscillator: { type: "triangle" }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.2 } }).toDestination(),
                incorrect: new Tone.Synth({ oscillator: { type: "square" }, envelope: { attack: 0.01, decay: 0.3, sustain: 0, release: 0.2 } }).toDestination(),
                finish: new Tone.Synth({ oscillator: { type: "sine" }, envelope: { attack: 0.1, decay: 0.5, sustain: 0.3, release: 1 } }).toDestination(),
                click: new Tone.MembraneSynth({ pitchDecay: 0.01, octaves: 2, envelope: { attack: 0.001, decay: 0.2, sustain: 0 } }).toDestination(),
                timer_tick: new Tone.Synth({ oscillator: { type: 'sine' }, volume: -10, envelope: { attack: 0.001, decay: 0.1, sustain: 0, release: 0.1 } }).toDestination(),
                drag: new Tone.NoiseSynth({ noise: { type: 'pink' }, volume: -15, envelope: { attack: 0.005, decay: 0.05, sustain: 0 } }).toDestination(),
                drop: new Tone.MembraneSynth({ pitchDecay: 0.008, octaves: 4, envelope: { attack: 0.001, decay: 0.3, sustain: 0 } }).toDestination(),
                confetti: new Tone.PluckSynth({ attackNoise: 1, dampening: 4000, resonance: 0.7 }).toDestination()
            };
            
            function playSound(sound, ...args) {
                if (isSoundOn && sound && typeof sound.triggerAttackRelease === 'function') {
                    try {
                        sound.triggerAttackRelease(...args);
                    } catch (e) {
                        console.error("Audio playback error:", e);
                    }
                }
            }

            // --- FONCTIONS PRINCIPALES DU JEU ---
            function initGame() {
                if (gameState.timerInterval) clearInterval(gameState.timerInterval);
                if (gameState.totalTimeInterval) clearInterval(gameState.totalTimeInterval);
                
                gameState = { score: 0, currentQuestionIndex: -1, timeLeft: 0, timerInterval: null, totalTime: 0, totalTimeInterval: null, questions: [], answeredQuestions: [], isQuestionAnswered: false, mode: null };
                updateScore(0);
                switchScreen('home');
                dom.displays.timer.textContent = '--:--';
                dom.displays.timerContainer.classList.remove('warning');
            }

            function startGame(mode) {
                Tone.start().then(() => {
                    isSoundOn = true;
                    playSound(sounds.start, "C4", "8n");
                });
                
                gameState.mode = mode;
                const questionsToLoad = mode === 'discovery' ? discoveryQuestions : proQuestions;
                gameState.questions = shuffleArray([...questionsToLoad]);
                gameState.answeredQuestions = new Array(gameState.questions.length).fill(null);
                
                startTotalTimer();
                nextQuestion();
            }

            function nextQuestion() {
                if (gameState.currentQuestionIndex >= gameState.questions.length - 1) { endGame(); return; }
                gameState.currentQuestionIndex++;
                displayQuestion();
            }

            function displayQuestion() {
                clearInterval(gameState.timerInterval);
                dom.displays.feedback.innerHTML = '';
                dom.buttons.next.style.display = 'none';
                
                const question = gameState.questions[gameState.currentQuestionIndex];
                gameState.isQuestionAnswered = false;
                
                dom.displays.questionText.innerHTML = `Question ${gameState.currentQuestionIndex + 1}/${gameState.questions.length}: ${question.text}`;
                dom.displays.answerContainer.innerHTML = '';
                
                // Affichage conditionnel des stats
                dom.displays.scoreContainer.style.display = gameState.mode === 'pro' ? 'flex' : 'none';
                dom.displays.timerContainer.style.display = gameState.mode === 'pro' ? 'flex' : 'none';

                const interfaceBuilder = { 
                    'qcm': createQCMInterface, 
                    'scenario': createQCMInterface, 
                    'multiple-choice': createMultipleChoiceInterface, 
                    'calculation': createCalculationInterface, 
                    'text-input': createTextInputInterface, 
                    'chronological-order': createDragDropOrderInterface, 
                    'pipe-connect': createPipeConnectInterface,
                    'categorize': createCategorizeInterface
                }[question.type];

                if (interfaceBuilder) interfaceBuilder(question);
                
                startTimer(question.time);
                switchScreen('question');
            }

            function endGame() {
                clearInterval(gameState.timerInterval);
                clearInterval(gameState.totalTimeInterval);
                playSound(sounds.finish, "C5", "1n", Tone.now() + 0.1);
                launchConfetti();
                
                const correctCount = gameState.answeredQuestions.filter(a => a && a.isCorrect).length;
                const totalQuestions = gameState.questions.length;
                
                dom.displays.finalScore.textContent = gameState.score;
                dom.displays.correctAnswers.textContent = `${correctCount} / ${totalQuestions}`;
                dom.displays.totalTime.textContent = formatTime(gameState.totalTime);
                
                let message;
                if (gameState.mode === 'discovery') {
                    message = "Bravo ! Vous avez explor√© les bases du m√©tier de projeteur VRD.";
                } else {
                    if (correctCount / totalQuestions < 0.5) message = "C'est un bon d√©but, continuez √† vous entra√Æner !";
                    else if (correctCount / totalQuestions < 0.8) message = "Tr√®s bon score, vous progressez bien !";
                    else message = "Excellent travail ! Vous avez l'√©toffe d'un expert !";
                }
                dom.displays.finalMessage.textContent = message;
                
                switchScreen('final');
            }

            function createQCMInterface(question) {
                const answerGrid = document.createElement('div');
                answerGrid.className = 'answer-grid';
                question.answers.forEach((answer, index) => {
                    const btn = document.createElement('button');
                    btn.className = 'answer-btn';
                    btn.innerHTML = answer.text;
                    btn.onclick = () => handleAnswer(index, index);
                    answerGrid.appendChild(btn);
                });
                dom.displays.answerContainer.appendChild(answerGrid);
            }

            function createMultipleChoiceInterface(question) {
                const materialGrid = document.createElement('div');
                materialGrid.className = 'material-grid';
                question.answers.forEach((answer, index) => {
                    const card = document.createElement('div');
                    card.className = 'material-card';
                    card.dataset.index = index;
                    card.innerHTML = `<div class="material-icon">${answer.icon || '‚ùî'}</div><p>${answer.text}</p>`;
                    card.onclick = () => { if (!gameState.isQuestionAnswered) card.classList.toggle('selected'); };
                    materialGrid.appendChild(card);
                });
                dom.displays.answerContainer.appendChild(materialGrid);
                addSubmitButton(() => {
                    const selectedCards = dom.displays.answerContainer.querySelectorAll('.material-card.selected');
                    const selectedIndices = Array.from(selectedCards).map(c => parseInt(c.dataset.index));
                    handleAnswer(selectedIndices, selectedIndices);
                });
            }

            function createCalculationInterface(question) {
                const input = document.createElement('input');
                input.type = 'number';
                input.step = 'any';
                input.className = 'elevation-input';
                input.placeholder = 'Votre r√©ponse...';
                dom.displays.answerContainer.appendChild(input);
                addSubmitButton(() => { const value = parseFloat(input.value); if (!isNaN(value)) handleAnswer(value, value); });
            }

            function createTextInputInterface(question) {
                const input = document.createElement('input');
                input.type = 'text';
                input.className = 'text-input';
                input.placeholder = 'Votre r√©ponse...';
                dom.displays.answerContainer.appendChild(input);
                addSubmitButton(() => { const value = input.value.trim(); if (value) handleAnswer(value, value); });
            }
            
            function createDragDropOrderInterface(question) {
                const container = document.createElement('div');
                container.className = 'drop-zone-container';
                const dropZone = document.createElement('div');
                dropZone.className = 'category-zone';
                dropZone.style.minHeight = 'auto';
                dropZone.innerHTML = '<h4>Ordonnez les √©tapes ici</h4>';
                const draggableContainer = document.createElement('div');
                draggableContainer.className = 'draggable-container';
                shuffleArray([...question.items]).forEach((item) => {
                    const el = createDraggableElement(item, item);
                    draggableContainer.appendChild(el);
                });
                container.appendChild(dropZone);
                container.appendChild(draggableContainer);
                dom.displays.answerContainer.appendChild(container);
                setupDragDrop([dropZone, draggableContainer]);
                addSubmitButton(() => { const droppedItems = Array.from(dropZone.querySelectorAll('.draggable')).map(child => child.dataset.id); handleAnswer(droppedItems, droppedItems); });
            }

            function createCategorizeInterface(question) {
                const container = document.createElement('div');
                container.className = 'drop-zone-container';
                const categoryContainer = document.createElement('div');
                categoryContainer.className = 'category-container';
                question.categories.forEach(cat => {
                    const zone = document.createElement('div');
                    zone.className = 'category-zone';
                    zone.dataset.category = cat.id;
                    zone.innerHTML = `<h4>${cat.title}</h4>`;
                    categoryContainer.appendChild(zone);
                });
                const draggableContainer = document.createElement('div');
                draggableContainer.className = 'draggable-container';
                shuffleArray([...question.items]).forEach((item) => {
                    const el = createDraggableElement(item.text, item.text, item.category);
                    draggableContainer.appendChild(el);
                });
                container.appendChild(categoryContainer);
                container.appendChild(draggableContainer);
                dom.displays.answerContainer.appendChild(container);
                setupDragDrop([...categoryContainer.children, draggableContainer]);
                addSubmitButton(() => {
                    const answer = {};
                    categoryContainer.querySelectorAll('.category-zone').forEach(zone => {
                        answer[zone.dataset.category] = Array.from(zone.querySelectorAll('.draggable')).map(el => el.dataset.id);
                    });
                    handleAnswer(answer, answer);
                });
            }

            function createDraggableElement(id, text, category = '') {
                const el = document.createElement('div');
                el.className = 'draggable';
                el.textContent = text;
                el.draggable = true;
                el.dataset.id = id;
                if (category) el.dataset.category = category;
                el.addEventListener('dragstart', e => { playSound(sounds.drag, "8n"); e.dataTransfer.setData('text/plain', id); setTimeout(() => el.style.opacity = '0.5', 0); });
                el.addEventListener('dragend', () => el.style.opacity = '1');
                return el;
            }

            function setupDragDrop(zones) {
                zones.forEach(zone => {
                    zone.addEventListener('dragover', e => { e.preventDefault(); zone.classList.add('hover'); });
                    zone.addEventListener('dragleave', () => zone.classList.remove('hover'));
                    zone.addEventListener('drop', e => {
                        e.preventDefault();
                        playSound(sounds.drop, "C3", "8n");
                        zone.classList.remove('hover');
                        const id = e.dataTransfer.getData('text/plain');
                        const draggable = document.querySelector(`.draggable[data-id="${id}"]`);
                        if (draggable) zone.appendChild(draggable);
                    });
                });
            }
            
            function createPipeConnectInterface(question) {
                const container = document.createElement('div');
                container.className = 'pipe-game-container';
                const pipeTray = document.createElement('div');
                pipeTray.className = 'pipe-tray';
                const createDraggablePipe = (type, count) => {
                    const piece = document.createElement('div');
                    piece.className = 'pipe-piece-draggable';
                    piece.draggable = true;
                    piece.dataset.pipeType = type;
                    piece.innerHTML = getPipeSVG(type, 0, question.pipeColor) + `<span class="pipe-count" id="pipe-count-${type}">${count}</span>`;
                    piece.addEventListener('dragstart', e => { 
                        if (parseInt(piece.querySelector(`#pipe-count-${type}`).textContent) > 0) { 
                            playSound(sounds.drag, "8n"); 
                            e.dataTransfer.setData('text/plain', type); 
                            piece.classList.add('dragging'); 
                        } else { 
                            e.preventDefault(); 
                        } 
                    });
                    piece.addEventListener('dragend', () => piece.classList.remove('dragging'));
                    return piece;
                };
                Object.keys(question.pieces).forEach(type => pipeTray.appendChild(createDraggablePipe(type, question.pieces[type])));
                const gridContainer = document.createElement('div');
                gridContainer.className = 'pipe-grid-container';
                gridContainer.style.setProperty('--grid-cols', question.gridSize.cols);
                gridContainer.id = 'pipe-grid';
                for (let r = 0; r < question.gridSize.rows; r++) {
                    for (let c = 0; c < question.gridSize.cols; c++) {
                        const cell = document.createElement('div');
                        cell.className = 'grid-cell';
                        cell.dataset.row = r;
                        cell.dataset.col = c;
                        if (r === question.start.row && c === question.start.col) cell.classList.add('start-node');
                        else if (r === question.end.row && c === question.end.col) cell.classList.add('end-node');
                        else if (question.obstacles?.some(o => o.row === r && o.col === c)) {
                            cell.classList.add('obstacle-node');
                            cell.innerHTML = `<div style="width: 66%; height: 66%; color: var(--text-muted);"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M18.364 18.364a9 9 0 1 1-12.728-12.728A9 9 0 0 1 18.364 18.364zM12 16a4 4 0 1 0 0-8 4 4 0 0 0 0 8z"/><path d="m4 4 16 16"/></svg></div>`;
                            cell.dataset.obstacle = true;
                        }
                        cell.addEventListener('dragover', e => { if (!cell.hasChildNodes()) e.preventDefault(); });
                        cell.addEventListener('drop', e => {
                            e.preventDefault();
                            if (cell.innerHTML !== '' || cell.classList.contains('start-node') || cell.classList.contains('end-node') || cell.dataset.obstacle) return;
                            const type = e.dataTransfer.getData('text/plain');
                            const countEl = document.getElementById(`pipe-count-${type}`);
                            let count = parseInt(countEl.textContent);
                            if (count > 0) {
                                playSound(sounds.drop, "C3", "8n");
                                count--;
                                countEl.textContent = count;
                                const placedPiece = document.createElement('div');
                                placedPiece.className = 'pipe-piece-placed';
                                placedPiece.dataset.pipeType = type;
                                placedPiece.dataset.rotation = 0;
                                placedPiece.innerHTML = getPipeSVG(type, 0, question.pipeColor);
                                placedPiece.addEventListener('click', () => {
                                    if (gameState.isQuestionAnswered) return;
                                    let currentRotation = parseInt(placedPiece.dataset.rotation);
                                    currentRotation = (currentRotation + 90) % 360;
                                    placedPiece.dataset.rotation = currentRotation;
                                    placedPiece.style.transform = `rotate(${currentRotation}deg)`;
                                });
                                placedPiece.addEventListener('contextmenu', (ev) => {
                                    ev.preventDefault();
                                    if (gameState.isQuestionAnswered) return;
                                    cell.innerHTML = '';
                                    const typeToRemove = placedPiece.dataset.pipeType;
                                    const countElToRemove = document.getElementById(`pipe-count-${typeToRemove}`);
                                    countElToRemove.textContent = parseInt(countElToRemove.textContent) + 1;
                                });
                                cell.appendChild(placedPiece);
                            }
                        });
                        gridContainer.appendChild(cell);
                    }
                }
                container.appendChild(pipeTray);
                container.appendChild(gridContainer);
                dom.displays.answerContainer.appendChild(container);
                addSubmitButton(() => {
                    const placedPipes = [];
                    gridContainer.querySelectorAll('.pipe-piece-placed').forEach(p => {
                        const cell = p.parentElement;
                        placedPipes.push({ row: parseInt(cell.dataset.row), col: parseInt(cell.dataset.col), type: p.dataset.pipeType, rotation: parseInt(p.dataset.rotation) });
                    });
                    handleAnswer(placedPipes, placedPipes);
                }, 'V√©rifier');
            }

            function addSubmitButton(callback, text = 'Valider') {
                const submitBtn = document.createElement('button');
                submitBtn.textContent = text;
                submitBtn.className = 'btn';
                submitBtn.style.marginTop = '2rem';
                submitBtn.onclick = callback;
                dom.displays.answerContainer.appendChild(submitBtn);
            }

            function handleAnswer(userAnswer, answerForStorage) {
                if (gameState.isQuestionAnswered) return;

                const question = gameState.questions[gameState.currentQuestionIndex];
                if (!question) {
                    clearInterval(gameState.timerInterval);
                    return;
                }

                clearInterval(gameState.timerInterval);
                gameState.isQuestionAnswered = true;
                
                let isCorrect = false;
                switch (question.type) {
                    case 'qcm': case 'scenario': isCorrect = userAnswer !== null && question.answers[userAnswer].correct; break;
                    case 'multiple-choice':
                        const correctIndices = question.answers.map((a, i) => a.correct ? i : -1).filter(i => i !== -1);
                        isCorrect = userAnswer && userAnswer.length === correctIndices.length && userAnswer.every(index => correctIndices.includes(index));
                        break;
                    case 'calculation': isCorrect = userAnswer !== null && Math.abs(userAnswer - question.correctAnswer) <= (question.tolerance || 0.01); break;
                    case 'text-input': isCorrect = userAnswer && userAnswer.toLowerCase().trim() === question.correctAnswer.toLowerCase().trim(); break;
                    case 'chronological-order': isCorrect = userAnswer && userAnswer.length === question.items.length && userAnswer.every((item, index) => item === question.items[index]); break;
                    case 'pipe-connect': isCorrect = checkPipeConnection(userAnswer, question); break;
                    case 'categorize':
                        isCorrect = true;
                        for(const item of question.items) {
                            const correctCategory = item.category;
                            const placedCategory = Object.keys(userAnswer).find(cat => userAnswer[cat].includes(item.text));
                            if(correctCategory !== placedCategory) {
                                isCorrect = false;
                                break;
                            }
                        }
                        const allPlacedItems = Object.values(userAnswer).flat();
                        if (allPlacedItems.length !== question.items.length) isCorrect = false;
                        break;
                }
                gameState.answeredQuestions[gameState.currentQuestionIndex] = { answer: answerForStorage, isCorrect: isCorrect };
                if (isCorrect) {
                    playSound(sounds.correct, "C5", "8n", Tone.now() + 0.1);
                    dom.displays.feedback.innerHTML = "Bonne r√©ponse !";
                    dom.displays.feedback.style.color = 'var(--correct)';
                    let pointsGained = question.points;
                    if (question.bonus && gameState.mode === 'pro') pointsGained *= 2;
                    updateScore(gameState.score + pointsGained);
                } else {
                    playSound(sounds.incorrect, "C3", "8n", Tone.now() + 0.1);
                    dom.displays.feedback.innerHTML = `R√©ponse incorrecte. <br><span class="feedback-solution">${question.solution}</span>`;
                    dom.displays.feedback.style.color = 'var(--incorrect)';
                }
                showSolutionVisuals(question, isCorrect);
                dom.buttons.next.style.display = 'inline-flex';
            }

            function showSolutionVisuals(question, isCorrect) {
                const answerElements = dom.displays.answerContainer.querySelectorAll('.answer-btn, .material-card, .draggable, .pipe-piece-placed, input, button, .pipe-piece-draggable');
                answerElements.forEach(el => { el.style.pointerEvents = 'none'; el.disabled = true; if(el.classList.contains('material-card')) el.classList.add('disabled'); });
                switch (question.type) {
                    case 'qcm': case 'scenario': dom.displays.answerContainer.querySelectorAll('.answer-btn').forEach((btn, index) => { if (question.answers[index].correct) btn.classList.add('correct'); }); break;
                    case 'multiple-choice':
                        dom.displays.answerContainer.querySelectorAll('.material-card').forEach((card, index) => {
                            const isSelected = card.classList.contains('selected');
                            const isCorrectAnswer = question.answers[index].correct;
                            if (isCorrectAnswer) card.classList.add('correct');
                            else if (isSelected && !isCorrectAnswer) card.classList.add('incorrect');
                        });
                        break;
                    case 'categorize':
                        dom.displays.answerContainer.querySelectorAll('.draggable').forEach(el => {
                            const correctCategory = el.dataset.category;
                            const placedCategory = el.parentElement.dataset.category;
                            if (correctCategory === placedCategory) {
                                el.classList.add('correct');
                            } else {
                                el.classList.add('incorrect');
                            }
                        });
                        break;
                    case 'chronological-order':
                         dom.displays.answerContainer.querySelectorAll('.draggable').forEach(el => {
                            const userOrder = Array.from(el.parentElement.children).map(child => child.dataset.id);
                            const correctIndex = question.items.indexOf(el.dataset.id);
                            const userIndex = userOrder.indexOf(el.dataset.id);
                            if (el.parentElement.classList.contains('category-zone')) {
                                if (correctIndex === userIndex) {
                                    el.classList.add('correct');
                                } else {
                                    el.classList.add('incorrect');
                                }
                            }
                         });
                         break;
                }
            }
            
            function getPipeSVG(type, rotation, color) {
                let path = '';
                if (type === 'straight') path = `<path d="M0 50 L100 50" stroke="${color}" stroke-width="15" stroke-linecap="round" />`;
                else if (type === 'corner') path = `<path d="M0 50 L50 50 L50 100" stroke="${color}" stroke-width="15" stroke-linecap="round" fill="none" />`;
                return `<svg class="w-full h-full" viewBox="0 0 100 100" style="transform: rotate(${rotation}deg);">${path}</svg>`;
            }

            function getPipeExits(pipe) {
                if (!pipe) return [];
                const { type, rotation } = pipe;
                const r = (parseInt(rotation, 10) + 360) % 360;
                if (type === 'straight') return (r === 90 || r === 270) ? ['up', 'down'] : ['left', 'right'];
                if (type === 'corner') { if (r === 0) return ['left', 'down']; if (r === 90) return ['down', 'right']; if (r === 180) return ['right', 'up']; if (r === 270) return ['up', 'left']; }
                return [];
            }
            
            function checkPipeConnection(placedPipes, question) {
                if (!Array.isArray(placedPipes)) return false;
                const { gridSize, start, end, obstacles } = question;
                const grid = Array(gridSize.rows).fill(null).map(() => Array(gridSize.cols).fill(null));
                placedPipes.forEach(p => { grid[p.row][p.col] = p; });
                let queue = [];
                let visited = new Set();
                const directions = { up: { r: -1, c: 0, opp: 'down' }, down: { r: 1, c: 0, opp: 'up' }, left: { r: 0, c: -1, opp: 'right' }, right: { r: 0, c: 1, opp: 'left' } };
                for (const dirName in directions) {
                    const { r, c, opp } = directions[dirName];
                    const nextR = start.row + r;
                    const nextC = start.col + c;
                    const key = `${nextR},${nextC}`;
                    if (nextR >= 0 && nextR < gridSize.rows && nextC >= 0 && nextC < gridSize.cols) {
                        const nextPipe = grid[nextR]?.[nextC];
                        if (nextPipe && getPipeExits(nextPipe).includes(opp)) { visited.add(key); queue.push({ row: nextR, col: nextC, path: [`${start.row},${start.col}`, key] }); }
                    }
                }
                while (queue.length > 0) {
                    const current = queue.shift();
                    const currentPipe = grid[current.row][current.col];
                    const currentExits = getPipeExits(currentPipe);
                    for (const dirName in directions) {
                        const { r, c } = directions[dirName];
                        if (currentExits.includes(dirName)) {
                            const neighborR = current.row + r;
                            const neighborC = current.col + c;
                            if (neighborR === end.row && neighborC === end.col) {
                                const finalPath = [...current.path, `${end.row},${end.col}`];
                                const pathSet = new Set(finalPath);
                                const allObstaclesOnPath = obstacles?.every(o => pathSet.has(`${o.row},${o.col}`)) ?? true;
                                if (allObstaclesOnPath) return true;
                            }
                        }
                    }
                    for (const dirName in directions) {
                        const { r, c, opp } = directions[dirName];
                        if (currentExits.includes(dirName)) {
                            const nextR = current.row + r;
                            const nextC = current.col + c;
                            const key = `${nextR},${nextC}`;
                            if (nextR >= 0 && nextR < gridSize.rows && nextC >= 0 && nextC < gridSize.cols && !visited.has(key)) {
                                const nextPipe = grid[nextR]?.[nextC];
                                if (nextPipe && getPipeExits(nextPipe).includes(opp)) { visited.add(key); queue.push({ row: nextR, col: nextC, path: [...current.path, key] }); }
                            }
                        }
                    }
                }
                return false;
            }

            function switchScreen(screenName) { Object.values(dom.screens).forEach(s => s.classList.remove('active')); dom.screens[screenName].classList.add('active'); }
            function updateScore(newScore) { gameState.score = newScore; dom.displays.score.textContent = newScore; }
            function startTimer(duration) {
                gameState.timeLeft = duration;
                dom.displays.timerContainer.classList.remove('warning');
                function update() {
                    if(gameState.mode === 'pro') {
                        dom.displays.timer.textContent = formatTime(gameState.timeLeft);
                        if (gameState.timeLeft <= 10 && gameState.timeLeft > 0) {
                            dom.displays.timerContainer.classList.add('warning');
                            playSound(sounds.timer_tick, 'C6', '16n');
                        }
                    }
                    if (gameState.timeLeft <= 0) { 
                        clearInterval(gameState.timerInterval); 
                        handleAnswer(null, 'timeout'); 
                    }
                    gameState.timeLeft--;
                }
                update();
                gameState.timerInterval = setInterval(update, 1000);
            }
            function startTotalTimer() { gameState.totalTime = 0; if(gameState.totalTimeInterval) clearInterval(gameState.totalTimeInterval); gameState.totalTimeInterval = setInterval(() => { gameState.totalTime++; }, 1000); }
            function formatTime(seconds) { const mins = Math.floor(seconds / 60); const secs = seconds % 60; return `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`; }
            function shuffleArray(array) { for (let i = array.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [array[i], array[j]] = [array[j], array[i]]; } return array; }
            function launchConfetti() {
                playSound(sounds.confetti, "C4", "8n", Tone.now());
                playSound(sounds.confetti, "G4", "8n", Tone.now() + 0.1);
                playSound(sounds.confetti, "E5", "8n", Tone.now() + 0.2);
                for (let i = 0; i < 100; i++) { const c = document.createElement('div'); c.className = 'confetti'; c.style.left = `${Math.random()*100}vw`; c.style.animationDelay = `${Math.random()*2}s`; c.style.backgroundColor=`hsl(${Math.random()*360},100%,50%)`; c.style.transform=`scale(${Math.random()*.5+.5})`; document.body.appendChild(c); setTimeout(()=>c.remove(),3000);}
            }

            // --- EVENT LISTENERS ---
            dom.buttons.startDiscovery.addEventListener('click', () => { startGame('discovery'); playSound(sounds.click, "C2", "8n"); });
            dom.buttons.startPro.addEventListener('click', () => { startGame('pro'); playSound(sounds.click, "C2", "8n"); });
            dom.buttons.next.addEventListener('click', () => { nextQuestion(); playSound(sounds.click, "C2", "8n"); });
            dom.buttons.restartFinal.addEventListener('click', () => { startGame(gameState.mode); playSound(sounds.click, "C2", "8n"); });
            dom.buttons.homeFinal.addEventListener('click', () => { initGame(); playSound(sounds.click, "C2", "8n"); });
            dom.buttons.changeMode.addEventListener('click', () => { initGame(); playSound(sounds.click, "C2", "8n"); });

            // --- INITIALISATION ---
            initGame();
        });
    </script>
</body>
</html>
