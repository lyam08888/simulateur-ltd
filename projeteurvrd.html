<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LTD Simulateur - Projeteur VRD</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;800&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Poppins', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 10px;
            /* Default font size, will be updated by JS */
            font-size: 14px; /* Adjusted base font size */
        }
        
        .game-container {
            width: 100%;
            max-width: 1400px; /* Main container width */
            height: 95vh;
            background: rgba(255, 255, 255, 0.98);
            border-radius: 30px;
            box-shadow: 0 25px 80px rgba(0, 0, 0, 0.3);
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        .game-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 25px 50px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 5px 25px rgba(0, 0, 0, 0.15);
            position: absolute; /* Fixed position to stay at top */
            top: 0;
            left: 0;
            width: 100%;
            z-index: 10; /* Ensure it's above other content */
            height: 90px; /* Explicit height to help with screen padding */
        }
        
        .logo {
            display: flex;
            align-items: center;
            gap: 15px;
            font-size: 2rem; /* Adjusted from 28px */
            font-weight: 800;
        }
        
        .logo-icon {
            width: 50px;
            height: 50px;
            background: white;
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.2rem; /* Adjusted from 30px */
        }
        
        .header-stats {
            display: flex;
            gap: 30px;
            align-items: center; /* Align items vertically in the center */
        }
        
        .header-item {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 1.7rem; /* Adjusted from 24px */
            font-weight: 600;
            background: rgba(255, 255, 255, 0.2);
            padding: 10px 20px;
            border-radius: 50px;
            backdrop-filter: blur(10px);
        }
        
        .score-icon::before {
            content: "⭐";
            font-size: 2rem; /* Adjusted from 28px */
        }
        
        .timer-icon::before {
            content: "⏰";
            font-size: 2rem; /* Adjusted from 28px */
        }
        
        .timer-display.warning {
            animation: pulse 1s infinite;
            background: rgba(244, 67, 54, 0.3);
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        .screen {
            display: none;
            flex: 1;
            /* Adjusted padding to account for header (90px), controls (~100px from right), and bottom bars */
            padding: 100px 120px 80px 50px; /* top, right, bottom, left */
            overflow-y: auto;
            animation: fadeIn 0.5s ease-out;
            /* Removed redundant margins as padding now handles spacing */
            /* margin-top: 80px; */
            /* margin-right: 100px; */
            /* margin-bottom: 60px; */
        }
        
        .screen.active {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        /* Bonus round specific styling */
        .screen.bonus-active {
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%); /* Gold/Orange gradient */
            box-shadow: 0 25px 80px rgba(255, 165, 0, 0.5); /* Orange shadow */
            color: #333; /* Darker text for contrast */
        }
        .screen.bonus-active h2 {
            color: #333; /* Ensure heading is readable */
        }
        .screen.bonus-active .answer-btn {
            background: #fefce8; /* Light yellow background for buttons */
            border-color: #fbbf24; /* Yellow border */
            color: #333;
        }
        .screen.bonus-active .answer-btn:hover {
            border-color: #f59e0b; /* Darker yellow on hover */
            background: #fde68a;
        }
        .screen.bonus-active .material-card {
            background: #fefce8;
            border-color: #fbbf24;
            color: #333;
        }
        .screen.bonus-active .material-card:hover {
            border-color: #f59e0b;
            background: #fde68a;
        }
        .screen.bonus-active .elevation-input {
            border-color: #fbbf24;
        }
        .screen.bonus-active .elevation-input:focus {
            box-shadow: 0 0 0 3px rgba(251, 191, 36, 0.4);
        }
        .screen.bonus-active .btn {
            background: linear-gradient(135deg, #f59e0b 0%, #ef4444 100%); /* Orange to red gradient for bonus buttons */
            box-shadow: 0 5px 25px rgba(245, 158, 11, 0.4);
        }
        .screen.bonus-active .btn:hover {
            box-shadow: 0 8px 35px rgba(245, 158, 11, 0.6);
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        h1 {
            font-size: 3.5rem; /* Adjusted from 5rem */
            font-weight: 800;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 30px;
            text-align: center;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }
        
        h2 {
            font-size: 2.5rem; /* Adjusted from 3.8rem */
            font-weight: 600;
            color: #333;
            margin-bottom: 40px;
            text-align: center;
            line-height: 1.3;
        }

        p {
            font-size: 1.1rem; /* Adjusted from 1.4rem */
        }
        
        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 18px 50px;
            border-radius: 50px;
            font-size: 1.4rem; /* Adjusted from 20px */
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 25px rgba(102, 126, 234, 0.4);
            position: relative;
            overflow: hidden;
        }
        
        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.2);
            transition: left 0.5s ease;
        }
        
        .btn:hover::before {
            left: 100%;
        }
        
        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 35px rgba(102, 126, 234, 0.6);
        }
        
        .btn:active {
            transform: translateY(-1px);
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .btn-secondary {
            background: #e0e0e0;
            color: #333;
            box-shadow: 0 5px 25px rgba(0, 0, 0, 0.1);
        }
        
        .progress-bar-chronological { /* New class for chronological progress bar */
            width: calc(100% - 100px); /* Adjust width to fit within header padding */
            height: 15px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            margin: 0 50px; /* Match header padding */
            overflow: hidden;
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.1);
            position: absolute;
            bottom: 45px; /* Position above the tips bar */
            left: 0;
            right: 0;
            z-index: 10; /* Ensure it's above other content */
        }
        
        .progress-fill-chronological {
            height: 100%;
            background: white; /* White fill for contrast */
            border-radius: 10px;
            transition: width 0.5s ease;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding-right: 5px;
            font-size: 0.8rem; /* Adjusted from 12px */
            color: #667eea;
            font-weight: 600;
        }
        
        .answer-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); /* Adjusted minmax for smaller font */
            gap: 25px;
            width: 100%;
            max-width: 1000px;
            margin-top: 40px;
        }
        
        .answer-btn {
            background: white;
            border: 3px solid #e0e0e0;
            padding: 25px;
            border-radius: 20px;
            font-size: 1.2rem; /* Adjusted from 20px */
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            position: relative;
            overflow: hidden;
        }
        
        .answer-btn:hover {
            border-color: #667eea;
            transform: translateY(-5px);
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.15);
        }
        
        .answer-btn.correct {
            background: #4caf50;
            color: white;
            border-color: #4caf50;
            animation: bounce 0.5s ease;
        }
        
        .answer-btn.incorrect {
            background: #f44336;
            color: white;
            border-color: #f44336;
            animation: shake 0.5s ease;
        }
        
        @keyframes bounce {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-10px); }
            75% { transform: translateX(10px); }
        }
        
        .game-area {
            width: 100%;
            max-width: 1000px;
            height: 500px;
            background: #f8f9fa;
            border-radius: 25px;
            border: 3px solid #e0e0e0;
            position: relative;
            overflow: hidden;
            margin: 30px 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .controls {
            position: fixed;
            right: 30px; /* Position on the right */
            top: 50%; /* Center vertically */
            transform: translateY(-50%); /* Adjust for vertical centering */
            display: flex;
            flex-direction: column; /* Arrange buttons vertically */
            gap: 20px; /* Spacing between control buttons */
            background: rgba(255, 255, 255, 0.98);
            padding: 20px;
            border-radius: 60px; /* Adjust border-radius for vertical layout */
            box-shadow: 0 15px 50px rgba(0, 0, 0, 0.25);
            z-index: 10; /* Ensure it's above other content */
        }
        
        .control-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: none;
            background: white;
            color: #667eea;
            font-size: 1.7rem; /* Adjusted from 24px */
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 3px 15px rgba(0, 0, 0, 0.1);
            position: relative;
        }
        
        .control-btn:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.2);
            background: #667eea;
            color: white;
        }
        
        .control-btn:active {
            transform: translateY(-1px);
        }
        
        .control-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        
        .control-btn:disabled:hover {
            transform: none;
            background: white;
            color: #667eea;
        }
        
        /* Tooltip pour les boutons */
        .control-btn::after {
            content: attr(data-tooltip);
            position: absolute;
            left: -10px; /* Adjust for vertical positioning */
            transform: translateX(-100%); /* Move tooltip to the left of the button */
            top: 50%;
            transform: translateY(-50%);
            background: #333;
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 1rem; /* Adjusted from 14px */
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }
        
        .control-btn:hover::after {
            opacity: 1;
        }
        
        /* Icons pour les boutons */
        .icon-previous::before { content: "⏮️"; }
        .icon-restart::before { content: "🔄"; }
        .icon-music::before { content: "🎵"; }
        .icon-music.muted::before { content: "🔇"; }
        .icon-help::before { content: "❓"; }
        .icon-solution::before { content: "💡"; }
        .icon-skip::before { content: "⏭️"; }
        
        /* Modals */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(5px);
        }
        
        .modal.active {
            display: flex;
        }
        
        .modal-content {
            background: white;
            padding: 50px;
            border-radius: 25px;
            max-width: 700px;
            width: 90%;
            max-height: 85vh;
            overflow-y: auto;
            position: relative;
            animation: modalIn 0.3s ease;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }
        
        @keyframes modalIn {
            from { transform: scale(0.8); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }
        
        .modal-close {
            position: absolute;
            top: 25px;
            right: 25px;
            width: 45px;
            height: 45px;
            border: none;
            background: #f0f0f0;
            border-radius: 50%;
            font-size: 2rem; /* Adjusted from 28px */
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .modal-close:hover {
            background: #e0e0e0;
            transform: rotate(90deg);
        }
        
        /* Spécifique aux mini-jeux */
        .draggable {
            padding: 15px 25px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 15px;
            cursor: grab;
            user-select: none;
            margin: 8px;
            transition: all 0.3s ease;
            font-size: 1.1rem; /* Adjusted from 18px */
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.3);
        }
        
        .draggable:active {
            cursor: grabbing;
            opacity: 0.7;
            transform: scale(0.95);
        }
        
        .drop-zone {
            min-height: 70px;
            border: 3px dashed #ccc;
            border-radius: 15px;
            margin: 12px 0;
            padding: 15px;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.1rem; /* Adjusted from 18px */
            background: white;
        }
        
        .drop-zone.hover {
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.1);
            transform: scale(1.02);
        }
        
        .drop-zone.filled {
            border-style: solid;
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.05);
        }
        
        .material-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); /* Adjusted minmax for smaller font */
            gap: 25px;
            max-width: 1000px;
            margin-top: 40px;
        }
        
        .material-card {
            background: white;
            border: 3px solid #e0e0e0;
            border-radius: 20px;
            padding: 30px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }
        
        .material-icon {
            font-size: 4rem; /* Adjusted from 60px */
            line-height: 1;
        }
        
        .material-card:hover {
            border-color: #667eea;
            transform: translateY(-8px);
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.15);
        }
        
        .material-card.selected {
            border-color: #764ba2;
            background: rgba(118, 75, 162, 0.1);
            transform: scale(1.05);
        }
        
        .material-card.correct {
            background: #4caf50;
            color: white;
            border-color: #4caf50;
        }
        
        .material-card.incorrect {
            background: #f44336;
            color: white;
            border-color: #f44336;
        }
        
        .elevation-input {
            font-size: 1.8rem; /* Adjusted from 28px */
            padding: 20px 40px;
            border: 3px solid #e0e0e0;
            border-radius: 20px;
            text-align: center;
            width: 300px;
            transition: all 0.3s ease;
            margin: 20px 0;
        }
        
        .elevation-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2);
        }
        
        /* Network game */
        .network-svg {
            width: 100%;
            height: 100%;
        }
        
        .network-node {
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .network-node:hover {
            r: 25;
        }
        
        .network-line {
            stroke-width: 4;
            fill: none;
            stroke-dasharray: 10, 5;
            animation: dash 20s linear infinite;
        }
        
        @keyframes dash {
            to { stroke-dashoffset: -100; }
        }
        
        /* Confetti */
        .confetti {
            position: absolute;
            width: 12px;
            height: 12px;
            background: #667eea;
            animation: fall 3s linear forwards;
        }
        
        @keyframes fall {
            to {
                transform: translateY(100vh) rotate(360deg);
                opacity: 0;
            }
        }
        
        /* Scenario alert */
        .scenario-alert {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%);
            color: white;
            padding: 40px;
            border-radius: 25px;
            margin: 30px 0;
            text-align: center;
            animation: alertPulse 2s ease-in-out infinite;
            box-shadow: 0 10px 40px rgba(238, 90, 36, 0.4);
        }
        
        @keyframes alertPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }
        
        .scenario-icon {
            font-size: 4rem; /* Adjusted from 60px */
            margin-bottom: 20px;
        }
        
        /* Final screen stats */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 25px;
            margin: 40px 0;
            max-width: 800px;
        }
        
        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.3);
        }
        
        .stat-number {
            font-size: 3.2rem; /* Adjusted from 48px */
            font-weight: 800;
            margin: 10px 0;
        }
        
        .stat-label {
            font-size: 1.1rem; /* Adjusted from 18px */
            opacity: 0.9;
        }
        /* Added for right alignment of buttons */
        .button-center-align { /* Changed class name to reflect centering */
            width: 100%;
            max-width: 600px; /* Match the max-width of drop-zones/input for consistency */
            display: flex;
            justify-content: center; /* Centered now */
            margin-top: 30px; /* Add some top top margin */
        }

        /* New styles for the tips bar */
        .tips-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background: linear-gradient(90deg, #764ba2 0%, #667eea 100%);
            color: white;
            padding: 8px 0;
            font-size: 1rem; /* Adjusted from 16px */
            overflow: hidden;
            white-space: nowrap;
            box-shadow: 0 -5px 15px rgba(0, 0, 0, 0.2);
            z-index: 10; /* Ensure it's above other content */
            height: 30px; /* Explicit height to help with screen padding */
        }

        .tips-bar-content {
            display: inline-block;
            padding-left: 100%; /* Start off-screen to the right */
            animation: marquee 20s linear infinite; /* Adjust duration as needed */
        }

        @keyframes marquee {
            0% { transform: translateX(0%); }
            100% { transform: translateX(-100%); }
        }

        /* Home Screen Specific Styles */
        #homeScreen {
            background: linear-gradient(135deg, #1a202c 0%, #2d3748 100%); /* Darker, more professional gradient */
            color: white;
            text-shadow: 2px 2px 8px rgba(0,0,0,0.5);
            justify-content: center;
            align-items: center;
            padding: 50px;
            margin-top: 0;
            margin-right: 0;
            margin-bottom: 0;
            position: relative; /* Needed for pseudo-element background */
            overflow: hidden; /* Hide overflow from pseudo-element */
        }

        #homeScreen::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='none' fill-rule='evenodd'%3E%3Cg fill='%239C92AC' fill-opacity='0.1'%3E%3Cpath d='M36 34v-4h-2v4h-4v2h4v4h2v-4h4v-2h-4zm0-30V0h-2v4h-4v2h4v4h2V6h4V4h-4zm0 36v-4h-2v4h-4v2h4v4h2v-4h4v-2h-4zm0 36v-4h-2v4h-4v2h4v4h2v-4h4v-2h-4zM12 34v-4H10v4H6v2h4v4h2v-4h4v-2h-4zm0-30V0h-2v4H6v2h4v4h2V6h4V4h-4zm0 36v-4H10v4H6v2h4v4h2v-4h4v-2h-4zm0 36v-4H10v4H6v2h4v4h2v-4h4v-2h-4z'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E");
            opacity: 0.1;
            z-index: 0;
            animation: backgroundPan 60s linear infinite; /* Subtle animation */
        }

        @keyframes backgroundPan {
            from { background-position: 0% 0%; }
            to { background-position: 100% 100%; }
        }

        #homeScreen h1 {
            font-size: 4.5rem; /* Adjusted from 6.8rem */
            background: linear-gradient(135deg, #a78bfa 0%, #c4b5fd 100%); /* Lighter, more vibrant gradient */
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 4px 4px 12px rgba(0,0,0,0.8); /* Stronger shadow */
            margin-bottom: 25px;
            letter-spacing: 2px; /* Add some letter spacing */
            position: relative; /* Ensure it's above pseudo-element */
            z-index: 1;
        }

        #homeScreen p {
            font-size: 1.6rem; /* Adjusted from 2.4rem */
            color: rgba(255, 255, 255, 0.95);
            margin-bottom: 40px;
            text-shadow: 2px 2px 8px rgba(0,0,0,0.6);
            line-height: 1.4;
            position: relative;
            z-index: 1;
        }

        #homeScreen .logo-icon {
            width: 150px; /* Adjusted from 200px */
            height: 150px;
            font-size: 7rem; /* Adjusted from 110px */
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.98); /* Brighter background */
            box-shadow: 0 15px 40px rgba(0,0,0,0.5), inset 0 0 20px rgba(255,255,255,0.5); /* More complex shadow */
            margin-bottom: 50px;
            position: relative;
            z-index: 1;
            transition: all 0.3s ease;
        }
        #homeScreen .logo-icon:hover {
            transform: scale(1.05) rotate(5deg);
            box-shadow: 0 20px 50px rgba(0,0,0,0.7), inset 0 0 30px rgba(255,255,255,0.7);
        }

        #homeScreen .btn {
            padding: 20px 60px; /* Adjusted from 25px 70px */
            font-size: 1.8rem; /* Adjusted from 26px */
            background: linear-gradient(135deg, #a78bfa 0%, #8b5cf6 100%); /* Purple gradient */
            box-shadow: 0 10px 40px rgba(167, 139, 250, 0.7); /* Stronger shadow */
            border: 2px solid rgba(255,255,255,0.3); /* Subtle border */
            position: relative;
            z-index: 1;
        }
        #homeScreen .btn:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 50px rgba(167, 139, 250, 0.9);
        }
        .home-features {
            font-size: 1.1rem; /* Adjusted from 1.6rem */
            color: rgba(255, 255, 255, 0.85);
            margin-bottom: 60px; /* More space */
            text-align: center;
            line-height: 1.6;
            text-shadow: 1px 1px 4px rgba(0,0,0,0.4);
            position: relative;
            z-index: 1;
        }
        .home-features p {
            margin: 8px 0;
        }

        /* Character and Speech Bubble */
        #gameCharacter {
            position: fixed;
            bottom: 80px; /* Above the tips bar and progress bar */
            left: 30px;
            font-size: 5rem; /* Adjust size, e.g., 80px */
            z-index: 50; /* Above game content, below modals */
            transition: transform 0.3s ease-out;
        }

        #speechBubble {
            position: fixed;
            bottom: 140px; /* Above the character */
            left: 100px; /* To the right of the character */
            background: white;
            padding: 15px 25px;
            border-radius: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            max-width: 250px; /* Limit width */
            text-align: center;
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.3s ease-out, transform 0.3s ease-out;
            z-index: 50;
        }

        #speechBubble.active {
            opacity: 1;
            transform: translateY(0);
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-header" style="display: none;">
            <div class="logo">
                <div class="logo-icon">🏗️</div>
                <span>LTD SIMULATEUR</span>
            </div>
            <div class="header-stats">
                <div class="font-size-controls">
                    <button class="font-size-btn" onclick="decreaseFontSize()">A-</button>
                    <button class="font-size-btn" onclick="increaseFontSize()">A+</button>
                </div>
                <div class="header-item">
                    <span class="score-icon"></span>
                    <span id="score">0</span>
                </div>
                <div class="header-item timer-display">
                    <span class="timer-icon"></span>
                    <span id="timer">0</span>s
                </div>
            </div>
        </div>
        
        <!-- Écran d'accueil -->
        <div id="homeScreen" class="screen active">
            <div class="logo-icon">🏗️</div>
            <h1>LTD SIMULATEUR</h1>
            <p>L'Expérience Complète du Projeteur VRD</p>
            <div class="home-features">
                <p>🔥 30 Niveaux de défis techniques</p>
                <p>🚨 Scénarios réalistes de chantier</p>
                <p>🚀 Devenez expert en Voirie et Réseaux Divers</p>
            </div>
            <button class="btn" onclick="startGame()">Commencer l'aventure</button>
        </div>
        
        <!-- Écrans de jeu -->
        <div id="quizScreen" class="screen"></div>
        <div id="gameScreen" class="screen"></div>
        <div id="finalScreen" class="screen"></div>
        
        <!-- Contrôles -->
        <div class="controls" style="display: none;">
            <button class="control-btn icon-previous" data-tooltip="Niveau précédent" onclick="previousLevel()"></button>
            <button class="control-btn icon-restart" data-tooltip="Recommencer" onclick="confirmRestart()"></button>
            <button class="control-btn icon-music" data-tooltip="Musique" onclick="toggleMusic()"></button>
            <button class="control-btn icon-help" data-tooltip="Aide" onclick="showHelp()"></button>
            <button class="control-btn icon-solution" data-tooltip="Solution (-50 pts)" onclick="showSolution()"></button>
            <button class="control-btn icon-skip" data-tooltip="Passer (-10 pts)" onclick="skipLevel()"></button>
        </div>

        <!-- Character and Speech Bubble -->
        <div id="gameCharacter" style="display: none;"></div>
        <div id="speechBubble" style="display: none;"><span id="speechBubbleText"></span></div>

        <!-- Chronological Progress Bar (moved to bottom) -->
        <div class="progress-bar-chronological" style="display: none;">
            <div id="chronologicalProgressBarFill" class="progress-fill-chronological"></div>
        </div>

        <!-- Tips Bar (new) -->
        <div class="tips-bar" style="display: none;">
            <span id="tipsBarContent" class="tips-bar-content"></span>
        </div>
    </div>
    
    <!-- Modals -->
    <div id="helpModal" class="modal">
        <div class="modal-content">
            <button class="modal-close" onclick="closeModal('helpModal')">✕</button>
            <h2 style="color: #667eea; margin-bottom: 30px;">📚 Comment jouer ?</h2>
            <p style="font-size: 1.1rem; line-height: 1.6; margin-bottom: 25px;">
                Bienvenue dans LTD Simulateur ! Votre objectif est de devenir un expert en VRD 
                (Voirie et Réseaux Divers) en complétant 30 défis variés.
            </p>
            <h3 style="color: #764ba2; margin: 25px 0 15px;">🎮 Types de défis :</h3>
            <div style="background: #f8f9fa; padding: 20px; border-radius: 15px; margin-bottom: 25px;">
                <p style="margin: 10px 0;"><strong>📝 Quiz</strong> : Questions techniques sur la VRD</p>
                <p style="margin: 10px 0;"><strong>🔧 Matériaux</strong> : Sélection des bons matériaux</p>
                <p style="margin: 10px 0;"><strong>🔌 Réseaux</strong> : Connexion de canalisations</p>
                <p style="margin: 10px 0;"><strong>📐 Construction</strong> : Assemblage des couches</p>
                <p style="margin: 10px 0;"><strong>🧮 Calculs</strong> : Problèmes d'altitude et pente</p>
                <p style="margin: 10px 0;"><strong>⚠️ Scénarios</strong> : Situations d'urgence</p>
                <p style="margin: 10px 0;"><strong>🌟 BONUS - Détection de Conflits</strong> : Identifiez les problèmes de réseaux.</p>
                <p style="margin: 10px 0;"><strong>🌟 BONUS - Calcul de Volume</strong> : Calculez les volumes de terrassement.</p>
            </div>
            <h3 style="color: #764ba2; margin: 25px 0 15px;">💯 Système de points :</h3>
            <div style="background: #e8f5e9; padding: 20px; border-radius: 15px; margin-bottom: 25px;">
                <p style="margin: 10px 0;">✅ Bonne réponse : <strong>+50 à +100 points</strong></p>
                <p style="margin: 10px 0;">❌ Mauvaise réponse : <strong>-10 à -30 points</strong></p>
                <p style="margin: 10px 0;">⏰ Temps écoulé : <strong>-20 points</strong></p>
                <p style="margin: 10px 0;">💡 Voir solution : <strong>-50 points</strong></p>
                <p style="margin: 10px 0;">⏭️ Passer : <strong>-10 points</strong></p>
                <p style="margin: 10px 0;">🔥 Bonus réussis : <strong>Doublent les points de la prochaine question !</strong></p>
            </div>
            <button class="btn" onclick="closeModal('helpModal')">Compris !</button>
        </div>
    </div>
    
    <div id="confirmModal" class="modal">
        <div class="modal-content" style="text-align: center;">
            <h2 id="confirmTitle" style="color: #667eea; margin-bottom: 30px;">Confirmer</h2>
            <p style="font-size: 1.2rem; margin: 30px 0;" id="confirmText">Êtes-vous sûr ?</p>
            <div style="display: flex; gap: 20px; justify-content: center; margin-top: 40px;">
                <button class="btn" onclick="confirmAction()">Oui</button>
                <button class="btn btn-secondary" onclick="closeModal('confirmModal')">Non</button>
            </div>
        </div>
    </div>

    <div id="correctionModal" class="modal">
        <div class="modal-content">
            <button class="modal-close" onclick="closeModal('correctionModal')">✕</button>
            <h2 style="color: #667eea; margin-bottom: 30px;">📊 Rapport de Correction</h2>
            <div id="correctionReportContent" style="font-size: 1.1rem; line-height: 1.6;">
                <!-- Correction content will be inserted here -->
            </div>
            <button class="btn mt-8" onclick="copyCorrectionToClipboard()">Copier la correction</button>
        </div>
    </div>

<script>
// Game state
let gameState = {
    currentLevel: 0,
    score: 0,
    timer: null,
    timeLeft: 0,
    musicEnabled: true,
    // Store detailed answers for correction report
    answers: [], // { levelIndex: N, type: 'quiz', question: '...', userAnswer: '...', correctAnswer: '...', isCorrect: true/false, pointsEarned: X }
    synth: null,
    pendingAction: null,
    skillScores: { // Track performance per skill type
        quiz: { correct: 0, total: 0 },
        material: { correct: 0, total: 0 },
        drag: { correct: 0, total: 0 },
        calc: { correct: 0, total: 0 },
        network: { correct: 0, total: 0 },
        scenario: { correct: 0, total: 0 },
        conflict_detection: { correct: 0, total: 0 }, // New skill type
        volume_calc: { correct: 0, total: 0 } // New skill type
    },
    baseFontSize: 14, // Default base font size in pixels, adjusted to 14px
    characterTipInterval: null, // Interval for character tips
    shuffledLevels: [], // New array to store shuffled levels
    isBonusRound: false, // Flag to indicate if current round is a bonus round
    bonusLevelData: null, // Stores the current bonus level data
    bonusMultiplier: 1 // Multiplier for points on the next question
};

// Level data
const originalLevels = [ // Renamed to originalLevels
    // Level 1-5: Introduction
    { type: 'quiz', question: "Que signifie VRD ?", answers: ["Voirie et Réseaux Divers", "Vraiment Rapide et Dangereux", "Vérification Routière Détaillée"], correct: 0, points: 50 },
    { type: 'quiz', question: "Quelle est la couleur normalisée pour l'eau potable ?", answers: ["Rouge", "Bleu", "Vert", "Jaune"], correct: 1, points: 50 },
    { type: 'material', question: "Sélectionnez le matériau le plus adapté pour un trottoir", materials: ["Asphalte", "Béton désactivé", "Terre battue", "Gravier"], icons: ["🛣️", "🧱", "🌿", "🚧"], correct: 1, points: 75 },
    { type: 'quiz', question: "Qu'est-ce qu'un plan de récolement ?", answers: ["Le plan initial du projet", "Un plan des travaux réalisés", "Un planning de chantier"], correct: 1, points: 50 },
    { type: 'network', question: "Tracez le réseau d'eaux usées du point A au point B", points: 100, correctPath: ['nodeA', 'nodeB'] }, // Added correctPath
    
    // Level 6-10: Technical basics
    { type: 'quiz', question: "Quelle est la pente minimale pour un réseau EU ?", answers: ["0.5%", "1%", "2%", "5%"], correct: 1, points: 75 },
    { type: 'drag', question: "Assemblez les couches d'une voirie (de bas en haut)", items: ["Sol support", "Géotextile", "Grave non traitée", "Enrobé"], points: 100 },
    { type: 'quiz', question: "Qu'est-ce qu'un avaloir ?", answers: ["Une bouche d'incendie", "Un dispositif de collecte des eaux", "Un type de regard"], correct: 1, points: 50 },
    { type: 'calc', question: "Altitude départ: 100.00m, pente 2% sur 50m. Altitude finale ?", answer: "99.00", points: 100 },
    { type: 'quiz', question: "Profondeur hors gel moyenne en France ?", answers: ["20-30cm", "50-80cm", "100-120cm"], correct: 1, points: 75 },
    
    // Level 11-15: Networks
    { type: 'quiz', question: "Couleur du grillage avertisseur électrique ?", answers: ["Bleu", "Rouge", "Vert", "Jaune"], correct: 1, points: 50 },
    { type: 'material', question: "Quel regard pour un changement de direction EU ?", materials: ["Regard de visite", "Bouche à clé", "Avaloir", "Tabouret"], icons: ["🕳️", "🔧", "🌊", "🪑"], correct: 0, points: 75 },
    { type: 'quiz', question: "Distance minimale entre eau potable et EU ?", answers: ["20cm", "40cm", "60cm", "100cm"], correct: 1, points: 75 },
    { type: 'network', question: "Connectez le réseau télécom en évitant les autres réseaux", points: 100, correctPath: ['nodeA', 'nodeD'] }, // Added correctPath
    { type: 'quiz', question: "Que signifie PMR ?", answers: ["Projet Majeur Régional", "Personnes à Mobilité Réduite", "Plan de Mise en Route"], correct: 1, points: 50 },
    
    // Level 16-20: VRD Deep Dive
    { type: 'drag', question: "Classez les étapes de la construction d'une chaussée (du début à la fin)", items: ["Terrassement", "Mise en œuvre des couches de forme", "Réalisation des couches de roulement", "Signalisation et marquage"], points: 100 },
    { type: 'quiz', question: "Quel est le rôle d'un géotextile ?", answers: ["Empêcher la pousse des mauvaises herbes", "Séparer des couches de matériaux", "Drainer l'eau", "Renforcer la structure"], correct: 1, points: 75 },
    { type: 'material', question: "Quel type de canalisation pour l'assainissement gravitaire ?", materials: ["PVC", "PEHD", "Fonte", "Acier"], icons: ["📏", "🔗", "⚙️", "🔩"], correct: 0, points: 75 },
    { type: 'calc', question: "Altitude finale: 85.50m, pente 1.5% sur 100m. Altitude départ ?", answer: "87.00", points: 100 },
    { type: 'quiz', question: "Qu'est-ce qu'un BPU en VRD ?", answers: ["Bordure Paveur Urbain", "Béton Prêt à l'Usage", "Bureau des Projets Urbains"], correct: 0, points: 50 },

    // Level 21-25: Practical cases and standards
    { type: 'network', question: "Optimisez le tracé du réseau d'éclairage public pour minimiser les longueurs", points: 120, correctPath: ['nodeB', 'nodeC'] }, // Added correctPath
    { type: 'quiz', question: "Quelle norme régit l'accessibilité PMR en France ?", answers: ["NF P98-331", "Arrêté du 15 janvier 2007", "DTU 20.1"], correct: 1, points: 75 },
    { type: 'material', question: "Matériau pour une conduite d'eau potable sous pression ?", materials: ["PVC-O", "Grès", "Béton armé", "Fibrociment"], icons: ["💧", "🏺", "🏗️", "💨"], correct: 0, points: 80 },
    { type: 'calc', question: "Distance: 75m, dénivelé: 1.5m. Quelle est la pente en % ?", answer: "2.00", points: 100 },
    { type: 'scenario', question: "Un réseau d'eau potable est endommagé. Quelle est la première action à mener ?", actions: ["Couper l'arrivée d'eau", "Réparer immédiatement", "Prévenir les usagers", "Analyser la cause"], correct: 0, points: 100 },

    // Level 26-30: Expertise and project management
    { type: 'drag', question: "Classez les étapes d'un projet VRD (de l'étude à la réception)", items: ["Terrassement", "Mise en œuvre des couches de forme", "Réalisation des couches de roulement", "Signalisation et marquage"], points: 120 },
    { type: 'quiz', question: "Quelle est la fonction principale d'un caniveau ?", answers: ["Délimiter la chaussée", "Collecter les eaux de ruissellement", "Servir de support aux réseaux", "Améliorer l'esthétique"], correct: 1, points: 60 },
    { type: 'network', question: "Concevez un réseau de drainage pluvial pour un parking, avec points de collecte", points: 130, correctPath: ['nodeC', 'nodeD'] }, // Added correctPath
    { type: 'calc', question: "Longueur de réseau: 200m, pente 0.8%. Quel est le dénivelé total ?", answer: "1.60", points: 100 },
    { type: 'scenario', question: "Vous découvrez un réseau non répertorié lors des terrassements. Que faites-vous ?", actions: ["Continuer les travaux avec prudence", "Arrêter les travaux et informer le chef de projet", "Essayer de l'identifier vous-même", "Le contourner sans le signaler"], correct: 1, points: 150 }
];

const bonusLevels = [
    { type: 'conflict_detection', question: "Un réseau d'eau potable passe à 15 cm au-dessus d'un câble électrique. Y a-t-il un conflit ?", options: ["Oui, conflit de distance verticale insuffisante", "Non, c'est conforme", "Oui, conflit de croisement horizontal"], correct: 0, points: 150 },
    { type: 'volume_calc', question: "Calculez le volume de terre (en m³) à évacuer pour une fouille de 10m de long, 2m de large et 1.5m de profondeur.", answer: "30.00", points: 150 },
    { type: 'volume_calc', question: "Quel volume de béton (en m³) est nécessaire pour une dalle de 5m x 4m avec une épaisseur de 0.20m ?", answer: "4.00", points: 120 },
    { type: 'conflict_detection', question: "Une canalisation d'assainissement gravitaire doit traverser une zone rocheuse. Quel est le risque principal ?", options: ["Rupture de la canalisation due aux mouvements du sol", "Difficulté de raccordement aux autres réseaux", "Coût élevé du terrassement et risque d'endommagement de la roche", "Infiltration d'eau dans la canalisation"], correct: 2, points: 140 }
];

// Tips for the scrolling bar
const gameTips = [
    "Astuce: Vérifiez toujours les plans de réseaux avant de terrasser.",
    "Astuce: Une bonne gestion des eaux pluviales est cruciale pour la durabilité des ouvrages.",
    "Astuce: La profondeur hors gel varie selon les régions, adaptez vos calculs!",
    "Astuce: Les normes PMR garantissent l'accessibilité pour tous, ne les négligez jamais.",
    "Astuce: Un plan de récolement précis est essentiel pour les futures interventions.",
    "Astuce: La couleur bleue indique généralement les réseaux d'eau potable.",
    "Astuce: La pente minimale pour un réseau d'eaux usées est de 1% pour assurer l'écoulement.",
    "Astuce: Le géotextile sépare les couches de matériaux et prévient le mélange.",
    "Astuce: Les regards de visite permettent l'inspection et l'entretien des réseaux.",
    "Astuce: En cas de réseau non répertorié, stoppez les travaux et signalez-le immédiatement."
];
let currentTipIndex = 0;
let tipInterval = null;

// Utility functions
function showScreen(screenId) {
    document.querySelectorAll('.screen').forEach(screen => {
        screen.classList.remove('active');
        screen.classList.remove('bonus-active'); // Remove bonus class when switching screens
    });
    document.getElementById(screenId).classList.add('active');
}

function updateHeader() {
    document.getElementById('score').textContent = gameState.score;
    document.getElementById('timer').textContent = gameState.timeLeft;
    updateChronologicalProgressBar(); // Update progress bar on header update
}

function updateChronologicalProgressBar() {
    const progressBarFill = document.getElementById('chronologicalProgressBarFill');
    // Use gameState.shuffledLevels.length for total levels
    const progressPercentage = (gameState.currentLevel / gameState.shuffledLevels.length) * 100;
    if (progressBarFill) { // Added null check
        progressBarFill.style.width = `${progressPercentage}%`;
        progressBarFill.textContent = `${gameState.currentLevel}/${gameState.shuffledLevels.length}`;
    }
}

function startTimer(duration) {
    clearInterval(gameState.timer);
    gameState.timeLeft = duration;
    updateHeader();
    const timerElement = document.querySelector('.timer-display');
    if (timerElement) { // Added null check
        timerElement.classList.remove('warning');
    }


    gameState.timer = setInterval(() => {
        gameState.timeLeft--;
        updateHeader();
        if (gameState.timeLeft <= 10 && gameState.timeLeft > 0) {
            if (timerElement) { // Added null check
                timerElement.classList.add('warning');
            }
            playSound('shortBeep');
        } else if (gameState.timeLeft <= 0) {
            clearInterval(gameState.timer);
            if (timerElement) { // Added null check
                timerElement.classList.remove('warning');
            }
            handleTimeout();
        }
    }, 1000);
}

function stopTimer() {
    clearInterval(gameState.timer);
    const timerElement = document.querySelector('.timer-display');
    if (timerElement) { // Added null check
        timerElement.classList.remove('warning');
    }
}

function playSound(type) {
    if (!gameState.musicEnabled) return;

    // Ensure synth is initialized
    if (!gameState.synth) {
        console.warn("Tone.PolySynth not initialized when playSound was called.");
        return;
    }

    switch (type) {
        case 'correct':
            gameState.synth.triggerAttackRelease("C5", "8n");
            break;
        case 'incorrect':
            gameState.synth.triggerAttackRelease("C3", "8n");
            break;
        case 'levelUp':
            const levelUpNotes = ["C4", "E4", "G4"];
            const levelUpDuration = "0.5s";
            levelUpNotes.forEach((note, index) => {
                // Play each note with a tiny offset to ensure they are distinct events
                // and avoid the "Invalid argument(s) to setValueAtTime" error with arrays.
                gameState.synth.triggerAttackRelease(note, levelUpDuration, Tone.context.currentTime + (index * 0.01));
            });
            break;
        case 'gameOver':
            const gameOverNotes = ["C3", "G2", "C2"];
            const gameOverDuration = "1s";
            gameOverNotes.forEach((note, index) => {
                gameState.synth.triggerAttackRelease(note, gameOverDuration, Tone.context.currentTime + (index * 0.01));
            });
            break;
        case 'shortBeep':
            gameState.synth.triggerAttackRelease("C4", "32n");
            break;
        case 'buttonClick':
            gameState.synth.triggerAttackRelease("C6", "64n");
            break;
        case 'bonusStart':
            gameState.synth.triggerAttackRelease(["C5", "E5", "G5"], "0.5"); // Upbeat chord
            break;
    }
}

function toggleMusic() {
    gameState.musicEnabled = !gameState.musicEnabled;
    const musicBtn = document.querySelector('.icon-music');
    if (musicBtn) { // Added null check
        if (gameState.musicEnabled) {
            musicBtn.classList.remove('muted');
            // Potentially start background music here if desired
        } else {
            musicBtn.classList.add('muted');
            // Stop background music here if playing
        }
    }
    playSound('buttonClick');
}

function showModal(modalId) {
    const modal = document.getElementById(modalId);
    if (modal) { // Added null check
        modal.classList.add('active');
    }
}

function closeModal(modalId) {
    const modal = document.getElementById(modalId);
    if (modal) { // Added null check
        modal.classList.remove('active');
    }
    gameState.pendingAction = null; // Clear any pending action when modal closes
}

function confirmAction() {
    if (gameState.pendingAction) {
        gameState.pendingAction();
        gameState.pendingAction = null;
    }
    closeModal('confirmModal');
}

function showConfirmModal(title, text, action) {
    const confirmTitle = document.getElementById('confirmTitle');
    const confirmText = document.getElementById('confirmText');
    if (confirmTitle) { // Added null check
        confirmTitle.textContent = title;
    }
    if (confirmText) { // Added null check
        confirmText.textContent = text;
    }
    gameState.pendingAction = action;
    showModal('confirmModal');
}

/**
 * Shuffles an array in place using the Fisher-Yates (Knuth) algorithm.
 * @param {Array} array The array to shuffle.
 */
function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]]; // Swap elements
    }
}

// Navigation and game functions
async function startGame() { // Make it async
    // Ensure audio context is started on user gesture
    if (Tone.context.state !== 'running') {
        await Tone.start(); // Await Tone.start()
    }
    // Initialize PolySynth for playing chords
    if (!gameState.synth) {
        gameState.synth = new Tone.PolySynth(Tone.Synth).toDestination();
    }

    gameState.currentLevel = 0;
    gameState.score = 0;
    gameState.answers = []; // Reset answers for new game
    // Reset skill scores for new game
    for (const skill in gameState.skillScores) {
        gameState.skillScores[skill] = { correct: 0, total: 0 };
    }

    // Shuffle levels for a new game
    gameState.shuffledLevels = [...originalLevels]; // Create a copy to shuffle
    shuffleArray(gameState.shuffledLevels);
    
    // Reset bonus state
    gameState.isBonusRound = false;
    gameState.bonusLevelData = null;
    gameState.bonusMultiplier = 1;

    const gameHeader = document.querySelector('.game-header');
    const controls = document.querySelector('.controls');
    const progressBar = document.querySelector('.progress-bar-chronological');
    const tipsBar = document.querySelector('.tips-bar');
    const gameCharacter = document.getElementById('gameCharacter');

    if (gameHeader) gameHeader.style.display = 'flex';
    if (controls) controls.style.display = 'flex';
    if (progressBar) progressBar.style.display = 'block'; // Show progress bar
    if (tipsBar) tipsBar.style.display = 'block'; // Show tips bar
    if (gameCharacter) gameCharacter.style.display = 'block'; // Show character

    startTipsMarquee(); // Start tips marquee
    displayCharacter('🚀', "Bienvenue, Projeteur ! Prêt à relever le défi ?", 3000); // Welcome message
    loadLevel();
    playSound('levelUp');
}

function loadLevel() {
    stopTimer();
    const levelToLoad = gameState.isBonusRound ? gameState.bonusLevelData : gameState.shuffledLevels[gameState.currentLevel];
    const quizScreen = document.getElementById('quizScreen');
    const gameScreen = document.getElementById('gameScreen');
    
    // Remove bonus-active class from all screens first
    document.querySelectorAll('.screen').forEach(screen => screen.classList.remove('bonus-active'));

    if (quizScreen) quizScreen.innerHTML = ''; // Clear previous content
    if (gameScreen) gameScreen.innerHTML = ''; // Clear previous content

    updateHeader(); // Update header including progress bar
    
    if (!levelToLoad) {
        endGame();
        return;
    }

    // Determine time limit based on level type
    let timeLimit;
    switch (levelToLoad.type) {
        case 'quiz':
            timeLimit = 30; // 30 seconds for quiz
            break;
        case 'material':
        case 'drag':
        case 'calc':
            timeLimit = 45; // 45 seconds for material, drag, calc
            break;
        case 'network':
            timeLimit = 60; // 60 seconds for network
            break;
        case 'scenario':
            timeLimit = 90; // 90 seconds for scenario
            break;
        case 'conflict_detection': // New bonus type
            timeLimit = 50; 
            break;
        case 'volume_calc': // New bonus type
            timeLimit = 40; 
            break;
        default:
            timeLimit = 30; // Default time
    }
    startTimer(timeLimit);

    // Render level based on type
    switch (levelToLoad.type) {
        case 'quiz':
            renderQuizLevel(levelToLoad);
            showScreen('quizScreen');
            break;
        case 'material':
            renderMaterialLevel(levelToLoad);
            showScreen('quizScreen'); // Using quizScreen for material selection
            break;
        case 'drag':
            renderDragLevel(levelToLoad);
            showScreen('gameScreen'); // Using gameScreen for drag and drop
            break;
        case 'calc':
            renderCalcLevel(levelToLoad);
            showScreen('quizScreen'); // Using quizScreen for calculation
            break;
        case 'network':
            renderNetworkLevel(levelToLoad);
            showScreen('gameScreen'); // Using gameScreen for network drawing
            break;
        case 'scenario':
            renderScenarioLevel(levelToLoad);
            showScreen('quizScreen'); // Using quizScreen for scenario
            break;
        case 'conflict_detection': // New bonus type
            renderConflictDetectionLevel(levelToLoad);
            showScreen('quizScreen');
            const quizScreenElement = document.getElementById('quizScreen');
            if (quizScreenElement) { // Added null check
                quizScreenElement.classList.add('bonus-active'); // Add bonus class
            }
            break;
        case 'volume_calc': // New bonus type
            renderVolumeCalcLevel(levelToLoad);
            showScreen('quizScreen');
            const quizScreenElement2 = document.getElementById('quizScreen');
            if (quizScreenElement2) { // Added null check
                quizScreenElement2.classList.add('bonus-active'); // Add bonus class
            }
            break;
        default:
            console.error("Unknown level type:", levelToLoad.type);
            // Fallback to a simple quiz or skip
            break;
    }
    applyFontSize(); // Apply font size after rendering new content
}

function startBonusRoundTransition() {
    playSound('bonusStart');
    displayCharacter('🌟', "NIVEAU BONUS ! Doublez vos points sur la prochaine question !", 3000); // Character announces bonus
    
    // Directly load the bonus level after a short delay for the character message
    setTimeout(() => {
        loadLevel(); // Load the bonus level
    }, 1000); // Short delay to allow character message to be seen/heard
}

function nextLevel() {
    stopTimer();

    // If the previous level was a bonus round, reset bonus state
    if (gameState.isBonusRound) {
        gameState.isBonusRound = false;
        gameState.bonusLevelData = null;
        // The bonusMultiplier is consumed by the checkAnswer function of the *next* question.
        // So we don't reset it here, it will be reset to 1 by the next regular loadLevel.
        gameState.currentLevel++; // Move to the next *regular* level
    } else {
        gameState.currentLevel++; // Move to the next *regular* level
        // Randomly decide if the *next* level should be a bonus level (20% chance)
        // Only trigger if there are still regular levels left
        if (Math.random() < 0.2 && gameState.currentLevel < gameState.shuffledLevels.length) {
            gameState.isBonusRound = true;
            gameState.bonusLevelData = bonusLevels[Math.floor(Math.random() * bonusLevels.length)];
            gameState.bonusMultiplier = 2; // Set multiplier for the *next* question
            startBonusRoundTransition(); // Start the bonus transition
            return; // Exit to prevent immediate loadLevel
        } else {
            gameState.bonusMultiplier = 1; // Ensure multiplier is 1 for regular levels
        }
    }

    if (gameState.currentLevel < gameState.shuffledLevels.length || gameState.isBonusRound) {
        loadLevel();
        playSound('levelUp');
    } else {
        endGame();
    }
}

function previousLevel() {
    if (gameState.currentLevel > 0) {
        showConfirmModal("Retour au niveau précédent", "Vous perdrez le score du niveau actuel. Continuer ?", () => {
            // If we were in a bonus round, we need to go back to the regular level before it
            if (gameState.isBonusRound) {
                gameState.isBonusRound = false;
                gameState.bonusLevelData = null;
                gameState.bonusMultiplier = 1; // Reset multiplier
                // currentLevel does not change if we were in a bonus round, as it's an interstitial level
            } else {
                gameState.currentLevel--;
            }
            
            // Remove the last answer record if going back
            if (gameState.answers.length > gameState.currentLevel) {
                const lastAnswer = gameState.answers.pop();
                // If the popped answer was correct, decrement correct count for that skill
                if (lastAnswer.isCorrect) {
                    gameState.skillScores[lastAnswer.type].correct--;
                }
                gameState.skillScores[lastAnswer.type].total--; // Always decrement total
            }
            loadLevel();
        });
    } else {
        // Optionally show a message that they are on the first level
    }
}

function confirmRestart() {
    showConfirmModal("Recommencer le jeu", "Êtes-vous sûr de vouloir recommencer du début ? Votre score sera remis à zéro.", startGame);
}

function showHelp() {
    showModal('helpModal');
    playSound('buttonClick');
}

function showSolution() {
    const pointsCost = 50;
    if (gameState.score < pointsCost) {
        displayCharacter('🤔', `Vous n'avez pas assez de points pour cela ! Il vous faut ${pointsCost} points.`, 3000);
        playSound('incorrect');
        return;
    }

    showConfirmModal("Afficher la solution", `Afficher la solution vous coûtera ${pointsCost} points. Continuer ?`, () => {
        const level = gameState.isBonusRound ? gameState.bonusLevelData : gameState.shuffledLevels[gameState.currentLevel];
        const pointsLost = pointsCost;
        gameState.score = Math.max(0, gameState.score - pointsLost); // Ensure score doesn't go below zero
        updateHeader();
        
        // Record the answer as incorrect due to solution view
        gameState.answers.push({
            levelIndex: gameState.currentLevel,
            type: level.type,
            question: level.question,
            userAnswer: "Solution affichée",
            correctAnswer: getCorrectAnswerForLevel(level),
            isCorrect: false,
            pointsEarned: -pointsLost
        });
        // Update skill score for this type as incorrect
        gameState.skillScores[level.type].total++;
        // No increment for correct as solution was viewed

        // Implement solution display based on current level type
        if (level.type === 'quiz' || level.type === 'conflict_detection' || level.type === 'scenario') {
            const buttons = document.querySelectorAll('.answer-btn');
            buttons.forEach((btn) => {
                if (btn.dataset.isCorrect === 'true') { // Check the data attribute
                    btn.classList.add('correct');
                } else {
                    btn.classList.add('incorrect');
                }
                btn.disabled = true;
            });
        } else if (level.type === 'material') {
            const cards = document.querySelectorAll('.material-card');
            cards.forEach((card) => {
                if (card.dataset.isCorrect === 'true') { // Check the data attribute
                    card.classList.add('correct');
                } else {
                    card.classList.add('incorrect');
                }
                card.style.pointerEvents = 'none'; // Disable clicks
            });
        } else if (level.type === 'calc' || level.type === 'volume_calc') { // Added volume_calc
            const input = document.getElementById('elevationInput');
            const validateBtn = document.getElementById('validateCalcBtn');
            if (input) { // Added null check
                input.value = level.answer;
                input.style.borderColor = '#4caf50';
                input.style.boxShadow = '0 0 0 3px rgba(76, 175, 80, 0.2)';
            }
            if (validateBtn) { // Added null check
                validateBtn.disabled = true;
            }
        } else if (level.type === 'drag') {
            const dropZones = document.querySelectorAll('.drop-zone');
            const correctOrder = level.items; // Use items from the current shuffled level
            dropZones.forEach((zone, index) => {
                const droppedItem = zone.querySelector('.draggable');
                if (droppedItem) droppedItem.remove(); // Remove existing items
                
                const correctItem = document.createElement('div');
                correctItem.classList.add('draggable', 'correct');
                correctItem.textContent = correctOrder[index];
                correctItem.draggable = false;
                zone.appendChild(correctItem);
                zone.style.borderColor = '#4caf50';
                zone.style.borderStyle = 'solid';
            });
            const gameScreenBtn = document.getElementById('gameScreen').querySelector('.btn');
            if (gameScreenBtn) { // Added null check
                gameScreenBtn.disabled = true;
            }
        } else if (level.type === 'network') {
            // For network, display the correct path visually
            const drawnLinesGroup = document.getElementById('drawnLines');
            if (drawnLinesGroup) { // Added null check
                drawnLinesGroup.innerHTML = ''; // Clear any user-drawn lines
            }

            const nodes = [
                { id: 'nodeA', cx: 100, cy: 100, color: 'blue' },
                { id: 'nodeB', cx: 400, cy: 100, color: 'blue' },
                { id: 'nodeC', cx: 100, cy: 400, color: 'red' },
                { id: 'nodeD', cx: 400, cy: 400, color: 'red' },
                { id: 'nodeE', cx: 250, cy: 250, color: 'green' }
            ];
            // Use the correctPath from the level data
            const correctPath = level.correctPath; 

            if (correctPath && correctPath.length === 2) { // Added null check for correctPath
                const startNode = nodes.find(n => n.id === correctPath[0]);
                const endNode = nodes.find(n => n.id === correctPath[1]);

                if (startNode && endNode && drawnLinesGroup) { // Added null check for drawnLinesGroup
                    const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                    line.setAttribute('x1', startNode.cx);
                    line.setAttribute('y1', startNode.cy);
                    line.setAttribute('x2', endNode.cx);
                    line.setAttribute('y2', endNode.cy);
                    line.setAttribute('stroke', '#4caf50'); // Green for correct
                    line.setAttribute('stroke-width', '4');
                    line.setAttribute('marker-end', 'url(#arrow)');
                    drawnLinesGroup.appendChild(line);
                }
            }
            const gameScreenBtn = document.getElementById('gameScreen').querySelector('.btn');
            if (gameScreenBtn) { // Added null check
                gameScreenBtn.disabled = true;
            }
        }

        setTimeout(nextLevel, 3000); // Automatically move to next level after showing solution
        playSound('incorrect'); // Play a sound indicating score loss
        displayCharacter('💡', "Pas de souci, l'apprentissage continue !", 3000); // Solution message
    });
}

function skipLevel() {
    const pointsCost = 10;
    if (gameState.score < pointsCost) {
        displayCharacter('🤔', `Vous n'avez pas assez de points pour cela ! Il vous faut ${pointsCost} points.`, 3000);
        playSound('incorrect');
        return;
    }

    showConfirmModal("Passer le niveau", `Passer ce niveau vous coûtera ${pointsCost} points. Continuer ?`, () => {
        const level = gameState.isBonusRound ? gameState.bonusLevelData : gameState.shuffledLevels[gameState.currentLevel];
        const pointsLost = pointsCost;
        gameState.score = Math.max(0, gameState.score + pointsLost);
        updateHeader();
        
        // Record the answer as skipped
        gameState.answers.push({
            levelIndex: gameState.currentLevel,
            type: level.type,
            question: level.question,
            userAnswer: "Niveau passé",
            correctAnswer: getCorrectAnswerForLevel(level),
            isCorrect: false,
            pointsEarned: -pointsLost
        });
        // Update skill score for this type as incorrect (or not attempted)
        gameState.skillScores[level.type].total++;

        nextLevel();
        playSound('incorrect'); // Play a sound indicating score loss
        displayCharacter('⏭️', "Parfois, il faut savoir passer à autre chose.", 3000); // Skip message
    });
}

function handleTimeout() {
    const level = gameState.isBonusRound ? gameState.bonusLevelData : gameState.shuffledLevels[gameState.currentLevel];
    const pointsLost = 20;
    gameState.score = Math.max(0, gameState.score + pointsLost); // Penalty for timeout
    updateHeader();
    
    // Record the answer as timeout
    gameState.answers.push({
        levelIndex: gameState.currentLevel,
        type: level.type,
        question: level.question,
        userAnswer: "Temps écoulé",
        correctAnswer: getCorrectAnswerForLevel(level),
        isCorrect: false,
        pointsEarned: pointsLost // This should be negative for penalty
    });
    // Update skill score for this type as incorrect
    gameState.skillScores[level.type].total++;

    // Visually indicate timeout, e.g., flash timer red
    const timerElement = document.querySelector('.timer-display');
    if (timerElement) { // Added null check
        timerElement.classList.add('warning');
    }
    playSound('incorrect');
    displayCharacter('⏰', "Oups, le temps est écoulé ! Plus vite la prochaine fois.", 3000); // Timeout message
    setTimeout(() => {
        if (timerElement) { // Added null check
            timerElement.classList.remove('warning');
        }
        nextLevel();
    }, 1500); // Wait a bit before moving to next level
}

function getCorrectAnswerForLevel(level) {
    // For levels that have been shuffled, we need to refer to the original level
    // to get the correct answer's text/value, as the index might have changed.
    // For bonus levels, they are not in originalLevels, so we directly use the level object.
    const sourceLevel = originalLevels.find(l => l.question === level.question) || bonusLevels.find(l => l.question === level.question) || level;

    switch (sourceLevel.type) {
        case 'quiz':
            return sourceLevel.answers[sourceLevel.correct];
        case 'material':
            return sourceLevel.materials[sourceLevel.correct];
        case 'drag':
            return sourceLevel.items.join(' > ');
        case 'calc':
            return sourceLevel.answer;
        case 'network':
            // Use the correctPath from the sourceLevel
            const nodes = [
                { id: 'nodeA', cx: 100, cy: 100, color: 'blue' },
                { id: 'nodeB', cx: 400, cy: 100, color: 'blue' },
                { id: 'nodeC', cx: 100, cy: 400, color: 'red' },
                { id: 'nodeD', cx: 400, cy: 400, color: 'red' },
                { id: 'nodeE', cx: 250, cy: 250, color: 'green' }
            ];
            const correctPathIds = sourceLevel.correctPath; 
            const correctPathNames = correctPathIds.map(id => nodes.find(n => n.id === id)?.id || id);
            return `Connecter: ${correctPathNames.join(' -> ')}`;
        case 'scenario':
            return sourceLevel.actions[sourceLevel.correct];
        case 'conflict_detection': // New bonus type
            return sourceLevel.options[sourceLevel.correct];
        case 'volume_calc': // New bonus type
            return sourceLevel.answer;
        default:
            return "N/A";
    }
}

function endGame() {
    stopTimer();
    stopTipsMarquee(); // Stop tips marquee
    clearInterval(gameState.characterTipInterval); // Stop character tip interval

    // Hide game elements
    const gameHeader = document.querySelector('.game-header');
    const controls = document.querySelector('.controls');
    const progressBar = document.querySelector('.progress-bar-chronological');
    const tipsBar = document.querySelector('.tips-bar');
    const gameCharacter = document.getElementById('gameCharacter');
    const speechBubble = document.getElementById('speechBubble');

    if (gameHeader) gameHeader.style.display = 'none';
    if (controls) controls.style.display = 'none';
    if (progressBar) progressBar.style.display = 'none'; // Hide progress bar
    if (tipsBar) tipsBar.style.display = 'none'; // Hide tips bar
    if (gameCharacter) gameCharacter.style.display = 'none'; // Hide character
    if (speechBubble) speechBubble.style.display = 'none'; // Hide speech bubble

    showScreen('finalScreen');
    const finalScreen = document.getElementById('finalScreen');
    if (finalScreen) { // Added null check
        finalScreen.innerHTML = `
            <div class="logo-icon" style="font-size: 5rem; width: 100px; height: 100px; margin-bottom: 30px;">🏆</div>
            <h1>Aventure Terminée !</h1>
            <h2 style="font-size: 1.8rem; color: #333; margin-bottom: 40px;">Félicitations, Projeteur VRD !</h2>
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-number">${gameState.score}</div>
                    <div class="stat-label">Points Totaux</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${gameState.currentLevel} / ${originalLevels.length}</div>
                    <div class="stat-label">Niveaux Complétés</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${(gameState.score / (gameState.currentLevel * 100) * 100).toFixed(0) || 0}%</div>
                    <div class="stat-label">Précision Moyenne</div>
                </div>
            </div>
            <button class="btn" onclick="startGame()">Rejouer</button>
            <button class="btn btn-secondary mt-4" onclick="showCorrectionReport()">Voir la correction</button>
        `;
    }
    triggerConfetti();
    playSound('gameOver');
    displayCharacter('�', "Bravo pour cette belle performance ! Revenez vite pour de nouveaux défis.", 5000); // End game message
}

function generateCorrectionReport() {
    let reportHtml = '<h3>Performance par Compétence :</h3><ul>';
    for (const skill in gameState.skillScores) {
        const { correct, total } = gameState.skillScores[skill];
        const percentage = total > 0 ? ((correct / total) * 100).toFixed(0) : 0;
        reportHtml += `<li><strong>${skill.charAt(0).toUpperCase() + skill.slice(1)}</strong>: ${correct} / ${total} (${percentage}%)</li>`;
    }
    reportHtml += '</ul><br/><h3>Détail des Réponses :</h3><ol>';

    gameState.answers.forEach((answer, index) => {
        const status = answer.isCorrect ? '✅ Correct' : '❌ Incorrect';
        const points = answer.pointsEarned >= 0 ? `(+${answer.pointsEarned} pts)` : `(${answer.pointsEarned} pts)`;
        reportHtml += `
            <li>
                <strong>Niveau ${answer.levelIndex + 1} (${answer.type})</strong>: ${answer.question}<br/>
                Votre réponse: <em>${answer.userAnswer}</em><br/>
                Réponse correcte: <em>${answer.correctAnswer}</em><br/>
                Statut: ${status} ${points}
            </li><br/>
        `;
    });
    reportHtml += '</ol>';
    return reportHtml;
}

function showCorrectionReport() {
    const reportContent = document.getElementById('correctionReportContent');
    if (reportContent) { // Added null check
        reportContent.innerHTML = generateCorrectionReport();
    }
    showModal('correctionModal');
}

function copyCorrectionToClipboard() {
    const reportContent = document.getElementById('correctionReportContent');
    let reportText = '';
    if (reportContent) { // Added null check
        reportText = reportContent.innerText;
    }
    
    const textArea = document.createElement("textarea");
    textArea.value = reportText;
    document.body.appendChild(textArea);
    textArea.select();
    try {
        // Use document.execCommand('copy') for better compatibility in iframes
        const successful = document.execCommand('copy');
        const msg = successful ? 'Copié dans le presse-papiers !' : 'Échec de la copie.';
        // Replace alert with a custom message box if desired
        const currentAlert = document.getElementById('customAlert');
        if (currentAlert) currentAlert.remove(); // Remove previous alert

        const customAlert = document.createElement('div');
        customAlert.id = 'customAlert';
        customAlert.style.cssText = `
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: #333; color: white; padding: 15px 30px; border-radius: 10px;
            z-index: 1001; opacity: 0; transition: opacity 0.3s ease-in-out;
            font-size: 1.1rem; text-align: center;
        `;
        customAlert.textContent = msg;
        document.body.appendChild(customAlert);

        setTimeout(() => {
            customAlert.style.opacity = '1';
        }, 10); // Small delay to trigger transition

        setTimeout(() => {
            customAlert.style.opacity = '0';
            customAlert.addEventListener('transitionend', () => customAlert.remove());
        }, 2000); // Message disappears after 2 seconds

    } catch (err) {
        // Fallback for older browsers or if execCommand fails
        alert('Impossible de copier : ' + err);
    }
    document.body.removeChild(textArea);
}

// Render specific levels

// Quiz Level
function renderQuizLevel(level) {
    const quizScreen = document.getElementById('quizScreen');
    if (!quizScreen) return; // Added null check

    // Create a mutable copy of answers with their correct status
    const answersWithStatus = level.answers.map((answer, index) => ({
        text: answer,
        isCorrect: index === level.correct
    }));
    shuffleArray(answersWithStatus); // Shuffle the answers

    quizScreen.innerHTML = `
        <h2 id="questionText">${level.question}</h2>
        <div class="answer-grid">
            ${answersWithStatus.map((answer, index) => `
                <button class="answer-btn" data-original-font-size="20" 
                        data-is-correct="${answer.isCorrect}"
                        onclick="checkQuizAnswer(${index}, ${answer.isCorrect}, ${level.points}, '${answer.text.replace(/'/g, "\\'")}', '${level.type}')">
                    ${answer.text}
                </button>
            `).join('')}
        </div>
    `;
}

// Modified checkQuizAnswer to use isCorrect flag and user's answer text
function checkQuizAnswer(selectedIndex, isCorrectFlag, points, userAnswerText, levelType) {
    stopTimer();
    const buttons = document.querySelectorAll('.answer-btn');
    buttons.forEach((btn, index) => {
        btn.disabled = true;
        // The correct button is the one with the isCorrectFlag true
        if (btn.getAttribute('onclick') && btn.getAttribute('onclick').includes('true')) { // Added null check for getAttribute
            btn.classList.add('correct');
        } else if (index === selectedIndex) {
            btn.classList.add('incorrect');
        }
    });

    const level = gameState.isBonusRound ? gameState.bonusLevelData : gameState.shuffledLevels[gameState.currentLevel];
    let pointsEarned = 0;
    let basePoints = points;

    if (isCorrectFlag) {
        pointsEarned = basePoints;
        if (!gameState.isBonusRound) { // Only apply bonus multiplier for regular questions
            pointsEarned *= gameState.bonusMultiplier; 
        }
        gameState.score += pointsEarned;
        playSound('correct');
        if (gameState.bonusMultiplier > 1 && !gameState.isBonusRound) {
             displayCharacter('🎉', "BONUS ACTIVÉ ! Points doublés !", 2000);
        } else {
            displayCharacter('😊', "Super ! Bonne réponse !", 2000); // Correct message
        }
    } else {
        pointsEarned = -Math.floor(basePoints / 5); // Small penalty for incorrect
        gameState.score = Math.max(0, gameState.score + pointsEarned);
        playSound('incorrect');
        displayCharacter('😟', "Dommage, ce n'est pas ça. Mais continuez d'apprendre !", 2000); // Incorrect message
    }
    
    // Record answer
    gameState.answers.push({
        levelIndex: gameState.currentLevel,
        type: level.type, // Use level.type directly
        question: level.question,
        userAnswer: userAnswerText, // Use the actual text the user clicked
        correctAnswer: getCorrectAnswerForLevel(level), // Get original correct answer
        isCorrect: isCorrectFlag,
        pointsEarned: pointsEarned
    });
    // Update skill score
    gameState.skillScores[level.type].total++;
    if (isCorrectFlag) {
        gameState.skillScores[level.type].correct++;
    }
    
    // Reset bonus multiplier after it's used for a regular question
    if (!gameState.isBonusRound) {
        gameState.bonusMultiplier = 1;
    }

    updateHeader();
    setTimeout(nextLevel, 1500);
}

// Material Level
function renderMaterialLevel(level) {
    const quizScreen = document.getElementById('quizScreen');
    if (!quizScreen) return; // Added null check

    // Create a mutable copy of materials with their correct status and icons
    const materialsWithStatus = level.materials.map((material, index) => ({
        text: material,
        icon: level.icons[index],
        isCorrect: index === level.correct
    }));
    shuffleArray(materialsWithStatus); // Shuffle the materials

    quizScreen.innerHTML = `
        <h2 id="questionText">${level.question}</h2>
        <div class="material-grid">
            ${materialsWithStatus.map((material, index) => `
                <div class="material-card" 
                     data-is-correct="${material.isCorrect}"
                     onclick="checkMaterialAnswer(${index}, ${material.isCorrect}, ${level.points}, '${material.text.replace(/'/g, "\\'")}', '${level.type}')">
                    <span class="material-icon">${material.icon}</span>
                    <span class="material-text">${material.text}</span>
                </div>
            `).join('')}
        </div>
    `;
}

// Modified checkMaterialAnswer to use isCorrect flag and user's answer text
function checkMaterialAnswer(selectedIndex, isCorrectFlag, points, userAnswerText, levelType) {
    stopTimer();
    const cards = document.querySelectorAll('.material-card');
    cards.forEach((card, index) => {
        card.style.pointerEvents = 'none'; // Disable further clicks
        // Find the correct card based on the isCorrectFlag in its onclick attribute
        if (card.getAttribute('onclick') && card.getAttribute('onclick').includes('true')) { // Added null check for getAttribute
            card.classList.add('correct');
        } else if (index === selectedIndex) {
            card.classList.add('incorrect');
        }
    });

    const level = gameState.isBonusRound ? gameState.bonusLevelData : gameState.shuffledLevels[gameState.currentLevel];
    let pointsEarned = 0;
    let basePoints = points;

    if (isCorrectFlag) {
        pointsEarned = basePoints;
        if (!gameState.isBonusRound) { // Only apply bonus multiplier for regular questions
            pointsEarned *= gameState.bonusMultiplier; 
        }
        gameState.score += pointsEarned;
        playSound('correct');
        if (gameState.bonusMultiplier > 1 && !gameState.isBonusRound) {
             displayCharacter('🎉', "BONUS ACTIVÉ ! Points doublés !", 2000);
        } else {
            displayCharacter('😊', "Exact ! Vous avez l'œil pour les matériaux !", 2000); // Correct message
        }
    } else {
        pointsEarned = -Math.floor(basePoints / 5);
        gameState.score = Math.max(0, gameState.score + pointsEarned);
        playSound('incorrect');
        displayCharacter('😟', "Ce n'est pas le bon choix. Réfléchissez bien aux propriétés !", 2000); // Incorrect message
    }

    // Record answer
    gameState.answers.push({
        levelIndex: gameState.currentLevel,
        type: level.type,
        question: level.question,
        userAnswer: userAnswerText,
        correctAnswer: getCorrectAnswerForLevel(level),
        isCorrect: isCorrectFlag,
        pointsEarned: pointsEarned
    });
    // Update skill score
    gameState.skillScores[level.type].total++;
    if (isCorrectFlag) {
        gameState.skillScores[level.type].correct++;
    }

    // Reset bonus multiplier after it's used for a regular question
    if (!gameState.isBonusRound) {
        gameState.bonusMultiplier = 1;
    }

    updateHeader();
    setTimeout(nextLevel, 1500);
}

// Drag and Drop Level
function renderDragLevel(level) {
    const gameScreen = document.getElementById('gameScreen');
    if (!gameScreen) return; // Added null check

    const shuffledItems = [...level.items].sort(() => Math.random() - 0.5); // Shuffle for challenge
    const dropZones = level.items.map((item, index) => `<div class="drop-zone" data-index="${index}"><span class="drop-zone-text">Déposez ici</span></div>`).join('');

    gameScreen.innerHTML = `
        <h2 id="questionText">${level.question}</h2>
        <div style="display: flex; flex-wrap: wrap; justify-content: center; margin-bottom: 30px;">
            ${shuffledItems.map((item, index) => `<div class="draggable" draggable="true" data-item="${item}"><span class="draggable-text">${item}</span></div>`).join('')}
        </div>
        <div style="width: 100%; max-width: 600px;">
            ${dropZones}
        </div>
        <div class="button-center-align"> <!-- Changed to button-center-align -->
            <button class="btn" onclick="checkDragAnswer('${level.items.join(',')}', ${level.points}, '${level.type}')">Valider l'assemblage</button>
        </div>
    `;

    addDragAndDropListeners();
}

function addDragAndDropListeners() {
    const draggables = document.querySelectorAll('.draggable');
    const dropZones = document.querySelectorAll('.drop-zone');
    let draggedItem = null;

    draggables.forEach(draggable => {
        draggable.addEventListener('dragstart', (e) => {
            draggedItem = draggable;
            e.dataTransfer.setData('text/plain', draggable.dataset.item);
            setTimeout(() => draggable.classList.add('hidden'), 0); // Hide original
        });

        draggable.addEventListener('dragend', () => {
            if (draggedItem) { // Added null check
                draggedItem.classList.remove('hidden');
            }
            draggedItem = null;
        });
    });

    dropZones.forEach(zone => {
        zone.addEventListener('dragover', (e) => {
            e.preventDefault(); // Allow drop
            zone.classList.add('hover');
        });

        zone.addEventListener('dragleave', () => {
            zone.classList.remove('hover');
        });

        zone.addEventListener('drop', (e) => {
            e.preventDefault();
            zone.classList.remove('hover');
            if (zone.children.length === 0 || (zone.children.length === 1 && zone.children[0].classList.contains('drop-zone-text'))) { // Only allow one item per zone, or replace placeholder text
                const data = e.dataTransfer.getData('text/plain');
                const item = document.querySelector(`.draggable[data-item="${data}"]`);
                if (item) {
                    // Remove placeholder text if it exists
                    const placeholder = zone.querySelector('.drop-zone-text');
                    if (placeholder) placeholder.remove();

                    zone.appendChild(item);
                    item.style.position = 'static'; // Reset position if it was absolute
                    item.style.margin = '0'; // Reset margin
                    zone.classList.add('filled');
                }
            }
        });
    });
}

function checkDragAnswer(correctOrderString, points, levelType) {
    stopTimer();
    const correctOrder = correctOrderString.split(',');
    const dropZones = document.querySelectorAll('.drop-zone');
    let correctCount = 0;
    let allCorrect = true;
    let userAnswerArray = [];

    dropZones.forEach((zone, index) => {
        const droppedItem = zone.querySelector('.draggable');
        if (droppedItem) {
            userAnswerArray.push(droppedItem.dataset.item);
            if (droppedItem.dataset.item === correctOrder[index]) {
                droppedItem.classList.add('correct');
                zone.style.borderColor = '#4caf50';
                correctCount++;
            } else {
                droppedItem.classList.add('incorrect');
                zone.style.borderColor = '#f44336';
                allCorrect = false;
            }
        } else {
            userAnswerArray.push("Vide"); // Indicate an empty drop zone
            zone.style.borderColor = '#f44336';
            allCorrect = false;
        }
        zone.style.borderStyle = 'solid'; // Make border solid for feedback
    });

    const level = gameState.isBonusRound ? gameState.bonusLevelData : gameState.shuffledLevels[gameState.currentLevel];
    let pointsEarned = 0;
    let basePoints = points;

    if (allCorrect) {
        pointsEarned = basePoints;
        if (!gameState.isBonusRound) { // Only apply bonus multiplier for regular questions
            pointsEarned *= gameState.bonusMultiplier; 
        }
        gameState.score += pointsEarned;
        playSound('correct');
        if (gameState.bonusMultiplier > 1 && !gameState.isBonusRound) {
             displayCharacter('🎉', "BONUS ACTIVÉ ! Points doublés !", 2000);
        } else {
            displayCharacter('😊', "Parfait ! L'assemblage est correct !", 2000); // Correct message
        }
    } else {
        pointsEarned = -Math.floor(basePoints / 2); // Larger penalty for drag/drop
        gameState.score = Math.max(0, gameState.score + pointsEarned);
        playSound('incorrect');
        displayCharacter('😟', "Revoyez l'ordre des couches, c'est important !", 2000); // Incorrect message
    }

    // Record answer
    gameState.answers.push({
        levelIndex: gameState.currentLevel,
        type: level.type,
        question: level.question,
        userAnswer: userAnswerArray.join(' > '),
        correctAnswer: correctOrder.join(' > '),
        isCorrect: allCorrect,
        pointsEarned: pointsEarned
    });
    // Update skill score
    gameState.skillScores[level.type].total++;
    if (allCorrect) {
        gameState.skillScores[level.type].correct++;
    }

    // Reset bonus multiplier after it's used for a regular question
    if (!gameState.isBonusRound) {
        gameState.bonusMultiplier = 1;
    }

    updateHeader();
    document.querySelectorAll('.draggable').forEach(item => item.draggable = false); // Disable further dragging
    const gameScreenBtn = document.getElementById('gameScreen').querySelector('.btn');
    if (gameScreenBtn) { // Added null check
        gameScreenBtn.disabled = true;
    }
    setTimeout(nextLevel, 2000);
}

// Calculation Level
function renderCalcLevel(level) {
    const quizScreen = document.getElementById('quizScreen');
    if (!quizScreen) return; // Added null check

    quizScreen.innerHTML = `
        <h2 id="questionText">${level.question}</h2>
        <input type="number" id="elevationInput" class="elevation-input" placeholder="Entrez votre réponse" step="0.01">
        <div class="button-center-align"> <!-- Changed to button-center-align -->
            <button class="btn" id="validateCalcBtn" onclick="checkCalcAnswer(${level.answer}, ${level.points}, '${level.type}')">Valider</button>
        </div>
    `;
}

function checkCalcAnswer(correctAnswer, points, levelType) {
    stopTimer();
    const input = document.getElementById('elevationInput');
    const validateBtn = document.getElementById('validateCalcBtn');

    let userAnswer = null;
    if (input) { // Added null check
        userAnswer = parseFloat(input.value);
        input.disabled = true;
    }
    if (validateBtn) { // Added null check
        validateBtn.disabled = true;
    }

    const tolerance = 0.01; // Allow for small floating point errors

    const level = gameState.isBonusRound ? gameState.bonusLevelData : gameState.shuffledLevels[gameState.currentLevel];
    let isCorrect = false;
    let pointsEarned = 0;
    let basePoints = points;

    if (userAnswer !== null && Math.abs(userAnswer - correctAnswer) < tolerance) { // Added null check for userAnswer
        isCorrect = true;
        pointsEarned = basePoints;
        if (!gameState.isBonusRound) { // Only apply bonus multiplier for regular questions
            pointsEarned *= gameState.bonusMultiplier; 
        }
        gameState.score += pointsEarned;
        playSound('correct');
        if (gameState.bonusMultiplier > 1 && !gameState.isBonusRound) {
             displayCharacter('🎉', "BONUS ACTIVÉ ! Points doublés !", 2000);
        } else {
            displayCharacter('😊', "Calcul parfait ! Vous maîtrisez les altitudes !", 2000); // Correct message
        }
    } else {
        pointsEarned = -Math.floor(basePoints / 3);
        if (input) { // Added null check
            input.style.borderColor = '#f44336';
            input.style.boxShadow = '0 0 0 3px rgba(244, 67, 54, 0.2)';
        }
        gameState.score = Math.max(0, gameState.score + pointsEarned);
        playSound('incorrect');
        displayCharacter('😟', "Vérifiez vos calculs, la précision est clé en VRD !", 2000); // Incorrect message
    }

    // Record answer
    gameState.answers.push({
        levelIndex: gameState.currentLevel,
        type: level.type,
        question: level.question,
        userAnswer: input ? input.value : "N/A", // Added null check
        correctAnswer: correctAnswer.toFixed(2), // Format correct answer for display
        isCorrect: isCorrect,
        pointsEarned: pointsEarned
    });
    // Update skill score
    gameState.skillScores[level.type].total++;
    if (isCorrect) {
        gameState.skillScores[level.type].correct++;
    }

    // Reset bonus multiplier after it's used for a regular question
    if (!gameState.isBonusRound) {
        gameState.bonusMultiplier = 1;
    }

    updateHeader();
    setTimeout(nextLevel, 1500);
}

// Network Level
function renderNetworkLevel(level) {
    const gameScreen = document.getElementById('gameScreen');
    if (!gameScreen) return; // Added null check

    // Example network nodes and paths (simplified for demonstration)
    const nodes = [
        { id: 'nodeA', cx: 100, cy: 100, color: 'blue' },
        { id: 'nodeB', cx: 400, cy: 100, color: 'blue' },
        { id: 'nodeC', cx: 100, cy: 400, color: 'red' },
        { id: 'nodeD', cx: 400, cy: 400, color: 'red' },
        { id: 'nodeE', cx: 250, cy: 250, color: 'green' } // An 'obstacle' node
    ];
    // Use the correctPath from the level data
    const correctPathForRender = level.correctPath || []; // Fallback if not defined

    gameScreen.innerHTML = `
        <h2 id="questionText">${level.question}</h2>
        <svg class="network-svg" viewBox="0 0 500 500">
            <defs>
                <marker id="arrow" markerWidth="10" markerHeight="10" refX="8" refY="3" orient="auto" markerUnits="strokeWidth">
                    <path d="M0,0 L0,6 L9,3 z" fill="#667eea" />
                </marker>
            </defs>
            ${nodes.map(node => `
                <circle class="network-node" id="${node.id}" cx="${node.cx}" cy="${node.cy}" r="15" fill="${node.color}" stroke="white" stroke-width="3" />
            `).join('')}
            <g id="drawnLines"></g>
        </svg>
        <div class="button-center-align"> <!-- Changed to button-center-align -->
            <button class="btn" onclick="checkNetworkAnswer(${level.points}, '${correctPathForRender.join(',')}', '${JSON.stringify(nodes).replace(/'/g, "\\'").replace(/"/g, '&quot;')}', '${level.type}')">Valider le réseau</button>
        </div>
    `;

    addNetworkListeners(nodes);
}

let networkSelectedNodes = [];
let networkDrawing = false;
let networkSvg = null;
let currentLine = null;

function addNetworkListeners(nodes) {
    networkSvg = document.querySelector('.network-svg');
    const drawnLinesGroup = document.getElementById('drawnLines');

    if (!networkSvg || !drawnLinesGroup) return; // Added null checks

    networkSvg.addEventListener('mousedown', (e) => {
        const target = e.target;
        if (target.classList.contains('network-node')) {
            networkDrawing = true;
            networkSelectedNodes = [target.id];
            
            // Start drawing a temporary line
            currentLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
            const startNode = nodes.find(n => n.id === target.id);
            if (startNode) { // Added null check
                currentLine.setAttribute('x1', startNode.cx);
                currentLine.setAttribute('y1', startNode.cy);
            }
            currentLine.setAttribute('x2', e.offsetX);
            currentLine.setAttribute('y2', e.offsetY);
            currentLine.setAttribute('stroke', '#667eea');
            currentLine.setAttribute('stroke-width', '4');
            currentLine.setAttribute('stroke-dasharray', '5,5');
            drawnLinesGroup.appendChild(currentLine);
        }
    });

    networkSvg.addEventListener('mousemove', (e) => {
        if (networkDrawing && currentLine) {
            currentLine.setAttribute('x2', e.offsetX);
            currentLine.setAttribute('y2', e.offsetY);
        }
    });

    networkSvg.addEventListener('mouseup', (e) => {
        if (networkDrawing) {
            networkDrawing = false;
            const target = e.target;
            if (target.classList.contains('network-node') && networkSelectedNodes[0] !== target.id) {
                networkSelectedNodes.push(target.id);
                const startNode = nodes.find(n => n.id === networkSelectedNodes[0]);
                const endNode = nodes.find(n => n.id === networkSelectedNodes[1]);

                // Finalize the line
                if (currentLine && endNode) { // Added null check for currentLine and endNode
                    currentLine.setAttribute('x2', endNode.cx);
                    currentLine.setAttribute('y2', endNode.cy);
                    currentLine.setAttribute('marker-end', 'url(#arrow)'); // Add arrow to the end
                }

                // Reset for next line
                networkSelectedNodes = [];
                currentLine = null;
            } else {
                // If not dropped on another node, remove the temporary line
                if (currentLine) {
                    currentLine.remove();
                }
            }
        }
    });
}


function checkNetworkAnswer(points, correctPathString, nodesJsonString, levelType) {
    stopTimer();
    const correctPath = correctPathString.split(',');
    const drawnLines = document.querySelectorAll('#drawnLines line');
    const nodes = JSON.parse(nodesJsonString.replace(/&quot;/g, '"')); // Parse nodes back from JSON string

    let allCorrect = true;
    let userAnswerPath = [];

    if (drawnLines.length === 1) {
        const line = drawnLines[0];
        const x1 = parseFloat(line.getAttribute('x1'));
        const y1 = parseFloat(line.getAttribute('y1'));
        const x2 = parseFloat(line.getAttribute('x2'));
        const y2 = parseFloat(line.getAttribute('y2'));
        
        let lineStartNodeId = null;
        let lineEndNodeId = null;

        nodes.forEach(node => {
            const nodeCx = node.cx;
            const nodeCy = node.cy;
            const nodeR = 15; // Hardcoded radius from renderNetworkLevel

            // Calculate distance from line endpoints to node center
            const distStartToNode = Math.sqrt(Math.pow(x1 - nodeCx, 2) + Math.pow(y1 - nodeCy, 2));
            const distEndToNode = Math.sqrt(Math.pow(x2 - nodeCx, 2) + Math.pow(y2 - nodeCy, 2));

            if (distStartToNode <= nodeR + 5) { // Add a small tolerance
                lineStartNodeId = node.id;
            }
            if (distEndToNode <= nodeR + 5) { // Add a small tolerance
                lineEndNodeId = node.id;
            }
        });

        if (lineStartNodeId && lineEndNodeId) {
            userAnswerPath.push(lineStartNodeId, lineEndNodeId);
            // Check if the connected nodes match the correct path (order doesn't matter for this simple check)
            const sortedUserPath = [...userAnswerPath].sort().join(',');
            const sortedCorrectPath = [...correctPath].sort().join(',');

            if (sortedUserPath === sortedCorrectPath) {
                allCorrect = true;
            } else {
                allCorrect = false;
            }
        } else {
            allCorrect = false; // Line endpoints not connected to valid nodes
        }
    } else {
        allCorrect = false; // Not exactly one line drawn
    }

    const level = gameState.isBonusRound ? gameState.bonusLevelData : gameState.shuffledLevels[gameState.currentLevel];
    let pointsEarned = 0;
    let basePoints = points;

    if (allCorrect) {
        pointsEarned = basePoints;
        if (!gameState.isBonusRound) { // Only apply bonus multiplier for regular questions
            pointsEarned *= gameState.bonusMultiplier; 
        }
        gameState.score += pointsEarned;
        playSound('correct');
        if (gameState.bonusMultiplier > 1 && !gameState.isBonusRound) {
             displayCharacter('🎉', "BONUS ACTIVÉ ! Points doublés !", 2000);
        } else {
            displayCharacter('😊', "Excellent ! Le réseau est bien tracé !", 2000); // Correct message
        }
        drawnLines.forEach(line => line.setAttribute('stroke', '#4caf50'));
    } else {
        pointsEarned = -Math.floor(basePoints / 2);
        gameState.score = Math.max(0, gameState.score + pointsEarned);
        playSound('incorrect');
        displayCharacter('😟', "Le tracé n'est pas optimal. Essayez à nouveau !", 2000); // Incorrect message
        drawnLines.forEach(line => line.setAttribute('stroke', '#f44336'));
    }

    // Record answer
    gameState.answers.push({
        levelIndex: gameState.currentLevel,
        type: level.type,
        question: level.question,
        userAnswer: userAnswerPath.length > 0 ? userAnswerPath.join(' -> ') : "Aucun tracé",
        correctAnswer: getCorrectAnswerForLevel(level),
        isCorrect: allCorrect,
        pointsEarned: pointsEarned
    });
    // Update skill score
    gameState.skillScores[level.type].total++;
    if (allCorrect) {
        gameState.skillScores[level.type].correct++;
    }

    // Reset bonus multiplier after it's used for a regular question
    if (!gameState.isBonusRound) {
        gameState.bonusMultiplier = 1;
    }

    updateHeader();
    const gameScreenBtn = document.getElementById('gameScreen').querySelector('.btn');
    if (gameScreenBtn) { // Added null check
        gameScreenBtn.disabled = true;
    }
    setTimeout(nextLevel, 2000);
}


// Scenario Level
function renderScenarioLevel(level) {
    const quizScreen = document.getElementById('quizScreen');
    if (!quizScreen) return; // Added null check

    // Create a mutable copy of actions with their correct status
    const actionsWithStatus = level.actions.map((action, index) => ({
        text: action,
        isCorrect: index === level.correct
    }));
    shuffleArray(actionsWithStatus); // Shuffle the actions

    quizScreen.innerHTML = `
        <div class="scenario-alert">
            <div class="scenario-icon">🚨</div>
            <h2 id="questionText">${level.question}</h2>
        </div>
        <div class="answer-grid">
            ${actionsWithStatus.map((action, index) => `
                <button class="answer-btn" data-original-font-size="20" 
                        data-is-correct="${action.isCorrect}"
                        onclick="checkScenarioAnswer(${index}, ${action.isCorrect}, ${level.points}, '${action.text.replace(/'/g, "\\'")}', '${level.type}')">
                    ${action.text}
                </button>
            `).join('')}
        </div>
    `;
}

// Modified checkScenarioAnswer to use isCorrect flag and user's answer text
function checkScenarioAnswer(selectedIndex, isCorrectFlag, points, userAnswerText, levelType) {
    stopTimer();
    const buttons = document.querySelectorAll('.answer-btn');
    buttons.forEach((btn, index) => {
        btn.disabled = true;
        // The correct button is the one with the isCorrectFlag true
        if (btn.getAttribute('onclick') && btn.getAttribute('onclick').includes('true')) { // Added null check for getAttribute
            btn.classList.add('correct');
        } else if (index === selectedIndex) {
            btn.classList.add('incorrect');
        }
    });

    const level = gameState.isBonusRound ? gameState.bonusLevelData : gameState.shuffledLevels[gameState.currentLevel];
    let pointsEarned = 0;
    let basePoints = points;

    if (isCorrectFlag) {
        pointsEarned = basePoints;
        if (!gameState.isBonusRound) { // Only apply bonus multiplier for regular questions
            pointsEarned *= gameState.bonusMultiplier; 
        }
        gameState.score += pointsEarned;
        playSound('correct');
        if (gameState.bonusMultiplier > 1 && !gameState.isBonusRound) {
             displayCharacter('🎉', "BONUS ACTIVÉ ! Points doublés !", 2000);
        } else {
            displayCharacter('😊', "Bonne décision ! La sécurité avant tout.", 2000); // Correct message
        }
    } else {
        pointsEarned = -Math.floor(basePoints / 4);
        gameState.score = Math.max(0, gameState.score + pointsEarned);
        playSound('incorrect');
        displayCharacter('😟', "Attention ! Une mauvaise décision peut avoir des conséquences !", 2000); // Incorrect message
    }

    // Record answer
    gameState.answers.push({
        levelIndex: gameState.currentLevel,
        type: level.type,
        question: level.question,
        userAnswer: userAnswerText,
        correctAnswer: getCorrectAnswerForLevel(level),
        isCorrect: isCorrectFlag,
        pointsEarned: pointsEarned
    });
    // Update skill score
    gameState.skillScores[level.type].total++;
    if (isCorrectFlag) {
        gameState.skillScores[level.type].correct++;
    }

    // Reset bonus multiplier after it's used for a regular question
    if (!gameState.isBonusRound) {
        gameState.bonusMultiplier = 1;
    }

    updateHeader();
    setTimeout(nextLevel, 1500);
}

// New Bonus Level Types

// Conflict Detection Level
function renderConflictDetectionLevel(level) {
    const quizScreen = document.getElementById('quizScreen');
    if (!quizScreen) return; // Added null check

    const optionsWithStatus = level.options.map((option, index) => ({
        text: option,
        isCorrect: index === level.correct
    }));
    shuffleArray(optionsWithStatus);

    quizScreen.innerHTML = `
        <div class="scenario-alert" style="background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);">
            <div class="scenario-icon">⚠️</div>
            <h2 id="questionText" style="color: #333;">${level.question}</h2>
        </div>
        <div class="answer-grid">
            ${optionsWithStatus.map((option, index) => `
                <button class="answer-btn" data-original-font-size="20" 
                        data-is-correct="${option.isCorrect}"
                        onclick="checkConflictDetectionAnswer(${index}, ${option.isCorrect}, ${level.points}, '${option.text.replace(/'/g, "\\'")}', '${level.type}')">
                    ${option.text}
                </button>
            `).join('')}
        </div>
    `;
}

function checkConflictDetectionAnswer(selectedIndex, isCorrectFlag, points, userAnswerText, levelType) {
    stopTimer();
    const buttons = document.querySelectorAll('.answer-btn');
    buttons.forEach((btn, index) => {
        btn.disabled = true;
        if (btn.getAttribute('onclick') && btn.getAttribute('onclick').includes('true')) { // Added null check for getAttribute
            btn.classList.add('correct');
        } else if (index === selectedIndex) {
            btn.classList.add('incorrect');
        }
    });

    const level = gameState.isBonusRound ? gameState.bonusLevelData : gameState.shuffledLevels[gameState.currentLevel];
    let pointsEarned = 0;
    let basePoints = points;

    if (isCorrectFlag) {
        pointsEarned = basePoints;
        // Bonus levels themselves don't get multiplied, they set the multiplier for the *next* regular question
        gameState.score += pointsEarned;
        playSound('correct');
        displayCharacter('✅', "Conflit bien identifié ! Excellente analyse !", 2000);
    } else {
        pointsEarned = -Math.floor(basePoints / 3);
        gameState.score = Math.max(0, gameState.score + pointsEarned);
        playSound('incorrect');
        displayCharacter('❌', "Attention aux détails ! Ce conflit est critique.", 2000);
    }

    gameState.answers.push({
        levelIndex: gameState.currentLevel,
        type: level.type,
        question: level.question,
        userAnswer: userAnswerText,
        correctAnswer: getCorrectAnswerForLevel(level),
        isCorrect: isCorrectFlag,
        pointsEarned: pointsEarned
    });
    gameState.skillScores[level.type].total++;
    if (isCorrectFlag) {
        gameState.skillScores[level.type].correct++;
    }

    // After a bonus round, the bonus multiplier is set for the *next* regular question.
    // We don't reset it here, it will be reset by the next regular loadLevel.

    updateHeader();
    setTimeout(nextLevel, 1500);
}

// Volume Calculation Level
function renderVolumeCalcLevel(level) {
    const quizScreen = document.getElementById('quizScreen');
    if (!quizScreen) return; // Added null check

    quizScreen.innerHTML = `
        <h2 id="questionText">${level.question}</h2>
        <input type="number" id="elevationInput" class="elevation-input" placeholder="Entrez votre réponse (m³)" step="0.01">
        <div class="button-center-align">
            <button class="btn" id="validateCalcBtn" onclick="checkVolumeCalcAnswer(${level.answer}, ${level.points}, '${level.type}')">Valider</button>
        </div>
    `;
}

function checkVolumeCalcAnswer(correctAnswer, points, levelType) {
    stopTimer();
    const input = document.getElementById('elevationInput');
    const validateBtn = document.getElementById('validateCalcBtn');

    let userAnswer = null;
    if (input) { // Added null check
        userAnswer = parseFloat(input.value);
        input.disabled = true;
    }
    if (validateBtn) { // Added null check
        validateBtn.disabled = true;
    }

    const tolerance = 0.01;

    const level = gameState.isBonusRound ? gameState.bonusLevelData : gameState.shuffledLevels[gameState.currentLevel];
    let isCorrect = false;
    let pointsEarned = 0;
    let basePoints = points;

    if (userAnswer !== null && Math.abs(userAnswer - correctAnswer) < tolerance) { // Added null check for userAnswer
        isCorrect = true;
        pointsEarned = basePoints;
        // Bonus levels themselves don't get multiplied, they set the multiplier for the *next* regular question
        gameState.score += pointsEarned;
        playSound('correct');
        displayCharacter('📈', "Calcul de volume précis ! Impressionnant !", 2000);
    } else {
        pointsEarned = -Math.floor(basePoints / 3);
        if (input) { // Added null check
            input.style.borderColor = '#f44336';
            input.style.boxShadow = '0 0 0 3px rgba(244, 67, 54, 0.2)';
        }
        gameState.score = Math.max(0, gameState.score + pointsEarned);
        playSound('incorrect');
        displayCharacter('📉', "Revoyez vos formules de volume. Chaque mètre cube compte !", 2000);
    }

    gameState.answers.push({
        levelIndex: gameState.currentLevel,
        type: level.type,
        question: level.question,
        userAnswer: input ? input.value : "N/A", // Added null check
        correctAnswer: correctAnswer.toFixed(2),
        isCorrect: isCorrect,
        pointsEarned: pointsEarned
    });
    gameState.skillScores[level.type].total++;
    if (isCorrect) {
        gameState.skillScores[level.type].correct++;
    }

    // After a bonus round, the bonus multiplier is set for the *next* regular question.
    // We don't reset it here, it will be reset by the next regular loadLevel.

    updateHeader();
    setTimeout(nextLevel, 1500);
}


// Font Size Adjustment Functions
function applyFontSize() {
    const root = document.documentElement;
    root.style.fontSize = `${gameState.baseFontSize}px`;

    // Elements that are always expected to be in the DOM or are handled by specific screen rendering
    // and might need scaling.
    const elementsToScale = [
        { selector: 'h1', baseRem: 3.5 }, // For general H1 (final screen)
        { selector: 'h2', baseRem: 2.5 }, // For general H2 (quiz, game, modals)
        { selector: 'p', baseRem: 1.1 }, // For general paragraphs
        { selector: '.answer-btn', baseRem: 1.2 },
        { selector: '.draggable', baseRem: 1.1 },
        { selector: '.drop-zone', baseRem: 1.1 },
        { selector: '.elevation-input', baseRem: 1.8 },
        { selector: '.material-text', baseRem: 1.0 },
        { selector: '.material-icon', baseRem: 4.0 },
        { selector: '#speechBubbleText', baseRem: 1.0 }, // Speech bubble text
        { selector: '.logo span', baseRem: 2.0 }, // Header logo text
        { selector: '.logo-icon', baseRem: 2.2 }, // Header logo icon and home screen logo icon
        { selector: '.header-item', baseRem: 1.7 }, // Header stats
        { selector: '.score-icon', baseRem: 2.0 },
        { selector: '.timer-icon', baseRem: 2.0 },
        { selector: '.progress-fill-chronological', baseRem: 0.8 },
        { selector: '.tips-bar-content', baseRem: 1.0 },
        { selector: '.control-btn', baseRem: 1.7 },
        { selector: '#homeScreen h1', baseRem: 4.5 }, // Home screen specific
        { selector: '#homeScreen p', baseRem: 1.6 }, // Home screen specific
        { selector: '#homeScreen .logo-icon', baseRem: 7.0 }, // Home screen specific
        { selector: '#homeScreen .btn', baseRem: 1.8 }, // Home screen specific
        { selector: '.home-features', baseRem: 1.1 }, // Home screen specific
        { selector: '#helpModal h2', baseRem: 1.8 },
        { selector: '#helpModal h3', baseRem: 1.4 },
        { selector: '#helpModal p', baseRem: 1.1 },
        { selector: '#confirmModal h2', baseRem: 1.8 },
        { selector: '#confirmModal p', baseRem: 1.2 },
        { selector: '#correctionModal h2', baseRem: 1.8 },
        { selector: '#correctionModal #correctionReportContent', baseRem: 1.1 },
        { selector: '.scenario-icon', baseRem: 4.0 },
        { selector: '.stat-number', baseRem: 3.2 },
        { selector: '.stat-label', baseRem: 1.1 },
        { selector: '#customAlert', baseRem: 1.1 }
    ];

    elementsToScale.forEach(item => {
        document.querySelectorAll(item.selector).forEach(el => {
            if (el) { // Check if the element exists before trying to set style
                el.style.fontSize = `${item.baseRem * (gameState.baseFontSize / 14)}rem`;
            }
        });
    });
}

function increaseFontSize() {
    if (gameState.baseFontSize < 20) { /* Adjusted max font size limit */
        gameState.baseFontSize += 2; // Increase by 2px
        localStorage.setItem('ltdSimFontSize', gameState.baseFontSize);
        applyFontSize();
        playSound('buttonClick');
    }
}

function decreaseFontSize() {
    if (gameState.baseFontSize > 10) { /* Adjusted min font size limit */
        gameState.baseFontSize -= 2; // Decrease by 2px
        localStorage.setItem('ltdSimFontSize', gameState.baseFontSize);
        applyFontSize();
        playSound('buttonClick');
    }
}

// Character and Speech Bubble Functions
function displayCharacter(emoji, message, duration = 3000) {
    const characterDiv = document.getElementById('gameCharacter');
    const speechBubble = document.getElementById('speechBubble');
    const speechBubbleText = document.getElementById('speechBubbleText');

    if (!characterDiv || !speechBubble || !speechBubbleText) return; // Ensure all elements exist

    // Stop any current tip interval
    clearInterval(gameState.characterTipInterval);

    characterDiv.textContent = emoji;
    characterDiv.style.display = 'block';
    speechBubbleText.textContent = message;
    speechBubble.classList.add('active');
    speechBubble.style.display = 'block';
    applyFontSize(); // Re-apply font size to speech bubble text

    // Set a timeout to hide the bubble and potentially restart tips
    setTimeout(() => {
        if (speechBubble) { // Added null check
            speechBubble.classList.remove('active');
        }
        // speechBubble.style.display = 'none'; // Keep hidden until next message
        // characterDiv.style.display = 'none'; // Keep character visible
        // Restart tips after a short delay if game is active
        if (document.getElementById('quizScreen').classList.contains('active') || document.getElementById('gameScreen').classList.contains('active')) {
            startCharacterTips();
        }
    }, duration);
}

function startCharacterTips() {
    // Clear any existing interval to prevent duplicates
    clearInterval(gameState.characterTipInterval); 
    gameState.characterTipInterval = setInterval(() => {
        const tip = gameTips[currentTipIndex];
        displayCharacter('🤔', tip, 5000); // Display tip for 5 seconds
        currentTipIndex = (currentTipIndex + 1) % gameTips.length;
    }, 10000); // Change tip every 10 seconds
}

// Tips Marquee Functions (kept for the bottom bar, though character will also give tips)
function startTipsMarquee() {
    const tipsBarContent = document.getElementById('tipsBarContent');
    if (!tipsBarContent) return; // Ensure element exists

    // Clear any existing animation to reset
    tipsBarContent.style.animation = 'none';
    tipsBarContent.offsetHeight; // Trigger reflow
    tipsBarContent.style.animation = null;

    tipsBarContent.textContent = gameTips[currentTipIndex];
    currentTipIndex = (currentTipIndex + 1) % gameTips.length;

    // Calculate animation duration based on content length to make speed consistent
    const textLength = tipsBarContent.textContent.length;
    const duration = Math.max(10, textLength * 0.15); // Min 10s, 0.15s per character
    tipsBarContent.style.animationDuration = `${duration}s`;

    // Restart animation on completion to cycle tips
    tipsBarContent.onanimationiteration = () => {
        tipsBarContent.textContent = gameTips[currentTipIndex];
        currentTipIndex = (currentTipIndex + 1) % gameTips.length;
        // Re-calculate duration for the new text
        const newTextLength = tipsBarContent.textContent.length;
        const newDuration = Math.max(10, newTextLength * 0.15);
        tipsBarContent.style.animationDuration = `${newDuration}s`;
    };
}

function stopTipsMarquee() {
    const tipsBarContent = document.getElementById('tipsBarContent');
    if (tipsBarContent) {
        tipsBarContent.style.animationPlayState = 'paused';
        tipsBarContent.onanimationiteration = null; // Remove event listener
    }
}

// Confetti effect (from previous versions)
function triggerConfetti() {
    const confettiCount = 100;
    for (let i = 0; i < confettiCount; i++) {
        const confetti = document.createElement('div');
        confetti.classList.add('confetti');
        confetti.style.left = Math.random() * 100 + 'vw';
        confetti.style.backgroundColor = `hsl(${Math.random() * 360}, 100%, 70%)`;
        confetti.style.animationDelay = `${Math.random() * 2}s`;
        document.body.appendChild(confetti);
        confetti.addEventListener('animationend', () => {
            confetti.remove();
        });
    }
}


// Initialisation
window.onload = function() {
    // Load saved font size
    const savedFontSize = localStorage.getItem('ltdSimFontSize');
    if (savedFontSize) {
        gameState.baseFontSize = parseInt(savedFontSize);
    }
    applyFontSize(); // Apply initial or saved font size
};

</script>
</body>
</html>
�
