<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LTD Simulateur - Projeteur VRD</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;800&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Poppins', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 10px;
            /* Default font size, will be updated by JS */
            font-size: 14px; /* Adjusted base font size */
        }
        
        .game-container {
            width: 100%;
            max-width: 1400px; /* Main container width */
            height: 95vh;
            background: rgba(255, 255, 255, 0.98);
            border-radius: 30px;
            box-shadow: 0 25px 80px rgba(0, 0, 0, 0.3);
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        .game-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 25px 50px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 5px 25px rgba(0, 0, 0, 0.15);
            position: absolute; /* Fixed position to stay at top */
            top: 0;
            left: 0;
            width: 100%;
            z-index: 10; /* Ensure it's above other content */
            height: 90px; /* Explicit height to help with screen padding */
        }
        
        .logo {
            display: flex;
            align-items: center;
            gap: 15px;
            font-size: 2rem; /* Adjusted from 28px */
            font-weight: 800;
        }
        
        .logo-icon {
            width: 50px;
            height: 50px;
            background: white;
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.2rem; /* Adjusted from 30px */
        }
        
        .header-stats {
            display: flex;
            gap: 30px;
            align-items: center; /* Align items vertically in the center */
        }
        
        .header-item {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 1.7rem; /* Adjusted from 24px */
            font-weight: 600;
            background: rgba(255, 255, 255, 0.2);
            padding: 10px 20px;
            border-radius: 50px;
            backdrop-filter: blur(10px);
        }
        
        .score-icon::before {
            content: "‚≠ê";
            font-size: 2rem; /* Adjusted from 28px */
        }
        
        .timer-icon::before {
            content: "‚è∞";
            font-size: 2rem; /* Adjusted from 28px */
        }
        
        .timer-display.warning {
            animation: pulse 1s infinite;
            background: rgba(244, 67, 54, 0.3);
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        .screen {
            display: none;
            flex: 1;
            /* Adjusted padding to account for header (90px), controls (~100px from right), and bottom bars */
            padding: 100px 120px 80px 50px; /* top, right, bottom, left */
            overflow-y: auto;
            animation: fadeIn 0.5s ease-out;
            /* Removed redundant margins as padding now handles spacing */
            /* margin-top: 80px; */
            /* margin-right: 100px; */
            /* margin-bottom: 60px; */
        }
        
        .screen.active {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        /* Bonus round specific styling */
        .screen.bonus-active {
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%); /* Gold/Orange gradient */
            box-shadow: 0 25px 80px rgba(255, 165, 0, 0.5); /* Orange shadow */
            color: #333; /* Darker text for contrast */
        }
        .screen.bonus-active h2 {
            color: #333; /* Ensure heading is readable */
        }
        .screen.bonus-active .answer-btn {
            background: #fefce8; /* Light yellow background for buttons */
            border-color: #fbbf24; /* Yellow border */
            color: #333;
        }
        .screen.bonus-active .answer-btn:hover {
            border-color: #f59e0b; /* Darker yellow on hover */
            background: #fde68a;
        }
        .screen.bonus-active .material-card {
            background: #fefce8;
            border-color: #fbbf24;
            color: #333;
        }
        .screen.bonus-active .material-card:hover {
            border-color: #f59e0b;
            background: #fde68a;
        }
        .screen.bonus-active .elevation-input {
            border-color: #fbbf24;
        }
        .screen.bonus-active .elevation-input:focus {
            box-shadow: 0 0 0 3px rgba(251, 191, 36, 0.4);
        }
        .screen.bonus-active .btn {
            background: linear-gradient(135deg, #f59e0b 0%, #ef4444 100%); /* Orange to red gradient for bonus buttons */
            box-shadow: 0 5px 25px rgba(245, 158, 11, 0.4);
        }
        .screen.bonus-active .btn:hover {
            box-shadow: 0 8px 35px rgba(245, 158, 11, 0.6);
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        h1 {
            font-size: 3.5rem; /* Adjusted from 5rem */
            font-weight: 800;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 30px;
            text-align: center;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }
        
        h2 {
            font-size: 2.5rem; /* Adjusted from 3.8rem */
            font-weight: 600;
            color: #333;
            margin-bottom: 40px;
            text-align: center;
            line-height: 1.3;
        }

        p {
            font-size: 1.1rem; /* Adjusted from 1.4rem */
        }
        
        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 18px 50px;
            border-radius: 50px;
            font-size: 1.4rem; /* Adjusted from 20px */
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 25px rgba(102, 126, 234, 0.4);
            position: relative;
            overflow: hidden;
        }
        
        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.2);
            transition: left 0.5s ease;
        }
        
        .btn:hover::before {
            left: 100%;
        }
        
        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 35px rgba(102, 126, 234, 0.6);
        }
        
        .btn:active {
            transform: translateY(-1px);
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .btn-secondary {
            background: #e0e0e0;
            color: #333;
            box-shadow: 0 5px 25px rgba(0, 0, 0, 0.1);
        }
        
        .progress-bar-chronological { /* New class for chronological progress bar */
            width: calc(100% - 100px); /* Adjust width to fit within header padding */
            height: 15px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            margin: 0 50px; /* Match header padding */
            overflow: hidden;
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.1);
            position: absolute;
            bottom: 45px; /* Position above the tips bar */
            left: 0;
            right: 0;
            z-index: 10; /* Ensure it's above other content */
            height: 30px; /* Explicit height to help with screen padding */
        }
        
        .progress-fill-chronological {
            height: 100%;
            background: white; /* White fill for contrast */
            border-radius: 10px;
            transition: width 0.5s ease;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding-right: 5px;
            font-size: 0.8rem; /* Adjusted from 12px */
            color: #667eea;
            font-weight: 600;
        }
        
        .answer-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); /* Adjusted minmax for smaller font */
            gap: 25px;
            width: 100%;
            max-width: 1000px;
            margin-top: 40px;
        }
        
        .answer-btn {
            background: white;
            border: 3px solid #e0e0e0;
            padding: 25px;
            border-radius: 20px;
            font-size: 1.2rem; /* Adjusted from 20px */
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            position: relative;
            overflow: hidden;
        }
        
        .answer-btn:hover {
            border-color: #667eea;
            transform: translateY(-5px);
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.15);
        }
        
        .answer-btn.correct {
            background: #4caf50;
            color: white;
            border-color: #4caf50;
            animation: bounce 0.5s ease;
        }
        
        .answer-btn.incorrect {
            background: #f44336;
            color: white;
            border-color: #f44336;
            animation: shake 0.5s ease;
        }
        
        @keyframes bounce {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-10px); }
            75% { transform: translateX(10px); }
        }
        
        .game-area {
            width: 100%;
            max-width: 1000px;
            height: 500px;
            background: #f8f9fa;
            border-radius: 25px;
            border: 3px solid #e0e0e0;
            position: relative;
            overflow: hidden;
            margin: 30px 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .controls {
            position: fixed;
            right: 30px; /* Position on the right */
            top: 50%; /* Center vertically */
            transform: translateY(-50%); /* Adjust for vertical centering */
            display: flex;
            flex-direction: column; /* Arrange buttons vertically */
            gap: 20px; /* Spacing between control buttons */
            background: rgba(255, 255, 255, 0.98);
            padding: 20px;
            border-radius: 60px; /* Adjust border-radius for vertical layout */
            box-shadow: 0 15px 50px rgba(0, 0, 0, 0.25);
            z-index: 10; /* Ensure it's above other content */
        }
        
        .control-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: none;
            background: white;
            color: #667eea;
            font-size: 1.7rem; /* Adjusted from 24px */
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 3px 15px rgba(0, 0, 0, 0.1);
            position: relative;
        }
        
        .control-btn:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.2);
            background: #667eea;
            color: white;
        }
        
        .control-btn:active {
            transform: translateY(-1px);
        }
        
        .control-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        
        .control-btn:disabled:hover {
            transform: none;
            background: white;
            color: #667eea;
        }
        
        /* Tooltip pour les boutons */
        .control-btn::after {
            content: attr(data-tooltip);
            position: absolute;
            left: -10px; /* Adjust for vertical positioning */
            transform: translateX(-100%); /* Move tooltip to the left of the button */
            top: 50%;
            transform: translateY(-50%);
            background: #333;
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 1rem; /* Adjusted from 14px */
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }
        
        .control-btn:hover::after {
            opacity: 1;
        }
        
        /* Icons pour les boutons */
        .icon-previous::before { content: "‚èÆÔ∏è"; }
        .icon-restart::before { content: "üîÑ"; }
        .icon-music::before { content: "üéµ"; }
        .icon-music.muted::before { content: "üîá"; }
        .icon-help::before { content: "‚ùì"; }
        .icon-solution::before { content: "üí°"; }
        .icon-skip::before { content: "‚è≠Ô∏è"; }
        .icon-finish::before { content: "üèÅ"; } /* New icon for finish button */
        
        /* Modals */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(5px);
        }
        
        .modal.active {
            display: flex;
        }
        
        .modal-content {
            background: white;
            padding: 50px;
            border-radius: 25px;
            max-width: 700px;
            width: 90%;
            max-height: 85vh;
            overflow-y: auto;
            position: relative;
            animation: modalIn 0.3s ease;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }
        
        @keyframes modalIn {
            from { transform: scale(0.8); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }
        
        .modal-close {
            position: absolute;
            top: 25px;
            right: 25px;
            width: 45px;
            height: 45px;
            border: none;
            background: #f0f0f0;
            border-radius: 50%;
            font-size: 2rem; /* Adjusted from 28px */
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .modal-close:hover {
            background: #e0e0e0;
            transform: rotate(90deg);
        }
        
        /* Sp√©cifique aux mini-jeux */
        .draggable {
            padding: 15px 25px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 15px;
            cursor: grab;
            user-select: none;
            margin: 8px;
            transition: all 0.3s ease;
            font-size: 1.1rem; /* Adjusted from 18px */
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.3);
        }
        
        .draggable:active {
            cursor: grabbing;
            opacity: 0.7;
            transform: scale(0.95);
        }
        
        .drop-zone {
            min-height: 70px;
            border: 3px dashed #ccc;
            border-radius: 15px;
            margin: 12px 0;
            padding: 15px;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.1rem; /* Adjusted from 18px */
            background: white;
        }
        
        .drop-zone.hover {
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.1);
            transform: scale(1.02);
        }
        
        .drop-zone.filled {
            border-style: solid;
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.05);
        }
        
        .material-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); /* Adjusted minmax for smaller font */
            gap: 25px;
            max-width: 1000px;
            margin-top: 40px;
        }
        
        .material-card {
            background: white;
            border: 3px solid #e0e0e0;
            border-radius: 20px;
            padding: 30px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }
        
        .material-icon {
            font-size: 4rem; /* Adjusted from 60px */
            line-height: 1;
        }
        
        .material-card:hover {
            border-color: #667eea;
            transform: translateY(-8px);
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.15);
        }
        
        .material-card.selected {
            border-color: #764ba2;
            background: rgba(118, 75, 162, 0.1);
            transform: scale(1.05);
        }
        
        .material-card.correct {
            background: #4caf50;
            color: white;
            border-color: #4caf50;
        }
        
        .material-card.incorrect {
            background: #f44336;
            color: white;
            border-color: #f44336;
        }
        
        .elevation-input {
            font-size: 1.8rem; /* Adjusted from 28px */
            padding: 20px 40px;
            border: 3px solid #e0e0e0;
            border-radius: 20px;
            text-align: center;
            width: 300px;
            transition: all 0.3s ease;
            margin: 20px 0;
        }
        
        .elevation-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2);
        }
        
        /* Network game */
        .network-svg {
            width: 100%;
            height: 100%;
        }
        
        .network-node {
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .network-node:hover {
            r: 25;
        }
        
        .network-line {
            stroke-width: 4;
            fill: none;
            stroke-dasharray: 10, 5;
            animation: dash 20s linear infinite;
        }
        
        @keyframes dash {
            to { stroke-dashoffset: -100; }
        }
        
        /* Confetti */
        .confetti {
            position: absolute;
            width: 12px;
            height: 12px;
            background: #667eea;
            animation: fall 3s linear forwards;
        }
        
        @keyframes fall {
            to {
                transform: translateY(100vh) rotate(360deg);
                opacity: 0;
            }
        }
        
        /* Scenario alert */
        .scenario-alert {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%);
            color: white;
            padding: 40px;
            border-radius: 25px;
            margin: 30px 0;
            text-align: center;
            animation: alertPulse 2s ease-in-out infinite;
            box-shadow: 0 10px 40px rgba(238, 90, 36, 0.4);
        }
        
        @keyframes alertPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }
        
        .scenario-icon {
            font-size: 4rem; /* Adjusted from 60px */
            margin-bottom: 20px;
        }
        
        /* Final screen stats */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 25px;
            margin: 40px 0;
            max-width: 800px;
        }
        
        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.3);
        }
        
        .stat-number {
            font-size: 3.2rem; /* Adjusted from 48px */
            font-weight: 800;
            margin: 10px 0;
        }
        
        .stat-label {
            font-size: 1.1rem; /* Adjusted from 18px */
            opacity: 0.9;
        }
        /* Added for right alignment of buttons */
        .button-center-align { /* Changed class name to reflect centering */
            width: 100%;
            max-width: 600px; /* Match the max-width of drop-zones/input for consistency */
            display: flex;
            justify-content: center; /* Centered now */
            margin-top: 30px; /* Add some top top margin */
        }

        /* New styles for the tips bar */
        .tips-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background: linear-gradient(90deg, #764ba2 0%, #667eea 100%);
            color: white;
            padding: 8px 0;
            font-size: 1rem; /* Adjusted from 16px */
            overflow: hidden;
            white-space: nowrap;
            box-shadow: 0 -5px 15px rgba(0, 0, 0, 0.2);
            z-index: 10; /* Ensure it's above other content */
            height: 30px; /* Explicit height to help with screen padding */
        }

        .tips-bar-content {
            display: inline-block;
            padding-left: 100%; /* Start off-screen to the right */
            animation: marquee 20s linear infinite; /* Adjust duration as needed */
        }

        @keyframes marquee {
            0% { transform: translateX(0%); }
            100% { transform: translateX(-100%); }
        }

        /* Home Screen Specific Styles */
        #homeScreen {
            background: white; /* Changed to white */
            color: #333; /* Default text color for home screen */
            text-shadow: none; /* Removed text shadow for better readability on white */
            justify-content: center;
            align-items: center;
            padding: 50px;
            margin-top: 0;
            margin-right: 0;
            margin-bottom: 0;
            position: relative;
            overflow: hidden;
        }

        #homeScreen::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='none' fill-rule='evenodd'%3E%3Cg fill='%239C92AC' fill-opacity='0.05'%3E%3Cpath d='M36 34v-4h-2v4h-4v2h4v4h2v-4h4v-2h-4zm0-30V0h-2v4h-4v2h4v4h2V6h4V4h-4zm0 36v-4h-2v4h-4v2h4v4h2v-4h4v-2h-4zm0 36v-4h-2v4h-4v2h4v4h2v-4h4v-2h-4zM12 34v-4H10v4H6v2h4v4h2v-4h4v-2h-4zm0-30V0h-2v4H6v2h4v4h2V6h4V4h-4zm0 36v-4H10v4H6v2h4v4h2v-4h4v-2h-4zm0 36v-4H10v4H6v2h4v4h2v-4h4v-2h-4z'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E");
            opacity: 0.8; /* More visible on white */
            z-index: 0;
            animation: backgroundPan 90s linear infinite;
        }

        @keyframes backgroundPan {
            0% { background-position: 0% 0%; }
            100% { background-position: 100% 100%; }
        }

        #homeScreen h1 {
            font-size: 5.5rem;
            background: linear-gradient(135deg, #1a202c 0%, #2d3748 100%); /* Dark gradient for text */
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: none; /* Removed text shadow */
            margin-bottom: 20px;
            letter-spacing: 3px;
            position: relative;
            z-index: 1;
        }

        #homeScreen p {
            font-size: 1.8rem;
            color: #333; /* Dark text */
            margin-bottom: 35px;
            text-shadow: none; /* Removed text shadow */
            line-height: 1.3;
            position: relative;
            z-index: 1;
        }

        #homeScreen .logo-icon {
            width: 180px;
            height: 180px;
            font-size: 8rem;
            border-radius: 50%;
            background: white; /* Keep white background */
            box-shadow: 0 10px 30px rgba(0,0,0,0.2), inset 0 0 15px rgba(0,0,0,0.1); /* Adjusted shadow for white background */
            margin-bottom: 40px;
            position: relative;
            z-index: 1;
            transition: all 0.4s ease-out;
        }
        #homeScreen .logo-icon:hover {
            transform: scale(1.1) rotate(8deg);
            box-shadow: 0 15px 40px rgba(0,0,0,0.3), inset 0 0 20px rgba(0,0,0,0.15);
        }

        #homeScreen .btn {
            padding: 22px 70px;
            font-size: 2rem;
            background: linear-gradient(135deg, #4299e1 0%, #3182ce 100%); /* Blue gradient */
            box-shadow: 0 12px 45px rgba(66, 153, 225, 0.6); /* Blue shadow */
            border: 3px solid rgba(255,255,255,0.4);
            position: relative;
            z-index: 1;
            overflow: hidden;
        }
        #homeScreen .btn:hover {
            transform: translateY(-7px);
            box-shadow: 0 18px 60px rgba(66, 153, 225, 0.8);
        }
        #homeScreen .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.3);
            transition: left 0.6s ease-out;
        }
        #homeScreen .btn:hover::before {
            left: 100%;
        }

        .home-features {
            font-size: 1.2rem;
            color: #444; /* Darker text for features */
            margin-bottom: 50px;
            text-align: center;
            line-height: 1.8;
            text-shadow: none; /* Removed text shadow */
            position: relative;
            z-index: 1;
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-width: 500px;
            padding: 15px 0;
        }
        .home-features p {
            margin: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            font-size: 1.2rem;
            color: #444; /* Ensure feature text is dark */
        }

        /* Character and Speech Bubble */
        #gameCharacter {
            position: fixed;
            bottom: 80px; /* Above the tips bar and progress bar */
            left: 30px;
            font-size: 5rem; /* Adjust size, e.g., 80px */
            z-index: 50; /* Above game content, below modals */
            transition: transform 0.3s ease-out;
        }

        #speechBubble {
            position: fixed;
            bottom: 140px; /* Above the character */
            left: 100px; /* To the right of the character */
            background: white;
            padding: 15px 25px;
            border-radius: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            max-width: 250px; /* Limit width */
            text-align: center;
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.3s ease-out, transform 0.3s ease-out;
            z-index: 50;
        }

        #speechBubble.active {
            opacity: 1;
            transform: translateY(0);
        }

        /* Pipe Connect Game Specific Styles */
        .pipe-game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            width: 100%;
            max-width: 800px;
        }

        .pipe-tray {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
            background: #f0f0f0;
            padding: 20px;
            border-radius: 15px;
            border: 2px solid #ddd;
            width: 100%;
        }

        .pipe-piece-draggable {
            width: 80px;
            height: 80px;
            background: #e2e8f0;
            border: 2px solid #cbd5e0;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: grab;
            transition: all 0.2s ease;
            position: relative;
            flex-shrink: 0; /* Prevent shrinking */
        }

        .pipe-piece-draggable:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        .pipe-piece-draggable.dragging {
            opacity: 0.6;
            cursor: grabbing;
        }

        .pipe-piece-draggable svg {
            width: 80%;
            height: 80%;
        }

        .pipe-grid-container {
            display: grid;
            border: 3px solid #667eea;
            border-radius: 15px;
            overflow: hidden;
            background: #f8f9fa;
        }

        .grid-cell {
            width: 100px; /* Fixed size for grid cells */
            height: 100px;
            border: 1px solid #e0e0e0;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            background-color: #fff;
        }

        .grid-cell.start-node {
            background-color: #d1fae5; /* Light green */
            border: 2px solid #34d399; /* Green border */
        }
        .grid-cell.end-node {
            background-color: #fee2e2; /* Light red */
            border: 2px solid #ef4444; /* Red border */
        }

        .grid-cell .pipe-piece-placed {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer; /* To allow rotation */
            transition: transform 0.1s ease-out;
        }

        .grid-cell .pipe-piece-placed svg {
            width: 80%;
            height: 80%;
            fill: #3b82f6; /* Blue pipe color */
            stroke: #1e40af; /* Darker blue stroke */
            stroke-width: 5;
            border-radius: 5px; /* Rounded pipe ends */
        }

        .grid-cell.correct-path .pipe-piece-placed svg {
            fill: #10b981; /* Green for correct path */
            stroke: #065f46;
        }
        .grid-cell.incorrect-path .pipe-piece-placed svg {
            fill: #ef4444; /* Red for incorrect path */
            stroke: #b91c1c;
        }

        .pipe-count {
            position: absolute;
            top: 5px;
            right: 5px;
            background: #667eea;
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 0.7rem;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-header" style="display: none;">
            <div class="logo">
                <div class="logo-icon">üèóÔ∏è</div>
                <span>LTD SIMULATEUR</span>
            </div>
            <div class="header-stats">
                <div class="font-size-controls">
                    <button class="font-size-btn" onclick="decreaseFontSize()">A-</button>
                    <button class="font-size-btn" onclick="increaseFontSize()">A+</button>
                </div>
                <div class="header-item">
                    <span class="score-icon"></span>
                    <span id="score">0</span>
                </div>
                <div class="header-item timer-display">
                    <span class="timer-icon"></span>
                    <span id="timer">0</span>s
                </div>
            </div>
        </div>
        
        <!-- √âcran d'accueil -->
        <div id="homeScreen" class="screen active">
            <div class="logo-icon">üèóÔ∏è</div>
            <h1>LTD SIMULATEUR</h1>
            <p>L'Exp√©rience Compl√®te du Projeteur VRD</p>
            <div class="home-features">
                <p>üî• <span>60 Niveaux de d√©fis techniques</span></p>
                <p>üö® <span>Sc√©narios r√©alistes de chantier</span></p>
                <p>üöÄ <span>Devenez expert en Voirie et R√©seaux Divers</span></p>
            </div>
            <button class="btn" onclick="startGame()">Commencer l'aventure</button>
        </div>
        
        <!-- √âcrans de jeu -->
        <div id="quizScreen" class="screen"></div>
        <div id="gameScreen" class="screen"></div>
        <div id="finalScreen" class="screen"></div>
        
        <!-- Contr√¥les -->
        <div class="controls" style="display: none;">
            <button class="control-btn icon-previous" data-tooltip="Niveau pr√©c√©dent" onclick="previousLevel()"></button>
            <button class="control-btn icon-restart" data-tooltip="Recommencer" onclick="confirmRestart()"></button>
            <button class="control-btn icon-music" data-tooltip="Musique" onclick="toggleMusic()"></button>
            <button class="control-btn icon-help" data-tooltip="Aide" onclick="showHelp()"></button>
            <button class="control-btn icon-solution" data-tooltip="Solution (-50 pts)" onclick="showSolution()"></button>
            <button class="control-btn icon-skip" data-tooltip="Passer (-10 pts)" onclick="skipLevel()"></button>
            <button class="control-btn icon-finish" data-tooltip="Finir le jeu (si score >= 1000)" id="finishGameBtn" disabled onclick="confirmFinishGame()"></button>
        </div>

        <!-- Character and Speech Bubble -->
        <div id="gameCharacter" style="display: none;"></div>
        <div id="speechBubble" style="display: none;"><span id="speechBubbleText"></span></div>

        <!-- Chronological Progress Bar (moved to bottom) -->
        <div class="progress-bar-chronological" style="display: none;">
            <div id="chronologicalProgressBarFill" class="progress-fill-chronological"></div>
        </div>

        <!-- Tips Bar (new) -->
        <div class="tips-bar" style="display: none;">
            <span id="tipsBarContent" class="tips-bar-content"></span>
        </div>
    </div>
    
    <!-- Modals -->
    <div id="helpModal" class="modal">
        <div class="modal-content">
            <button class="modal-close" onclick="closeModal('helpModal')">‚úï</button>
            <h2 style="color: #667eea; margin-bottom: 30px;">üìö Comment jouer ?</h2>
            <p style="font-size: 1.1rem; line-height: 1.6; margin-bottom: 25px;">
                Bienvenue dans LTD Simulateur ! Votre objectif est de devenir un expert en VRD 
                (Voirie et R√©seaux Divers) en compl√©tant 60 d√©fis vari√©s.
            </p>
            <h3 style="color: #764ba2; margin: 25px 0 15px;">üéÆ Types de d√©fis :</h3>
            <div style="background: #f8f9fa; padding: 20px; border-radius: 15px; margin-bottom: 25px;">
                <p style="margin: 10px 0;"><strong>üìù Quiz</strong> : Questions techniques sur la VRD</p>
                <p style="margin: 10px 0;"><strong>üîß Mat√©riaux</strong> : S√©lection des bons mat√©riaux</p>
                <p style="margin: 10px 0;"><strong>üîå R√©seaux</strong> : Connexion de canalisations</p>
                <p style="margin: 10px 0;"><strong>üìê Construction</strong> : Assemblage des couches</p>
                <p style="margin: 10px 0;"><strong>üßÆ Calculs</strong> : Probl√®mes d'altitude et pente</p>
                <p style="margin: 10px 0;"><strong>‚ö†Ô∏è Sc√©narios</strong> : Situations d'urgence</p>
                <p style="margin: 10px 0;"><strong>üß© Tuyaux</strong> : Connectez les sections de canalisation.</p>
                <p style="margin: 10px 0;"><strong>üåü BONUS - D√©tection de Conflits</strong> : Identifiez les probl√®mes de r√©seaux.</p>
                <p style="margin: 10px 0;"><strong>üåü BONUS - Calcul de Volume</strong> : Calculez les volumes de terrassement.</p>
            </div>
            <h3 style="color: #764ba2; margin: 25px 0 15px;">üíØ Syst√®me de points :</h3>
            <div style="background: #e8f5e9; padding: 20px; border-radius: 15px; margin-bottom: 25px;">
                <p style="margin: 10px 0;">‚úÖ Bonne r√©ponse : <strong>+50 √† +100 points</strong></p>
                <p style="margin: 10px 0;">‚ùå Mauvaise r√©ponse : <strong>-10 √† -30 points</strong></p>
                <p style="margin: 10px 0;">‚è∞ Temps √©coul√© : <strong>-20 points</strong></p>
                <p style="margin: 10px 0;">üí° Voir solution : <strong>-50 points</strong></p>
                <p style="margin: 10px 0;">‚è≠Ô∏è Passer : <strong>-10 points</strong></p>
                <p style="margin: 10px 0;">üî• Bonus r√©ussis : <strong>Doublent les points de la prochaine question !</strong></p>
            </div>
            <button class="btn" onclick="closeModal('helpModal')">Compris !</button>
        </div>
    </div>
    
    <div id="confirmModal" class="modal">
        <div class="modal-content" style="text-align: center;">
            <h2 id="confirmTitle" style="color: #667eea; margin-bottom: 30px;">Confirmer</h2>
            <p style="font-size: 1.2rem; margin: 30px 0;" id="confirmText">√ätes-vous s√ªr ?</p>
            <div style="display: flex; gap: 20px; justify-content: center; margin-top: 40px;">
                <button class="btn" onclick="confirmAction()">Oui</button>
                <button class="btn btn-secondary" onclick="closeModal('confirmModal')">Non</button>
            </div>
        </div>
    </div>

    <div id="correctionModal" class="modal">
        <div class="modal-content">
            <button class="modal-close" onclick="closeModal('correctionModal')">‚úï</button>
            <h2 style="color: #667eea; margin-bottom: 30px;">üìä Rapport de Correction</h2>
            <div id="correctionReportContent" style="font-size: 1.1rem; line-height: 1.6;">
                <!-- Correction content will be inserted here -->
            </div>
            <button class="btn mt-8" onclick="copyCorrectionToClipboard()">Copier la correction</button>
        </div>
    </div>

<script>
// Game state
let gameState = {
    currentLevel: 0,
    score: 0,
    timer: null,
    timeLeft: 0,
    musicEnabled: true,
    // Store detailed answers for correction report
    answers: [], // { levelIndex: N, type: 'quiz', question: '...', userAnswer: '...', correctAnswer: '...', isCorrect: true/false, pointsEarned: X }
    synth: null,
    pendingAction: null,
    skillScores: { // Track performance per skill type
        quiz: { correct: 0, total: 0 },
        material: { correct: 0, total: 0 },
        drag: { correct: 0, total: 0 },
        calc: { correct: 0, total: 0 },
        network: { correct: 0, total: 0 },
        scenario: { correct: 0, total: 0 },
        pipe_connect: { correct: 0, total: 0 }, // New skill type
        conflict_detection: { correct: 0, total: 0 }, // New skill type
        volume_calc: { correct: 0, total: 0 } // New skill type
    },
    baseFontSize: 14, // Default base font size in pixels, adjusted to 14px
    characterTipInterval: null, // Interval for character tips
    shuffledLevels: [], // New array to store shuffled levels
    isBonusRound: false, // Flag to indicate if current round is a bonus round
    bonusLevelData: null, // Stores the current bonus level data
    bonusMultiplier: 1 // Multiplier for points on the next question
};

// Level data
const originalLevels = [ // Renamed to originalLevels
    // Level 1-5: Introduction
    { type: 'quiz', question: "Que signifie VRD ?", answers: ["Voirie et R√©seaux Divers", "Vraiment Rapide et Dangereux", "V√©rification Routi√®re D√©taill√©e"], correct: 0, points: 50 },
    { type: 'drag', question: "Assemblez les couches d'une voirie (de bas en haut)", items: ["Sol support", "G√©otextile", "Grave non trait√©e", "Enrob√©"], points: 100 },
    { type: 'quiz', question: "Quelle est la couleur normalis√©e pour l'eau potable ?", answers: ["Rouge", "Bleu", "Vert", "Jaune"], correct: 1, points: 50 },
    { type: 'material', question: "S√©lectionnez le mat√©riau le plus adapt√© pour un trottoir", materials: ["Asphalte", "B√©ton d√©sactiv√©", "Terre battue", "Gravier"], icons: ["üõ£Ô∏è", "üß±", "üåø", "üöß"], correct: 1, points: 75 },
    { type: 'network', question: "Tracez le r√©seau d'eaux us√©es du point A au point B", points: 100, correctPath: ['nodeA', 'nodeB'], nodes: [{ id: 'nodeA', cx: 100, cy: 100, color: 'blue' }, { id: 'nodeB', cx: 400, cy: 100, color: 'blue' }, { id: 'nodeC', cx: 100, cy: 400, color: 'red' }, { id: 'nodeD', cx: 400, cy: 400, color: 'red' }, { id: 'nodeE', cx: 250, cy: 250, color: 'green' }] },
    
    // Level 6-10: Technical basics
    { type: 'quiz', question: "Quelle est la pente minimale pour un r√©seau EU ?", answers: ["0.5%", "1%", "2%", "5%"], correct: 1, points: 75 },
    { type: 'quiz', question: "Qu'est-ce qu'un plan de r√©colement ?", answers: ["Le plan initial du projet", "Un plan des travaux r√©alis√©s", "Un planning de chantier"], correct: 1, points: 50 },
    { type: 'volume_calc', question: "Calculez le volume de terre (en m¬≥) √† √©vacuer pour une tranch√©e de 20m de long, 0.8m de large et 1.2m de profondeur.", answer: "19.20", points: 120 }, // Modified for diversity
    { type: 'quiz', question: "Qu'est-ce qu'un avaloir ?", answers: ["Une bouche d'incendie", "Un dispositif de collecte des eaux", "Un type de regard"], correct: 1, points: 50 },
    { type: 'calc', question: "Altitude d√©part: 100.00m, pente 2% sur 50m. Altitude finale ?", answer: "99.00", points: 100 },
    
    // Level 11-15: Networks
    { type: 'quiz', question: "Profondeur hors gel moyenne en France ?", answers: ["20-30cm", "50-80cm", "100-120cm"], correct: 1, points: 75 },
    { type: 'quiz', question: "Couleur du grillage avertisseur √©lectrique ?", answers: ["Bleu", "Rouge", "Vert", "Jaune"], correct: 1, points: 50 },
    { type: 'material', question: "Quel regard pour un changement de direction EU ?", materials: ["Regard de visite", "Bouche √† cl√©", "Avaloir", "Tabouret"], icons: ["üï≥Ô∏è", "üîß", "üåä", "ü™ë"], correct: 0, points: 75 },
    { type: 'network', question: "Connectez le r√©seau t√©l√©com en √©vitant les autres r√©seaux", points: 100, correctPath: ['nodeA', 'nodeD'], nodes: [{ id: 'nodeA', cx: 100, cy: 100, color: 'orange' }, { id: 'nodeB', cx: 250, cy: 250, color: 'red' }, { id: 'nodeC', cx: 400, cy: 100, color: 'green' }, { id: 'nodeD', cx: 400, cy: 400, color: 'orange' }] },
    { type: 'quiz', question: "Que signifie PMR ?", answers: ["Projet Majeur R√©gional", "Personnes √† Mobilit√© R√©duite", "Plan de Mise en Route"], correct: 1, points: 50 },
    
    // Level 16-20: VRD Deep Dive
    { type: 'calc', question: "Altitude finale: 85.50m, pente 1.5% sur 100m. Altitude d√©part ?", answer: "87.00", points: 100 },
    { type: 'quiz', question: "Quel est le r√¥le d'un g√©otextile ?", answers: ["Emp√™cher la pousse des mauvaises herbes", "S√©parer des couches de mat√©riaux", "Drainer l'eau", "Renforcer la structure"], correct: 1, points: 75 },
    { type: 'material', question: "Quel type de canalisation pour l'assainissement gravitaire ?", materials: ["PVC", "PEHD", "Fonte", "Acier"], icons: ["üìè", "üîó", "‚öôÔ∏è", "üî©"], correct: 0, points: 75 },
    { type: 'quiz', question: "Qu'est-ce qu'un BPU en VRD ?", answers: ["Bordure Paveur Urbain", "B√©ton Pr√™t √† l'Usage", "Bureau des Projets Urbains"], correct: 0, points: 50 }, // First occurrence (kept)
    { type: 'scenario', question: "Un r√©seau d'eau potable est endommag√©. Quelle est la premi√®re action √† mener ?", actions: ["Couper l'arriv√©e d'eau", "R√©parer imm√©diatement", "Pr√©venir les usagers", "Analyser la cause"], correct: 0, points: 100 },

    // Level 21-25: Practical cases and standards
    { type: 'network', question: "Optimisez le trac√© du r√©seau d'√©clairage public pour minimiser les longueurs", points: 120, correctPath: ['nodeB', 'nodeC'], nodes: [{ id: 'nodeA', cx: 100, cy: 250, color: 'yellow' }, { id: 'nodeB', cx: 250, cy: 100, color: 'yellow' }, { id: 'nodeC', cx: 400, cy: 250, color: 'yellow' }, { id: 'nodeD', cx: 250, cy: 400, color: 'yellow' }] },
    { type: 'quiz', question: "Quelle norme r√©git l'accessibilit√© PMR en France ?", answers: ["NF P98-331", "Arr√™t√© du 15 janvier 2007", "DTU 20.1"], correct: 1, points: 75 },
    { type: 'material', question: "Mat√©riau pour une conduite d'eau potable sous pression ?", materials: ["PVC-O", "Gr√®s", "B√©ton arm√©", "Fibrociment"], icons: ["üíß", "üè∫", "üèóÔ∏è", "üí®"], correct: 0, points: 80 },
    { type: 'calc', question: "Distance: 75m, d√©nivel√©: 1.5m. Quelle est la pente en % ?", answer: "2.00", points: 100 },
    { type: 'scenario', question: "Vous d√©couvrez un r√©seau non r√©pertori√© lors des terrassements. Que faites-vous ?", actions: ["Continuer les travaux avec prudence", "Arr√™ter les travaux et informer le chef de projet", "Essayer de l'identifier vous-m√™me", "Le contourner sans le signaler"], correct: 1, points: 150 },

    // Level 26-30: Expertise and project management (Modified drag level)
    { type: 'drag', question: "Classez les √©tapes cl√©s d'un projet VRD (de l'initialisation √† la cl√¥ture)", items: ["√âtude de faisabilit√©", "Conception d√©taill√©e", "Appel d'offres et s√©lection entreprises", "Ex√©cution des travaux", "R√©ception et lev√©e des r√©serves"], points: 130 }, // Modified for diversity
    { type: 'quiz', question: "Quelle est la fonction principale d'un caniveau ?", answers: ["D√©limiter la chauss√©e", "Collecter les eaux de ruissellement", "Servir de support aux r√©seaux", "Am√©liorer l'esth√©tique"], correct: 1, points: 60 },
    { type: 'network', question: "Concevez un r√©seau de drainage pluvial pour un parking, avec points de collecte", points: 130, correctPath: ['nodeC', 'nodeD'], nodes: [{ id: 'nodeA', cx: 100, cy: 100, color: 'grey' }, { id: 'nodeB', cx: 400, cy: 100, color: 'grey' }, { id: 'nodeC', cx: 100, cy: 400, color: 'grey' }, { id: 'nodeD', cx: 400, cy: 400, color: 'grey' }] },
    { type: 'calc', question: "Longueur de r√©seau: 200m, pente 0.8%. Quel est le d√©nivel√© total ?", answer: "1.60", points: 100 },
    { type: 'scenario', question: "Les pr√©visions m√©t√©o annoncent de fortes pluies. Comment adaptez-vous le chantier ?", actions: ["Ne rien changer", "Prot√©ger les fouilles, v√©rifier le drainage et s√©curiser les mat√©riaux", "Acc√©l√©rer les travaux", "Arr√™ter le chantier compl√®tement"], correct: 1, points: 140 },

    // Level 31: New Mini-Game - Pipe Connection
    {
        type: 'pipe_connect',
        question: "Connectez les sections de canalisation pour cr√©er un r√©seau fonctionnel. Cliquez sur un tuyau pour le faire pivoter.",
        points: 150,
        gridSize: 4, // 4x4 grid
        start: { row: 0, col: 0 },
        end: { row: 3, col: 3 },
        availablePieces: [
            { type: 'straight', count: 3 }, // 3 straight pipes
            { type: 'bend', count: 4 },     // 4 bend pipes
            { type: 't_junction', count: 1 } // 1 T-junction
        ],
        correctSolutionDescription: "Utilisez les tuyaux fournis pour cr√©er un chemin continu du point de d√©part au point d'arriv√©e."
    },
    // New levels for diversity
    { type: 'quiz', question: "Quel est le r√¥le du g√©om√®tre-expert en VRD ?", answers: ["R√©aliser les travaux de terrassement", "√âtablir les plans topographiques et les implantations", "G√©rer le budget du projet", "Vendre les √©quipements de chantier"], correct: 1, points: 80 },
    { type: 'material', question: "Quel mat√©riau est couramment utilis√© pour les conduites d'eaux pluviales de grand diam√®tre ?", materials: ["PVC", "PEHD annel√©", "Gr√®s", "Fonte"], icons: ["üìè", "üåÄ", "üè∫", "‚öôÔ∏è"], correct: 1, points: 90 },
    { type: 'drag', question: "Classez les √©l√©ments d'un regard de visite (du bas vers le haut).", items: ["Radier", "Cunette", "Rehausses", "Cadre et tampon"], points: 110 },
    { type: 'calc', question: "Un point haut est √† 150.00m. La pente est de 0.5% sur 120m. Quelle est l'altitude du point bas ?", answer: "149.40", points: 100 },
    { type: 'network', question: "Tracez un r√©seau d'eau potable avec une d√©rivation vers un b√¢timent.", points: 120, correctPath: ['nodeA', 'nodeC'], nodes: [{ id: 'nodeA', cx: 100, cy: 200, color: 'blue' }, { id: 'nodeB', cx: 400, cy: 200, color: 'blue' }, { id: 'nodeC', cx: 250, cy: 400, color: 'blue' }] },
    { type: 'scenario', question: "Un ouvrier signale une odeur de gaz sur le chantier. Que faites-vous ?", actions: ["Ignorer et continuer", "Arr√™ter les travaux, √©vacuer la zone et appeler les secours", "Chercher la fuite vous-m√™me", "Ventiler la zone"], correct: 1, points: 160 },
    { type: 'quiz', question: "Quel document est utilis√© pour localiser les r√©seaux existants avant les travaux ?", answers: ["Plan de masse", "Plan de r√©colement", "DICT", "Permis de construire"], correct: 2, points: 60 },
    { type: 'material', question: "Quel mat√©riau est couramment utilis√© pour les bordures de trottoir ?", materials: ["Bois", "Plastique recycl√©", "Granit", "M√©tal"], icons: ["üå≥", "‚ôªÔ∏è", "ü™®", "‚õìÔ∏è"], correct: 2, points: 80 },
    { type: 'calc', question: "Une canalisation de 120m a un d√©nivel√© de 2.4m. Quelle est sa pente en % ?", answer: "2.00", points: 100 },
    { type: 'quiz', question: "Quelle est la couleur du grillage avertisseur pour le gaz ?", answers: ["Bleu", "Rouge", "Jaune", "Vert"], correct: 2, points: 50 },
    { type: 'drag', question: "Classez les √©l√©ments d'un syst√®me de drainage (du plus haut au plus bas).", items: ["Grille de caniveau", "Caniveau", "Tuyau de collecte", "Regard de visite"], points: 120 },
    { type: 'network', question: "Tracez un r√©seau d'arrosage pour couvrir toutes les zones vertes.", points: 130, correctPath: ['nodeA', 'nodeE'], nodes: [{ id: 'nodeA', cx: 100, cy: 100, color: 'green' }, { id: 'nodeB', cx: 400, cy: 100, color: 'green' }, { id: 'nodeC', cx: 100, cy: 400, color: 'green' }, { id: 'nodeD', cx: 400, cy: 400, color: 'green' }, { id: 'nodeE', cx: 250, cy: 250, color: 'green' }] },
    { type: 'scenario', question: "Un riverain se plaint du bruit des travaux. Quelle est votre d√©marche ?", actions: ["Ignorer la plainte", "Lui demander de contacter la mairie", "L'√©couter, expliquer les mesures prises et proposer des solutions si possible", "Arr√™ter imm√©diatement les travaux"], correct: 2, points: 120 },
    { type: 'quiz', question: "Qu'est-ce qu'un DTU ?", answers: ["Document Technique Unifi√©", "D√©claration de Travaux Urgents", "Dossier Technique Urbain"], correct: 0, points: 70 },
    { type: 'material', question: "Quel type de rev√™tement est souvent utilis√© pour les pistes cyclables ?", materials: ["B√©ton", "Enrob√© drainant", "Pav√©s", "Terre stabilis√©e"], icons: ["üß±", "ÔøΩ", "ü™®", "üåø"], correct: 1, points: 85 },
    { type: 'calc', question: "Calculez la longueur horizontale pour une pente de 2% et un d√©nivel√© de 0.5m.", answer: "25.00", points: 100 },
    { type: 'quiz', question: "Quel est le r√¥le d'un g√©omembranier ?", answers: ["Installer des g√©otextiles", "Poser des membranes d'√©tanch√©it√©", "R√©aliser des √©tudes g√©otechniques"], correct: 1, points: 75 },
    { type: 'scenario', question: "Vous d√©couvrez un vestige arch√©ologique sur le chantier. Que faites-vous ?", actions: ["Le d√©placer discr√®tement pour continuer les travaux", "Arr√™ter les travaux, s√©curiser la zone et contacter les autorit√©s comp√©tentes", "Le photographier et le signaler apr√®s la fin du chantier", "Le signaler √† l'√©quipe sans arr√™ter les travaux"], correct: 1, points: 180 },
    { type: 'quiz', question: "Quelle est la signification de 'EP' dans le contexte VRD ?", answers: ["Eau Potable", "Eaux Pluviales", "√âclairage Public"], correct: 1, points: 60 },
    { type: 'material', question: "Mat√©riau pour les regards de branchement d'eaux us√©es.", materials: ["B√©ton pr√©fabriqu√©", "Plastique", "Brique", "Acier"], icons: ["üß±", "‚ôªÔ∏è", "üè†", "‚õìÔ∏è"], correct: 0, points: 70 },
    { type: 'quiz', question: "Quel est le principal risque li√© √† la pr√©sence d'amiante dans les anciennes canalisations ?", answers: ["Fuites fr√©quentes", "Contamination de l'eau", "Risque sanitaire lors de la manipulation", "Faible r√©sistance aux chocs"], correct: 2, points: 90 },
    { type: 'quiz', question: "Quelle est la fonction d'une chambre de tirage en r√©seau t√©l√©com ?", answers: ["Connecter les c√¢bles √† la fibre optique", "Permettre le tirage et la maintenance des c√¢bles", "Mesurer le d√©bit de donn√©es"], correct: 1, points: 80 },
    { type: 'quiz', question: "Qu'est-ce qu'un PSS ?", answers: ["Plan de S√©curit√© et de Sant√©", "Projet de Stabilit√© des Sols", "Programme de Suivi des S√©diments"], correct: 0, points: 75 },
    { type: 'quiz', question: "Quel est le r√¥le du ma√Ætre d'≈ìuvre en VRD ?", answers: ["Financer le projet", "R√©aliser les travaux", "Concevoir et suivre la r√©alisation du projet", "Vendre les mat√©riaux"], correct: 2, points: 100 },
    { type: 'pipe_connect',
        question: "Connectez les sections de canalisation pour cr√©er un r√©seau d'eau pluviale. Cliquez sur un tuyau pour le faire pivoter.",
        points: 160,
        gridSize: 5, // 5x5 grid
        start: { row: 0, col: 2 },
        end: { row: 4, col: 2 },
        availablePieces: [
            { type: 'straight', count: 5 },
            { type: 'bend', count: 6 },
            { type: 't_junction', count: 2 }
        ],
        correctSolutionDescription: "Cr√©ez un chemin continu du point de d√©part au point d'arriv√©e avec les tuyaux."
    },
    { type: 'quiz', question: "Qu'est-ce qu'un fil d'eau en assainissement ?", answers: ["Le niveau le plus bas de l'√©coulement dans une canalisation", "La ligne de flottaison des eaux us√©es", "Le trac√© d'un cours d'eau souterrain"], correct: 0, points: 70 },
    { type: 'material', question: "Quel mat√©riau est privil√©gi√© pour les chambres de tirage de fibre optique ?", materials: ["B√©ton arm√©", "Brique", "Polyester renforc√© de fibres de verre (PRV)", "Acier"], icons: ["üèóÔ∏è", "üè†", "üì°", "‚õìÔ∏è"], correct: 2, points: 95 },
    { type: 'drag', question: "Classez les √©tapes de raccordement d'un branchement d'eaux us√©es (du d√©but √† la fin).", items: ["Rep√©rage et marquage", "Ouverture de la tranch√©e", "Pose du tabouret de branchement", "Raccordement au collecteur", "Remblayage et compactage"], points: 140 },
    { type: 'calc', question: "Calculez le volume de remblai (en m¬≥) n√©cessaire pour une fouille de 15m de long, 3m de large et 2m de profondeur, sachant que le foisonnement est de 20%.", answer: "72.00", points: 150 }, // 15*3*2 = 90. 90 * 0.8 = 72
    { type: 'network', question: "Concevez un r√©seau de fibre optique pour desservir 3 points de raccordement.", points: 140, correctPath: ['nodeA', 'nodeD'], nodes: [{ id: 'nodeA', cx: 100, cy: 100, color: 'purple' }, { id: 'nodeB', cx: 400, cy: 100, color: 'purple' }, { id: 'nodeC', cx: 100, cy: 400, color: 'purple' }, { id: 'nodeD', cx: 400, cy: 400, color: 'purple' }] },
    { type: 'scenario', question: "Une machine critique tombe en panne au milieu du chantier. Que faites-vous ?", actions: ["Tenter de la r√©parer soi-m√™me", "Attendre le technicien sans rien faire", "Contacter le fournisseur pour une intervention rapide et organiser un plan B", "Continuer les travaux manuellement"], correct: 2, points: 130 },
    { type: 'quiz', question: "Quelle est l'importance de la signalisation de chantier ?", answers: ["D√©corer le chantier", "Informer le public et assurer la s√©curit√© des travailleurs et usagers", "Cacher les travaux en cours"], correct: 1, points: 65 },
    { type: 'material', question: "Quel type de b√©ton est utilis√© pour les fondations profondes ?", materials: ["B√©ton d√©sactiv√©", "B√©ton autopla√ßant (BAP)", "B√©ton fibr√©", "B√©ton arm√©"], icons: ["üß±", "üåä", "üîó", "üí™"], correct: 3, points: 85 },
    { type: 'calc', question: "Un r√©seau doit avoir une pente de 1.2% sur 80m. Si l'altitude de d√©part est 50.00m, quelle est l'altitude d'arriv√©e ?", answer: "49.04", points: 100 },
    { type: 'quiz', question: "Quelle est la fonction d'une bouche √† cl√© ?", answers: ["Permettre l'acc√®s √† un regard", "Ouvrir ou fermer une vanne sur un r√©seau", "Mesurer la pression de l'eau"], correct: 1, points: 70 },
    { type: 'pipe_connect',
        question: "Connectez les sections de canalisation pour un r√©seau d'assainissement complexe.",
        points: 170,
        gridSize: 5,
        start: { row: 1, col: 0 },
        end: { row: 3, col: 4 },
        availablePieces: [
            { type: 'straight', count: 4 },
            { type: 'bend', count: 5 },
            { type: 't_junction', count: 3 },
            { type: 'cross', count: 1 }
        ],
        correctSolutionDescription: "Cr√©ez un chemin continu du point de d√©part au point d'arriv√©e avec les tuyaux."
    },
    { type: 'quiz', question: "Qu'est-ce qu'un puits perdu ?", answers: ["Un puits sans fond", "Un ouvrage de collecte et d'infiltration des eaux pluviales", "Un puits d'acc√®s aux r√©seaux souterrains"], correct: 1, points: 75 },
    { type: 'material', question: "Quel mat√©riau est le plus r√©sistant √† la corrosion pour les r√©seaux d'eaux us√©es industrielles ?", materials: ["PVC", "Gr√®s", "Polypropyl√®ne (PP)", "B√©ton"], icons: ["üìè", "üè∫", "üß™", "üèóÔ∏è"], correct: 2, points: 100 },
    { type: 'calc', question: "Un point A est √† 120.50m et un point B √† 119.80m, distants de 50m. Quelle est la pente moyenne en % ?", answer: "1.40", points: 110 },
    { type: 'network', question: "Tracez un r√©seau d'irrigation pour un parc avec plusieurs zones √† desservir.", points: 150, correctPath: ['nodeA', 'nodeE'], nodes: [{ id: 'nodeA', cx: 100, cy: 100, color: 'cyan' }, { id: 'nodeB', cx: 400, cy: 100, color: 'cyan' }, { id: 'nodeC', cx: 100, cy: 400, color: 'cyan' }, { id: 'nodeD', cx: 400, cy: 400, color: 'cyan' }, { id: 'nodeE', cx: 250, cy: 250, color: 'cyan' }] },
    { type: 'scenario', question: "Un camion de livraison bloque l'acc√®s au chantier. Que faites-vous ?", actions: ["Klaxonner jusqu'√† ce qu'il bouge", "Attendre patiemment", "Contacter le chauffeur ou l'entreprise de livraison pour qu'il d√©gage le passage", "Essayer de le d√©placer avec un engin de chantier"], correct: 2, points: 110 },
    { type: 'quiz', question: "Quelle est la diff√©rence entre un regard de visite et un tabouret de branchement ?", answers: ["Le regard est plus grand et permet l'acc√®s pour l'entretien, le tabouret est pour les branchements individuels.", "Le regard est pour l'eau potable, le tabouret pour les eaux us√©es.", "Le regard est en surface, le tabouret est enterr√©."], correct: 0, points: 85 },
    { type: 'material', question: "Quel mat√©riau est le plus adapt√© pour les pav√©s carrossables ?", materials: ["B√©ton", "Granit", "Gr√®s", "Bois"], icons: ["üß±", "ü™®", "üè∫", "üå≥"], correct: 1, points: 90 },
    { type: 'calc', question: "Une conduite de 300m a un d√©nivel√© de 6m. Quelle est sa pente en pour mille (‚Ä∞) ?", answer: "20.00", points: 120 }, // 6/300 * 1000 = 20
    { type: 'quiz', question: 'Qu\'est-ce qu\'une "zone d\'emprise" en VRD ?', answers: ["La zone o√π les engins de chantier sont stock√©s", "La surface de terrain n√©cessaire √† la r√©alisation des travaux et √† l'implantation des ouvrages", "La zone de circulation des pi√©tons"], correct: 1, points: 75 },
    { type: 'pipe_connect',
        question: "R√©tablissez la connexion du r√©seau d'assainissement apr√®s une rupture.",
        points: 180,
        gridSize: 6,
        start: { row: 0, col: 0 },
        end: { row: 5, col: 5 },
        availablePieces: [
            { type: 'straight', count: 6 },
            { type: 'bend', count: 7 },
            { type: 't_junction', count: 2 },
            { type: 'cross', count: 1 }
        ],
        correctSolutionDescription: "Cr√©ez un chemin continu du point de d√©part au point d'arriv√©e avec les tuyaux."
    },
    { type: 'quiz', question: "√Ä quoi sert un fil d'eau dans le calcul de pente d'une canalisation ?", answers: ["√Ä mesurer le d√©bit d'eau", "√Ä d√©finir la ligne de r√©f√©rence pour la pente", "√Ä indiquer la pr√©sence d'eau"], correct: 1, points: 80 },
    { type: 'material', question: "Quel type de g√©omembrane est utilis√© pour l'√©tanch√©it√© des bassins de r√©tention ?", materials: ["PVC", "PEHD", "EPDM", "Bitume"], icons: ["üìè", "üîó", "üíß", "üõ£Ô∏è"], correct: 1, points: 95 },
    { type: 'calc', question: "Une parcelle a une superficie de 500m¬≤. Un bassin de r√©tention doit collecter 100m¬≥ d'eau. Quelle hauteur d'eau (en m) cela repr√©sente-t-il sur la parcelle ?", answer: "0.20", points: 130 }, // 100/500 = 0.2
    { type: 'network', question: "Connectez les bornes incendie au r√©seau d'eau existant, en respectant les distances de s√©curit√©.", points: 160, correctPath: ['nodeA', 'nodeB'], nodes: [{ id: 'nodeA', cx: 100, cy: 100, color: 'red' }, { id: 'nodeB', cx: 400, cy: 100, color: 'red' }, { id: 'nodeC', cx: 100, cy: 400, color: 'red' }, { id: 'nodeD', cx: 400, cy: 400, color: 'red' }] },
    { type: 'scenario', question: "Un engin de chantier endommage accidentellement une cl√¥ture de propri√©t√© priv√©e. Que faites-vous ?", actions: ["Ignorer et partir", "R√©parer la cl√¥ture vous-m√™me sans pr√©venir", "S√©curiser la zone, informer le propri√©taire et le chef de projet, et organiser la r√©paration professionnelle", "Laisser un mot avec vos coordonn√©es"], correct: 2, points: 170 },
    { type: 'quiz', question: "Quel est le r√¥le d'un contr√¥leur technique en VRD ?", answers: ["R√©aliser les √©tudes de sol", "V√©rifier la conformit√© des ouvrages aux normes et r√©glementations", "G√©rer les √©quipes sur le chantier"], correct: 1, points: 90 },
    { type: 'material', question: "Quel type de sable est utilis√© pour le lit de pose des canalisations ?", materials: ["Sable de carri√®re", "Sable de mer", "Sable concass√©", "Sable de rivi√®re lav√©"], icons: ["‚õ∞Ô∏è", "üåä", "üî®", "üíß"], correct: 3, points: 80 },
    { type: 'calc', question: "Un regard a une altitude de fond de 98.75m. La canalisation en sortie a une pente de 1.5% sur 30m. Quelle est l'altitude du fil d'eau √† 30m ?", answer: "98.30", points: 120 }, // 98.75 - (30 * 0.015) = 98.30
    { type: 'quiz', question: "Que signifie 'DICT' en VRD ?", answers: ["D√©claration d'Intention de Commencement de Travaux", "Document d'Information sur les Canalisations et les Terrains", "Dossier d'Intervention et de Consultation Technique"], correct: 0, points: 60 }, // Replaced duplicate 2
    { type: 'scenario', question: "Le budget du projet est d√©pass√©. Quelle est votre premi√®re action ?", actions: ["Arr√™ter tous les travaux", "Demander plus d'argent sans justification", "Analyser les causes du d√©passement et proposer des mesures correctives au chef de projet", "R√©duire la qualit√© des mat√©riaux pour √©conomiser"], correct: 2, points: 140 },
    { type: 'quiz', question: "Quelle est la fonction d'un r√©seau s√©paratif ?", answers: ["Collecter toutes les eaux (us√©es et pluviales) ensemble", "S√©parer la collecte des eaux us√©es de celle des eaux pluviales", "S√©parer les r√©seaux d'eau potable et d'incendie"], correct: 1, points: 80 },
    { type: 'material', question: "Quel type de grave est utilis√© pour la couche de fondation d'une chauss√©e ?", materials: ["Grave non trait√©e (GNT)", "Sable", "Terre v√©g√©tale", "Enrob√©"], icons: ["üöß", "üèñÔ∏è", "üåø", "üõ£Ô∏è"], correct: 0, points: 85 },
    { type: 'calc', question: "Un r√©seau de 80m de long a un d√©nivel√© de 1.6m. Quelle est sa pente en degr√©s ?", answer: "1.15", points: 140 }, // atan(1.6/80) * 180/PI = 1.1459
    { type: 'quiz', question: "Quel est le r√¥le du 'DTU' dans la construction ?", answers: ["D√©finir les r√®gles de l'art pour les travaux", "Document de Travaux Urgents", "D√©claration Technique d'Urbanisme"], correct: 0, points: 70 }, // Replaced duplicate 3
];

const bonusLevels = [
    { type: 'conflict_detection', question: "Une canalisation de gaz (PEHD) est pos√©e √† 20 cm d'un arbre existant. Y a-t-il un conflit ?", options: ["Oui, risque d'endommagement par les racines", "Non, la distance est suffisante", "Oui, conflit de mat√©riau"], correct: 0, points: 150 }, // Modified for diversity
    { type: 'volume_calc', question: "Calculez le volume de terre (en m¬≥) √† √©vacuer pour une fouille de 10m de long, 2m de large et 1.5m de profondeur.", answer: "30.00", points: 150 },
    { type: 'volume_calc', question: "Quel volume de grave non trait√©e (en m¬≥) est n√©cessaire pour une couche de forme de 100m de long, 6m de large et 0.30m d'√©paisseur ?", answer: "180.00", points: 140 }, // New diverse volume calc
    { type: 'conflict_detection', question: "Un collecteur d'eaux us√©es (diam√®tre 500mm) est pr√©vu avec une pente de 0.2%. Y a-t-il un conflit ?", options: ["Non, c'est une pente standard", "Oui, la pente est insuffisante pour l'auto-curage", "Oui, la pente est trop forte"], correct: 1, points: 160 }, // New diverse conflict detection
    { type: 'volume_calc', question: "Un r√©servoir cylindrique d'eau pluviale a un diam√®tre de 3m et une hauteur de 4m. Quel est son volume (en m¬≥) ?", answer: "28.27", points: 130 }, // New diverse volume calc (requires PI)
    { type: 'conflict_detection', question: "Un r√©seau d'eau potable doit croiser un r√©seau √©lectrique existant. La norme impose une distance minimale de 40 cm. Ils sont pr√©vus √† 30 cm. Y a-t-il un conflit ?", options: ["Non, la distance est acceptable", "Oui, la distance minimale n'est pas respect√©e", "Oui, mais uniquement si l'eau est sous pression"], correct: 1, points: 170 } // Another diverse conflict detection
];

// Tips for the scrolling bar
const gameTips = [
    "Astuce: V√©rifiez toujours les plans de r√©seaux avant de terrasser.",
    "Astuce: Une bonne gestion des eaux pluviales est cruciale pour la durabilit√© des ouvrages.",
    "Astuce: La profondeur hors gel varie selon les r√©gions, adaptez vos calculs!",
    "Astuce: Les normes PMR garantissent l'accessibilit√© pour tous, ne les n√©gligez jamais.",
    "Astuce: Un plan de r√©colement pr√©cis est essentiel pour les futures interventions.",
    "Astuce: La couleur bleue indique g√©n√©ralement les r√©seaux d'eau potable.",
    "Astuce: La pente minimale pour un r√©seau d'eaux us√©es est de 1% pour assurer l'√©coulement.",
    "Astuce: Le g√©otextile s√©pare les couches de mat√©riaux et pr√©vient le m√©lange.",
    "Astuce: Les regards de visite permettent l'inspection et l'entretien des r√©seaux.",
    "Astuce: En cas de r√©seau non r√©pertori√©, stoppez les travaux et signalez-le imm√©diatement.",
    "Astuce: Pour le mini-jeu de tuyaux, chaque pi√®ce compte ! Planifiez votre chemin avant de placer.",
    "Astuce: La DICT est obligatoire avant tout travail √† proximit√© des r√©seaux existants.",
    "Astuce: Le PEHD est un excellent choix pour les canalisations de gaz gr√¢ce √† sa flexibilit√©.",
    "Astuce: Un PSS (Plan de S√©curit√© et de Sant√©) est vital pour la pr√©vention des accidents sur chantier.",
    "Astuce: Le r√¥le du g√©om√®tre-expert est fondamental pour l'implantation pr√©cise des ouvrages VRD.",
    "Astuce: Le fil d'eau est la r√©f√©rence altim√©trique pour la pose des canalisations gravitaires.",
    "Astuce: La signalisation de chantier prot√®ge les travailleurs et les usagers de la voie publique."
];
let currentTipIndex = 0;
let tipInterval = null;

// Utility functions
function showScreen(screenId) {
    document.querySelectorAll('.screen').forEach(screen => {
        screen.classList.remove('active');
        screen.classList.remove('bonus-active'); // Remove bonus class when switching screens
    });
    document.getElementById(screenId).classList.add('active');
}

function updateHeader() {
    document.getElementById('score').textContent = gameState.score;
    document.getElementById('timer').textContent = gameState.timeLeft;
    updateChronologicalProgressBar(); // Update progress bar on header update
    checkFinishGameButton(); // Check and update finish game button state
}

function updateChronologicalProgressBar() {
    const progressBarFill = document.getElementById('chronologicalProgressBarFill');
    // Use gameState.shuffledLevels.length for total levels
    const progressPercentage = (gameState.currentLevel / gameState.shuffledLevels.length) * 100;
    if (progressBarFill) { // Added null check
        progressBarFill.style.width = `${progressPercentage}%`;
        progressBarFill.textContent = `${gameState.currentLevel}/${gameState.shuffledLevels.length}`;
    }
}

function startTimer(duration) {
    clearInterval(gameState.timer);
    gameState.timeLeft = duration;
    updateHeader();
    const timerElement = document.querySelector('.timer-display');
    if (timerElement) { // Added null check
        timerElement.classList.remove('warning');
    }


    gameState.timer = setInterval(() => {
        gameState.timeLeft--;
        updateHeader();
        if (gameState.timeLeft <= 10 && gameState.timeLeft > 0) {
            if (timerElement) { // Added null check
                timerElement.classList.add('warning');
            }
            playSound('shortBeep');
        } else if (gameState.timeLeft <= 0) {
            clearInterval(gameState.timer);
            if (timerElement) { // Added null check
                timerElement.classList.remove('warning');
            }
            handleTimeout();
        }
    }, 1000);
}

function stopTimer() {
    clearInterval(gameState.timer);
    const timerElement = document.querySelector('.timer-display');
    if (timerElement) { // Added null check
        timerElement.classList.remove('warning');
    }
}

function playSound(type) {
    if (!gameState.musicEnabled) return;

    // Ensure synth is initialized
    if (!gameState.synth) {
        console.warn("Tone.PolySynth not initialized when playSound was called.");
        return;
    }

    switch (type) {
        case 'correct':
            gameState.synth.triggerAttackRelease("C5", "8n");
            break;
        case 'incorrect':
            gameState.synth.triggerAttackRelease("C3", "8n");
            break;
        case 'levelUp':
            const levelUpNotes = ["C4", "E4", "G4"];
            const levelUpDuration = "0.5s";
            levelUpNotes.forEach((note, index) => {
                // Play each note with a tiny offset to ensure they are distinct events
                // and avoid the "Invalid argument(s) to setValueAtTime" error with arrays.
                gameState.synth.triggerAttackRelease(note, Tone.context.currentTime + (index * 0.01), levelUpDuration);
            });
            break;
        case 'gameOver':
            const gameOverNotes = ["C3", "G2", "C2"];
            const gameOverDuration = "1s";
            gameOverNotes.forEach((note, index) => {
                gameState.synth.triggerAttackRelease(note, Tone.context.currentTime + (index * 0.01), gameOverDuration);
            });
            break;
        case 'shortBeep':
            gameState.synth.triggerAttackRelease("C4", "32n");
            break;
        case 'buttonClick':
            gameState.synth.triggerAttackRelease("C6", "64n");
            break;
        case 'bonusStart':
            gameState.synth.triggerAttackRelease(["C5", "E5", "G5"], "0.5"); // Upbeat chord
            break;
    }
}

function toggleMusic() {
    gameState.musicEnabled = !gameState.musicEnabled;
    const musicBtn = document.querySelector('.icon-music');
    if (musicBtn) { // Added null check
        if (gameState.musicEnabled) {
            musicBtn.classList.remove('muted');
            // Potentially start background music here if desired
        } else {
            musicBtn.classList.add('muted');
            // Stop background music here if playing
        }
    }
    playSound('buttonClick');
}

function showModal(modalId) {
    const modal = document.getElementById(modalId);
    if (modal) { // Added null check
        modal.classList.add('active');
    }
}

function closeModal(modalId) {
    const modal = document.getElementById(modalId);
    if (modal) { // Added null check
        modal.classList.remove('active');
    }
    gameState.pendingAction = null; // Clear any pending action when modal closes
}

function confirmAction() {
    if (gameState.pendingAction) {
        gameState.pendingAction();
        gameState.pendingAction = null;
    }
    closeModal('confirmModal');
}

function showConfirmModal(title, text, action) {
    const confirmTitle = document.getElementById('confirmTitle');
    const confirmText = document.getElementById('confirmText');
    if (confirmTitle) { // Added null check
        confirmTitle.textContent = title;
    }
    if (confirmText) { // Added null check
        confirmText.textContent = text;
    }
    gameState.pendingAction = action;
    showModal('confirmModal');
}

/**
 * Shuffles an array in place using the Fisher-Yates (Knuth) algorithm.
 * @param {Array} array The array to shuffle.
 */
function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]]; // Swap elements
    }
}

// Navigation and game functions
async function startGame() { // Make it async
    // Ensure audio context is started on user gesture
    if (Tone.context.state !== 'running') {
        await Tone.start(); // Await Tone.start()
    }
    // Initialize PolySynth for playing chords
    if (!gameState.synth) {
        gameState.synth = new Tone.PolySynth(Tone.Synth).toDestination();
    }

    gameState.currentLevel = 0;
    gameState.score = 0;
    gameState.answers = []; // Reset answers for new game
    // Reset skill scores for new game
    for (const skill in gameState.skillScores) {
        gameState.skillScores[skill] = { correct: 0, total: 0 };
    }

    // Shuffle levels for a new game
    gameState.shuffledLevels = [...originalLevels]; // Create a copy to shuffle
    shuffleArray(gameState.shuffledLevels);
    
    // Reset bonus state
    gameState.isBonusRound = false;
    gameState.bonusLevelData = null;
    gameState.bonusMultiplier = 1;

    const gameHeader = document.querySelector('.game-header');
    const controls = document.querySelector('.controls');
    const progressBar = document.querySelector('.progress-bar-chronological');
    const tipsBar = document.querySelector('.tips-bar');
    const gameCharacter = document.getElementById('gameCharacter');

    if (gameHeader) gameHeader.style.display = 'flex';
    if (controls) controls.style.display = 'flex';
    if (progressBar) progressBar.style.display = 'block'; // Show progress bar
    if (tipsBar) tipsBar.style.display = 'block'; // Show tips bar
    if (gameCharacter) gameCharacter.style.display = 'block'; // Show character

    startTipsMarquee(); // Start tips marquee
    displayCharacter('üöÄ', "Bienvenue, Projeteur ! Pr√™t √† relever le d√©fi ?", 3000); // Welcome message
    loadLevel();
    playSound('levelUp');
}

function loadLevel() {
    stopTimer();
    const levelToLoad = gameState.isBonusRound ? gameState.bonusLevelData : gameState.shuffledLevels[gameState.currentLevel];
    const quizScreen = document.getElementById('quizScreen');
    const gameScreen = document.getElementById('gameScreen');
    
    // Remove bonus-active class from all screens first
    document.querySelectorAll('.screen').forEach(screen => screen.classList.remove('bonus-active'));

    if (quizScreen) quizScreen.innerHTML = ''; // Clear previous content
    if (gameScreen) gameScreen.innerHTML = ''; // Clear previous content

    updateHeader(); // Update header including progress bar
    
    if (!levelToLoad) {
        endGame();
        return;
    }

    // Determine time limit based on level type
    let timeLimit;
    switch (levelToLoad.type) {
        case 'quiz':
            timeLimit = 30; // 30 seconds for quiz
            break;
        case 'material':
        case 'drag':
        case 'calc':
            timeLimit = 45; // 45 seconds for material, drag, calc
            break;
        case 'network':
        case 'pipe_connect': // New pipe connect game
            timeLimit = 60; // 60 seconds for network and pipe connect
            break;
        case 'scenario':
            timeLimit = 90; // 90 seconds for scenario
            break;
        case 'conflict_detection': // New bonus type
            timeLimit = 50; 
            break;
        case 'volume_calc': // New bonus type
            timeLimit = 40; 
            break;
        default:
            timeLimit = 30; // Default time
    }
    startTimer(timeLimit);

    // Render level based on type
    switch (levelToLoad.type) {
        case 'quiz':
            renderQuizLevel(levelToLoad);
            showScreen('quizScreen');
            break;
        case 'material':
            renderMaterialLevel(levelToLoad);
            showScreen('quizScreen'); // Using quizScreen for material selection
            break;
        case 'drag':
            renderDragLevel(levelToLoad);
            showScreen('gameScreen'); // Using gameScreen for drag and drop
            break;
        case 'calc':
            renderCalcLevel(levelToLoad);
            showScreen('quizScreen'); // Using quizScreen for calculation
            break;
        case 'network':
            renderNetworkLevel(levelToLoad);
            showScreen('gameScreen'); // Using gameScreen for network drawing
            break;
        case 'scenario':
            renderScenarioLevel(levelToLoad);
            showScreen('quizScreen'); // Using quizScreen for scenario
            break;
        case 'pipe_connect': // New mini-game
            renderPipeConnectLevel(levelToLoad);
            showScreen('gameScreen');
            break;
        case 'conflict_detection': // New bonus type
            renderConflictDetectionLevel(levelToLoad);
            showScreen('quizScreen');
            const quizScreenElement = document.getElementById('quizScreen');
            if (quizScreenElement) { // Added null check
                quizScreenElement.classList.add('bonus-active'); // Add bonus class
            }
            break;
        case 'volume_calc': // New bonus type
            renderVolumeCalcLevel(levelToLoad);
            showScreen('quizScreen');
            const quizScreenElement2 = document.getElementById('quizScreen');
            if (quizScreenElement2) { // Added null check
                quizScreenElement2.classList.add('bonus-active'); // Add bonus class
            }
            break;
        default:
            console.error("Unknown level type:", levelToLoad.type);
            // Fallback to a simple quiz or skip
            break;
    }
    applyFontSize(); // Apply font size after rendering new content
}

function startBonusRoundTransition() {
    playSound('bonusStart');
    displayCharacter('üåü', "NIVEAU BONUS ! Doublez vos points sur la prochaine question !", 3000); // Character announces bonus
    
    // Directly load the bonus level after a short delay for the character message
    setTimeout(() => {
        loadLevel(); // Load the bonus level
    }, 1000); // Short delay to allow character message to be seen/heard
}

function nextLevel() {
    stopTimer();

    // If the previous level was a bonus round, reset bonus state
    if (gameState.isBonusRound) {
        gameState.isBonusRound = false;
        gameState.bonusLevelData = null;
        // The bonusMultiplier is consumed by the checkAnswer function of the *next* question.
        // So we don't reset it here, it will be reset to 1 by the next regular loadLevel.
        gameState.currentLevel++; // Move to the next *regular* level
    } else {
        gameState.currentLevel++; // Move to the next *regular* level
        // Randomly decide if the *next* level should be a bonus level (20% chance)
        // Only trigger if there are still regular levels left
        if (Math.random() < 0.2 && gameState.currentLevel < gameState.shuffledLevels.length) {
            gameState.isBonusRound = true;
            gameState.bonusLevelData = bonusLevels[Math.floor(Math.random() * bonusLevels.length)];
            gameState.bonusMultiplier = 2; // Set multiplier for the *next* question
            startBonusRoundTransition(); // Start the bonus transition
            return; // Exit to prevent immediate loadLevel
        } else {
            gameState.bonusMultiplier = 1; // Ensure multiplier is 1 for regular levels
        }
    }

    if (gameState.currentLevel < gameState.shuffledLevels.length || gameState.isBonusRound) {
        loadLevel();
        playSound('levelUp');
    } else {
        endGame();
    }
}

function previousLevel() {
    if (gameState.currentLevel > 0) {
        showConfirmModal("Retour au niveau pr√©c√©dent", "Vous perdrez le score du niveau actuel. Continuer ?", () => {
            // If we were in a bonus round, we need to go back to the regular level before it
            if (gameState.isBonusRound) {
                gameState.isBonusRound = false;
                gameState.bonusLevelData = null;
                gameState.bonusMultiplier = 1; // Reset multiplier
                // currentLevel does not change if we were in a bonus round, as it's an interstitial level
            } else {
                gameState.currentLevel--;
            }
            
            // Remove the last answer record if going back
            if (gameState.answers.length > gameState.currentLevel) {
                const lastAnswer = gameState.answers.pop();
                // If the popped answer was correct, decrement correct count for that skill
                if (lastAnswer.isCorrect) {
                    gameState.skillScores[lastAnswer.type].correct--;
                }
                gameState.skillScores[lastAnswer.type].total--; // Always decrement total
            }
            loadLevel();
        });
    } else {
        // Optionally show a message that they are on the first level
    }
}

function confirmRestart() {
    showConfirmModal("Recommencer le jeu", "√ätes-vous s√ªr de vouloir recommencer du d√©but ? Votre score sera remis √† z√©ro.", startGame);
}

function showHelp() {
    showModal('helpModal');
    playSound('buttonClick');
}

function showSolution() {
    const pointsCost = 50;
    if (gameState.score < pointsCost) {
        displayCharacter('ü§î', `Vous n'avez pas assez de points pour cela ! Il vous faut ${pointsCost} points.`, 3000);
        playSound('incorrect');
        return;
    }

    showConfirmModal("Afficher la solution", `Afficher la solution vous co√ªtera ${pointsCost} points. Continuer ?`, () => {
        const level = gameState.isBonusRound ? gameState.bonusLevelData : gameState.shuffledLevels[gameState.currentLevel];
        const pointsLost = pointsCost;
        gameState.score = Math.max(0, gameState.score - pointsLost); // Ensure score doesn't go below zero
        updateHeader();
        
        // Record the answer as incorrect due to solution view
        gameState.answers.push({
            levelIndex: gameState.currentLevel,
            type: level.type,
            question: level.question,
            userAnswer: "Solution affich√©e",
            correctAnswer: getCorrectAnswerForLevel(level),
            isCorrect: false,
            pointsEarned: -pointsLost
        });
        // Update skill score for this type as incorrect
        gameState.skillScores[level.type].total++;
        // No increment for correct as solution was viewed

        // Implement solution display based on current level type
        if (level.type === 'quiz' || level.type === 'conflict_detection' || level.type === 'scenario') {
            const buttons = document.querySelectorAll('.answer-btn');
            buttons.forEach((btn) => {
                if (btn.dataset.isCorrect === 'true') { // Check the data attribute
                    btn.classList.add('correct');
                } else {
                    btn.classList.add('incorrect');
                }
                btn.disabled = true;
            });
        } else if (level.type === 'material') {
            const cards = document.querySelectorAll('.material-card');
            cards.forEach((card) => {
                if (card.dataset.isCorrect === 'true') { // Check the data attribute
                    card.classList.add('correct');
                } else {
                    card.classList.add('incorrect');
                }
                card.style.pointerEvents = 'none'; // Disable clicks
            });
        } else if (level.type === 'calc' || level.type === 'volume_calc') { // Added volume_calc
            const input = document.getElementById('elevationInput');
            const validateBtn = document.getElementById('validateCalcBtn');
            if (input) { // Added null check
                input.value = level.answer;
                input.style.borderColor = '#4caf50';
                input.style.boxShadow = '0 0 0 3px rgba(76, 175, 80, 0.2)';
            }
            if (validateBtn) { // Added null check
                validateBtn.disabled = true;
            }
        } else if (level.type === 'drag') {
            const dropZones = document.querySelectorAll('.drop-zone');
            const correctOrder = level.items; // Use items from the current shuffled level
            dropZones.forEach((zone, index) => {
                const droppedItem = zone.querySelector('.draggable');
                if (droppedItem) droppedItem.remove(); // Remove existing items
                
                const correctItem = document.createElement('div');
                correctItem.classList.add('draggable', 'correct');
                correctItem.textContent = correctOrder[index];
                correctItem.draggable = false;
                zone.appendChild(correctItem);
                zone.style.borderColor = '#4caf50';
                zone.style.borderStyle = 'solid';
            });
            const gameScreenBtn = document.getElementById('gameScreen').querySelector('.btn');
            if (gameScreenBtn) { // Added null check
                gameScreenBtn.disabled = true;
            }
        } else if (level.type === 'network') {
            // For network, display the correct path visually
            const drawnLinesGroup = document.getElementById('drawnLines');
            if (drawnLinesGroup) { // Added null check
                drawnLinesGroup.innerHTML = ''; // Clear any user-drawn lines
            }

            // Use the nodes from the level data
            const nodes = level.nodes;
            // Use the correctPath from the level data
            const correctPath = level.correctPath; 

            if (correctPath && correctPath.length === 2) { // Added null check for correctPath
                const startNode = nodes.find(n => n.id === correctPath[0]);
                const endNode = nodes.find(n => n.id === correctPath[1]);

                if (startNode && endNode && drawnLinesGroup) { // Added null check for drawnLinesGroup
                    const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                    line.setAttribute('x1', startNode.cx);
                    line.setAttribute('y1', startNode.cy);
                    line.setAttribute('x2', endNode.cx);
                    line.setAttribute('y2', endNode.cy);
                    line.setAttribute('stroke', '#4caf50'); // Green for correct
                    line.setAttribute('stroke-width', '4');
                    line.setAttribute('marker-end', 'url(#arrow)');
                    drawnLinesGroup.appendChild(line);
                }
            }
            const gameScreenBtn = document.getElementById('gameScreen').querySelector('.btn');
            if (gameScreenBtn) { // Added null check
                gameScreenBtn.disabled = true;
            }
        } else if (level.type === 'pipe_connect') {
            // For pipe connect, display a visual representation of a possible correct solution
            const pipeGridContainer = document.getElementById('pipeGridContainer');
            if (pipeGridContainer) {
                // Clear the grid
                pipeGridContainer.innerHTML = '';
                pipeGridContainer.style.gridTemplateColumns = `repeat(${level.gridSize}, 100px)`;

                // Define a simple correct path for demonstration
                const solutionPath = [
                    {r:0, c:0, type:'start', rotation:0},
                    {r:0, c:1, type:'straight', rotation:90},
                    {r:0, c:2, type:'straight', rotation:90},
                    {r:0, c:3, type:'bend', rotation:270},
                    {r:1, c:3, type:'straight', rotation:0},
                    {r:2, c:3, type:'straight', rotation:0},
                    {r:3, c:3, type:'end', rotation:0}
                ];

                const gridCells = Array(level.gridSize).fill(0).map((_, r) =>
                    Array(level.gridSize).fill(0).map((_, c) => {
                        const cell = document.createElement('div');
                        cell.classList.add('grid-cell');
                        const solutionPiece = solutionPath.find(p => p.r === r && p.c === c);
                        if (solutionPiece) {
                            if (solutionPiece.type === 'start') {
                                cell.classList.add('start-node');
                                cell.textContent = 'D√©part';
                            } else if (solutionPiece.type === 'end') {
                                cell.classList.add('end-node');
                                cell.textContent = 'Arriv√©e';
                            } else {
                                const pipeDiv = document.createElement('div');
                                pipeDiv.classList.add('pipe-piece-placed', 'correct-path');
                                pipeDiv.innerHTML = getPipeSVG(solutionPiece.type);
                                pipeDiv.style.transform = `rotate(${solutionPiece.rotation}deg)`;
                                cell.appendChild(pipeDiv);
                            }
                        }
                        pipeGridContainer.appendChild(cell);
                        return cell;
                    })
                );
            }
            const validateButton = document.getElementById('validatePipeConnectBtn');
            if (validateButton) validateButton.disabled = true;
        }

        setTimeout(nextLevel, 3000); // Automatically move to next level after showing solution
        playSound('incorrect'); // Play a sound indicating score loss
        displayCharacter('üí°', "Pas de souci, l'apprentissage continue !", 3000); // Solution message
    });
}

function skipLevel() {
    const pointsCost = 10;
    if (gameState.score < pointsCost) {
        displayCharacter('ü§î', `Vous n'avez pas assez de points pour cela ! Il vous faut ${pointsCost} points.`, 3000);
        playSound('incorrect');
        return;
    }

    showConfirmModal("Passer le niveau", `Passer ce niveau vous co√ªtera ${pointsCost} points. Continuer ?`, () => {
        const level = gameState.isBonusRound ? gameState.bonusLevelData : gameState.shuffledLevels[gameState.currentLevel];
        const pointsLost = pointsCost;
        gameState.score = Math.max(0, gameState.score + pointsLost);
        updateHeader();
        
        // Record the answer as skipped
        gameState.answers.push({
            levelIndex: gameState.currentLevel,
            type: level.type,
            question: level.question,
            userAnswer: "Niveau pass√©",
            correctAnswer: getCorrectAnswerForLevel(level),
            isCorrect: false,
            pointsEarned: -pointsLost
        });
        // Update skill score for this type as incorrect (or not attempted)
        gameState.skillScores[level.type].total++;

        nextLevel();
        playSound('incorrect'); // Play a sound indicating score loss
        displayCharacter('‚è≠Ô∏è', "Parfois, il faut savoir passer √† autre chose.", 3000); // Skip message
    });
}

function handleTimeout() {
    const level = gameState.isBonusRound ? gameState.bonusLevelData : gameState.shuffledLevels[gameState.currentLevel];
    const pointsLost = 20;
    gameState.score = Math.max(0, gameState.score + pointsLost); // Penalty for timeout
    updateHeader();
    
    // Record the answer as timeout
    gameState.answers.push({
        levelIndex: gameState.currentLevel,
        type: level.type,
        question: level.question,
        userAnswer: "Temps √©coul√©",
        correctAnswer: getCorrectAnswerForLevel(level),
        isCorrect: false,
        pointsEarned: pointsLost // This should be negative for penalty
    });
    // Update skill score for this type as incorrect
    gameState.skillScores[level.type].total++;

    // Visually indicate timeout, e.g., flash timer red
    const timerElement = document.querySelector('.timer-display');
    if (timerElement) { // Added null check
        timerElement.classList.add('warning');
    }
    playSound('incorrect');
    displayCharacter('‚è∞', "Oups, le temps est √©coul√© ! Plus vite la prochaine fois.", 3000); // Timeout message
    setTimeout(() => {
        if (timerElement) { // Added null check
            timerElement.classList.remove('warning');
        }
        nextLevel();
    }, 1500); // Wait a bit before moving to next level
}

function getCorrectAnswerForLevel(level) {
    // For levels that have been shuffled, we need to refer to the original level
    // to get the correct answer's text/value, as the index might have changed.
    // For bonus levels, they are not in originalLevels, so we directly use the level object.
    const sourceLevel = originalLevels.find(l => l.question === level.question) || bonusLevels.find(l => l.question === level.question) || level;

    switch (sourceLevel.type) {
        case 'quiz':
            return sourceLevel.answers[sourceLevel.correct];
        case 'material':
            return sourceLevel.materials[sourceLevel.correct];
        case 'drag':
            return sourceLevel.items.join(' > ');
        case 'calc':
            // For calc, round to 2 decimal places for consistency
            return parseFloat(sourceLevel.answer).toFixed(2);
        case 'network':
            // Use the correctPath from the sourceLevel
            const nodes = sourceLevel.nodes;
            const correctPathIds = sourceLevel.correctPath; 
            const correctPathNames = correctPathIds.map(id => nodes.find(n => n.id === id)?.id || id);
            return `Connecter: ${correctPathNames.join(' -> ')}`;
        case 'scenario':
            return sourceLevel.actions[sourceLevel.correct];
        case 'pipe_connect':
            return sourceLevel.correctSolutionDescription; // Use the descriptive solution
        case 'conflict_detection': // New bonus type
            return sourceLevel.options[sourceLevel.correct];
        case 'volume_calc': // New bonus type
            // For volume_calc, round to 2 decimal places for consistency
            return parseFloat(sourceLevel.answer).toFixed(2);
        default:
            return "N/A";
    }
}

function endGame() {
    stopTimer();
    stopTipsMarquee(); // Stop tips marquee
    clearInterval(gameState.characterTipInterval); // Stop character tip interval

    // Hide game elements
    const gameHeader = document.querySelector('.game-header');
    const controls = document.querySelector('.controls');
    const progressBar = document.querySelector('.progress-bar-chronological');
    const tipsBar = document.querySelector('.tips-bar');
    const gameCharacter = document.getElementById('gameCharacter');
    const speechBubble = document.getElementById('speechBubble');

    if (gameHeader) gameHeader.style.display = 'none';
    if (controls) controls.style.display = 'none';
    if (progressBar) progressBar.style.display = 'none'; // Hide progress bar
    if (tipsBar) tipsBar.style.display = 'none'; // Hide tips bar
    if (gameCharacter) gameCharacter.style.display = 'none'; // Hide character
    if (speechBubble) speechBubble.style.display = 'none'; // Hide speech bubble

    showScreen('finalScreen');
    const finalScreen = document.getElementById('finalScreen');
    if (finalScreen) { // Added null check
        finalScreen.innerHTML = `
            <div class="logo-icon" style="font-size: 5rem; width: 100px; height: 100px; margin-bottom: 30px;">üèÜ</div>
            <h1>Aventure Termin√©e !</h1>
            <h2 style="font-size: 1.8rem; color: #333; margin-bottom: 40px;">F√©licitations, Projeteur VRD !</h2>
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-number">${gameState.score}</div>
                    <div class="stat-label">Points Totaux</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${gameState.currentLevel} / ${originalLevels.length}</div>
                    <div class="stat-label">Niveaux Compl√©t√©s</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${(gameState.currentLevel > 0 ? (gameState.answers.filter(a => a.isCorrect).length / gameState.currentLevel) * 100 : 0).toFixed(0)}%</div>
                    <div class="stat-label">Pr√©cision Moyenne</div>
                </div>
            </div>
            <button class="btn" onclick="startGame()">Rejouer</button>
            <button class="btn btn-secondary mt-4" onclick="showCorrectionReport()">Voir la correction</button>
        `;
    }
    triggerConfetti();
    playSound('gameOver');
    displayCharacter('üéì', "Bravo pour cette belle performance ! Revenez vite pour de nouveaux d√©fis.", 5000); // End game message
}

function generateCorrectionReport() {
    let reportHtml = '<h3>Performance par Comp√©tence :</h3><ul>';
    for (const skill in gameState.skillScores) {
        const { correct, total } = gameState.skillScores[skill];
        const percentage = total > 0 ? ((correct / total) * 100).toFixed(0) : 0;
        reportHtml += `<li><strong>${skill.charAt(0).toUpperCase() + skill.slice(1)}</strong>: ${correct} / ${total} (${percentage}%)</li>`;
    }
    reportHtml += '</ul><br/><h3>D√©tail des R√©ponses :</h3><ol>';

    gameState.answers.forEach((answer, index) => {
        const status = answer.isCorrect ? '‚úÖ Correct' : '‚ùå Incorrect';
        const points = answer.pointsEarned >= 0 ? `(+${answer.pointsEarned} pts)` : `(${answer.pointsEarned} pts)`;
        reportHtml += `
            <li>
                <strong>Niveau ${answer.levelIndex + 1} (${answer.type})</strong>: ${answer.question}<br/>
                Votre r√©ponse: <em>${answer.userAnswer}</em><br/>
                R√©ponse correcte: <em>${answer.correctAnswer}</em><br/>
                Statut: ${status} ${points}
            </li><br/>
        `;
    });
    reportHtml += '</ol>';
    return reportHtml;
}

function showCorrectionReport() {
    const reportContent = document.getElementById('correctionReportContent');
    if (reportContent) { // Added null check
        reportContent.innerHTML = generateCorrectionReport();
    }
    showModal('correctionModal');
}

function copyCorrectionToClipboard() {
    const reportContent = document.getElementById('correctionReportContent');
    let reportText = '';
    if (reportContent) { // Added null check
        reportText = reportContent.innerText;
    }
    
    const textArea = document.createElement("textarea");
    textArea.value = reportText;
    document.body.appendChild(textArea);
    textArea.select();
    try {
        // Use document.execCommand('copy') for better compatibility in iframes
        const successful = document.execCommand('copy');
        const msg = successful ? 'Copi√© dans le presse-papiers !' : '√âchec de la copie.';
        // Replace alert with a custom message box if desired
        const currentAlert = document.getElementById('customAlert');
        if (currentAlert) currentAlert.remove(); // Remove previous alert

        const customAlert = document.createElement('div');
        customAlert.id = 'customAlert';
        customAlert.style.cssText = `
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: #333; color: white; padding: 15px 30px; border-radius: 10px;
            z-index: 1001; opacity: 0; transition: opacity 0.3s ease-in-out;
            font-size: 1.1rem; text-align: center;
        `;
        customAlert.textContent = msg;
        document.body.appendChild(customAlert);

        setTimeout(() => {
            customAlert.style.opacity = '1';
        }, 10); // Small delay to trigger transition

        setTimeout(() => {
            customAlert.style.opacity = '0';
            customAlert.addEventListener('transitionend', () => customAlert.remove());
        }, 2000); // Message disappears after 2 seconds

    } catch (err) {
        // Fallback for older browsers or if execCommand fails
        alert('Impossible de copier : ' + err);
    }
    document.body.removeChild(textArea);
}

// Render specific levels

// Quiz Level
function renderQuizLevel(level) {
    const quizScreen = document.getElementById('quizScreen');
    if (!quizScreen) return; // Added null check

    // Create a mutable copy of answers with their correct status
    const answersWithStatus = level.answers.map((answer, index) => ({
        text: answer,
        isCorrect: index === level.correct
    }));
    shuffleArray(answersWithStatus); // Shuffle the answers

    quizScreen.innerHTML = `
        <h2 id="questionText">${level.question}</h2>
        <div class="answer-grid">
            ${answersWithStatus.map((answer, index) => `
                <button class="answer-btn" data-original-font-size="20" 
                        data-is-correct="${answer.isCorrect}"
                        onclick="checkQuizAnswer(${index}, ${answer.isCorrect}, ${level.points}, '${answer.text.replace(/'/g, "\\'")}', '${level.type}')">
                    ${answer.text}
                </button>
            `).join('')}
        </div>
    `;
}

// Modified checkQuizAnswer to use isCorrect flag and user's answer text
function checkQuizAnswer(selectedIndex, isCorrectFlag, points, userAnswerText, levelType) {
    stopTimer();
    const buttons = document.querySelectorAll('.answer-btn');
    buttons.forEach((btn, index) => {
        btn.disabled = true;
        // The correct button is the one with the isCorrectFlag true
        if (btn.getAttribute('onclick') && btn.getAttribute('onclick').includes('true')) { // Added null check for getAttribute
            btn.classList.add('correct');
        } else if (index === selectedIndex) {
            btn.classList.add('incorrect');
        }
    });

    const level = gameState.isBonusRound ? gameState.bonusLevelData : gameState.shuffledLevels[gameState.currentLevel];
    let pointsEarned = 0;
    let basePoints = points;

    if (isCorrectFlag) {
        pointsEarned = basePoints;
        if (!gameState.isBonusRound) { // Only apply bonus multiplier for regular questions
            pointsEarned *= gameState.bonusMultiplier; 
        }
        gameState.score += pointsEarned;
        playSound('correct');
        if (gameState.bonusMultiplier > 1 && !gameState.isBonusRound) {
             displayCharacter('üéâ', "BONUS ACTIV√â ! Points doubl√©s !", 2000);
        } else {
            displayCharacter('üòä', "Super ! Bonne r√©ponse !", 2000); // Correct message
        }
    } else {
        pointsEarned = -Math.floor(basePoints / 5); // Small penalty for incorrect
        gameState.score = Math.max(0, gameState.score + pointsEarned);
        playSound('incorrect');
        displayCharacter('üòü', "Dommage, ce n'est pas √ßa. Mais continuez d'apprendre !", 2000); // Incorrect message
    }
    
    // Record answer
    gameState.answers.push({
        levelIndex: gameState.currentLevel,
        type: level.type, // Use level.type directly
        question: level.question,
        userAnswer: userAnswerText, // Use the actual text the user clicked
        correctAnswer: getCorrectAnswerForLevel(level), // Get original correct answer
        isCorrect: isCorrectFlag,
        pointsEarned: pointsEarned
    });
    // Update skill score
    gameState.skillScores[level.type].total++;
    if (isCorrectFlag) {
        gameState.skillScores[level.type].correct++;
    }
    
    // Reset bonus multiplier after it's used for a regular question
    if (!gameState.isBonusRound) {
        gameState.bonusMultiplier = 1;
    }

    updateHeader();
    setTimeout(nextLevel, 1500);
}

// Material Level
function renderMaterialLevel(level) {
    const quizScreen = document.getElementById('quizScreen');
    if (!quizScreen) return; // Added null check

    // Create a mutable copy of materials with their correct status and icons
    const materialsWithStatus = level.materials.map((material, index) => ({
        text: material,
        icon: level.icons[index],
        isCorrect: index === level.correct
    }));
    shuffleArray(materialsWithStatus); // Shuffle the materials

    quizScreen.innerHTML = `
        <h2 id="questionText">${level.question}</h2>
        <div class="material-grid">
            ${materialsWithStatus.map((material, index) => `
                <div class="material-card" 
                     data-is-correct="${material.isCorrect}"
                     onclick="checkMaterialAnswer(${index}, ${material.isCorrect}, ${level.points}, '${material.text.replace(/'/g, "\\'")}', '${level.type}')">
                    <span class="material-icon">${material.icon}</span>
                    <span class="material-text">${material.text}</span>
                </div>
            `).join('')}
        </div>
    `;
}

// Modified checkMaterialAnswer to use isCorrect flag and user's answer text
function checkMaterialAnswer(selectedIndex, isCorrectFlag, points, userAnswerText, levelType) {
    stopTimer();
    const cards = document.querySelectorAll('.material-card');
    cards.forEach((card, index) => {
        card.style.pointerEvents = 'none'; // Disable further clicks
        // Find the correct card based on the isCorrectFlag in its onclick attribute
        if (card.getAttribute('onclick') && card.getAttribute('onclick').includes('true')) { // Added null check for getAttribute
            card.classList.add('correct');
        } else if (index === selectedIndex) {
            card.classList.add('incorrect');
        }
    });

    const level = gameState.isBonusRound ? gameState.bonusLevelData : gameState.shuffledLevels[gameState.currentLevel];
    let pointsEarned = 0;
    let basePoints = points;

    if (isCorrectFlag) {
        pointsEarned = basePoints;
        if (!gameState.isBonusRound) { // Only apply bonus multiplier for regular questions
            pointsEarned *= gameState.bonusMultiplier; 
        }
        gameState.score += pointsEarned;
        playSound('correct');
        if (gameState.bonusMultiplier > 1 && !gameState.isBonusRound) {
             displayCharacter('üéâ', "BONUS ACTIV√â ! Points doubl√©s !", 2000);
        } else {
            displayCharacter('üòä', "Exact ! Vous avez l'≈ìil pour les mat√©riaux !", 2000); // Correct message
        }
    } else {
        pointsEarned = -Math.floor(basePoints / 5);
        gameState.score = Math.max(0, gameState.score + pointsEarned);
        playSound('incorrect');
        displayCharacter('üòü', "Ce n'est pas le bon choix. R√©fl√©chissez bien aux propri√©t√©s !", 2000); // Incorrect message
    }

    // Record answer
    gameState.answers.push({
        levelIndex: gameState.currentLevel,
        type: level.type,
        question: level.question,
        userAnswer: userAnswerText,
        correctAnswer: getCorrectAnswerForLevel(level),
        isCorrect: isCorrectFlag,
        pointsEarned: pointsEarned
    });
    // Update skill score
    gameState.skillScores[level.type].total++;
    if (isCorrectFlag) {
        gameState.skillScores[level.type].correct++;
    }

    // Reset bonus multiplier after it's used for a regular question
    if (!gameState.isBonusRound) {
        gameState.bonusMultiplier = 1;
    }

    updateHeader();
    setTimeout(nextLevel, 1500);
}

// Drag and Drop Level
function renderDragLevel(level) {
    const gameScreen = document.getElementById('gameScreen');
    if (!gameScreen) return; // Added null check

    const shuffledItems = [...level.items].sort(() => Math.random() - 0.5); // Shuffle for challenge
    const dropZones = level.items.map((item, index) => `<div class="drop-zone" data-index="${index}"><span class="drop-zone-text">D√©posez ici</span></div>`).join('');

    gameScreen.innerHTML = `
        <h2 id="questionText">${level.question}</h2>
        <div style="display: flex; flex-wrap: wrap; justify-content: center; margin-bottom: 30px;">
            ${shuffledItems.map((item, index) => `<div class="draggable" draggable="true" data-item="${item}"><span class="draggable-text">${item}</span></div>`).join('')}
        </div>
        <div style="width: 100%; max-width: 600px;">
            ${dropZones}
        </div>
        <div class="button-center-align"> <!-- Changed to button-center-align -->
            <button class="btn" onclick="checkDragAnswer('${level.items.join(',')}', ${level.points}, '${level.type}')">Valider l'assemblage</button>
        </div>
    `;

    addDragAndDropListeners();
}

function addDragAndDropListeners() {
    const draggables = document.querySelectorAll('.draggable');
    const dropZones = document.querySelectorAll('.drop-zone');
    let draggedItem = null;

    draggables.forEach(draggable => {
        draggable.addEventListener('dragstart', (e) => {
            draggedItem = draggable;
            e.dataTransfer.setData('text/plain', draggable.dataset.item);
            setTimeout(() => draggable.classList.add('hidden'), 0); // Hide original
        });

        draggable.addEventListener('dragend', () => {
            if (draggedItem) { // Added null check
                draggedItem.classList.remove('hidden');
            }
            draggedItem = null;
        });
    });

    dropZones.forEach(zone => {
        zone.addEventListener('dragover', (e) => {
            e.preventDefault(); // Allow drop
            zone.classList.add('hover');
        });

        zone.addEventListener('dragleave', () => {
            zone.classList.remove('hover');
        });

        zone.addEventListener('drop', (e) => {
            e.preventDefault();
            zone.classList.remove('hover');
            if (zone.children.length === 0 || (zone.children.length === 1 && zone.children[0].classList.contains('drop-zone-text'))) { // Only allow one item per zone, or replace placeholder text
                const data = e.dataTransfer.getData('text/plain');
                const item = document.querySelector(`.draggable[data-item="${data}"]`);
                if (item) {
                    // Remove placeholder text if it exists
                    const placeholder = zone.querySelector('.drop-zone-text');
                    if (placeholder) placeholder.remove();

                    zone.appendChild(item);
                    item.style.position = 'static'; // Reset position if it was absolute
                    item.style.margin = '0'; // Reset margin
                    zone.classList.add('filled');
                }
            }
        });
    });
}

function checkDragAnswer(correctOrderString, points, levelType) {
    stopTimer();
    const correctOrder = correctOrderString.split(',');
    const dropZones = document.querySelectorAll('.drop-zone');
    let correctCount = 0;
    let allCorrect = true;
    let userAnswerArray = [];

    dropZones.forEach((zone, index) => {
        const droppedItem = zone.querySelector('.draggable');
        if (droppedItem) {
            userAnswerArray.push(droppedItem.dataset.item);
            if (droppedItem.dataset.item === correctOrder[index]) {
                droppedItem.classList.add('correct');
                zone.style.borderColor = '#4caf50';
                correctCount++;
            } else {
                droppedItem.classList.add('incorrect');
                zone.style.borderColor = '#f44336';
                allCorrect = false;
            }
        } else {
            userAnswerArray.push("Vide"); // Indicate an empty drop zone
            zone.style.borderColor = '#f44336';
            allCorrect = false;
        }
        zone.style.borderStyle = 'solid'; // Make border solid for feedback
    });

    const level = gameState.isBonusRound ? gameState.bonusLevelData : gameState.shuffledLevels[gameState.currentLevel];
    let pointsEarned = 0;
    let basePoints = points;

    if (allCorrect) {
        pointsEarned = basePoints;
        if (!gameState.isBonusRound) { // Only apply bonus multiplier for regular questions
            pointsEarned *= gameState.bonusMultiplier; 
        }
        gameState.score += pointsEarned;
        playSound('correct');
        if (gameState.bonusMultiplier > 1 && !gameState.isBonusRound) {
             displayCharacter('üéâ', "BONUS ACTIV√â ! Points doubl√©s !", 2000);
        } else {
            displayCharacter('üòä', "Parfait ! L'assemblage est correct !", 2000); // Correct message
        }
    } else {
        pointsEarned = -Math.floor(basePoints / 2); // Larger penalty for drag/drop
        gameState.score = Math.max(0, gameState.score + pointsEarned);
        playSound('incorrect');
        displayCharacter('üòü', "Revoyez l'ordre des couches, c'est important !", 2000); // Incorrect message
    }

    // Record answer
    gameState.answers.push({
        levelIndex: gameState.currentLevel,
        type: level.type,
        question: level.question,
        userAnswer: userAnswerArray.join(' > '),
        correctAnswer: correctOrder.join(' > '),
        isCorrect: allCorrect,
        pointsEarned: pointsEarned
    });
    // Update skill score
    gameState.skillScores[level.type].total++;
    if (allCorrect) {
        gameState.skillScores[level.type].correct++;
    }

    // Reset bonus multiplier after it's used for a regular question
    if (!gameState.isBonusRound) {
        gameState.bonusMultiplier = 1;
    }

    updateHeader();
    document.querySelectorAll('.draggable').forEach(item => item.draggable = false); // Disable further dragging
    const gameScreenBtn = document.getElementById('gameScreen').querySelector('.btn');
    if (gameScreenBtn) { // Added null check
        gameScreenBtn.disabled = true;
    }
    setTimeout(nextLevel, 2000);
}

// Calculation Level
function renderCalcLevel(level) {
    const quizScreen = document.getElementById('quizScreen');
    if (!quizScreen) return; // Added null check

    quizScreen.innerHTML = `
        <h2 id="questionText">${level.question}</h2>
        <input type="number" id="elevationInput" class="elevation-input" placeholder="Entrez votre r√©ponse" step="0.01">
        <div class="button-center-align"> <!-- Changed to button-center-align -->
            <button class="btn" id="validateCalcBtn" onclick="checkCalcAnswer(${level.answer}, ${level.points}, '${level.type}')">Valider</button>
        </div>
    `;
}

function checkCalcAnswer(correctAnswer, points, levelType) {
    stopTimer();
    const input = document.getElementById('elevationInput');
    const validateBtn = document.getElementById('validateCalcBtn');

    let userAnswer = null;
    if (input) { // Added null check
        userAnswer = parseFloat(input.value);
        input.disabled = true;
    }
    if (validateBtn) { // Added null check
        validateBtn.disabled = true;
    }

    const tolerance = 0.01; // Allow for small floating point errors

    const level = gameState.isBonusRound ? gameState.bonusLevelData : gameState.shuffledLevels[gameState.currentLevel];
    let isCorrect = false;
    let pointsEarned = 0;
    let basePoints = points;

    if (userAnswer !== null && Math.abs(userAnswer - correctAnswer) < tolerance) { // Added null check for userAnswer
        isCorrect = true;
        pointsEarned = basePoints;
        if (!gameState.isBonusRound) { // Only apply bonus multiplier for regular questions
            pointsEarned *= gameState.bonusMultiplier; 
        }
        gameState.score += pointsEarned;
        playSound('correct');
        if (gameState.bonusMultiplier > 1 && !gameState.isBonusRound) {
             displayCharacter('üéâ', "BONUS ACTIV√â ! Points doubl√©s !", 2000);
        } else {
            displayCharacter('üòä', "Calcul parfait ! Vous ma√Ætrisez les altitudes !", 2000); // Correct message
        }
    } else {
        pointsEarned = -Math.floor(basePoints / 3);
        if (input) { // Added null check
            input.style.borderColor = '#f44336';
            input.style.boxShadow = '0 0 0 3px rgba(244, 67, 54, 0.2)';
        }
        gameState.score = Math.max(0, gameState.score + pointsEarned);
        playSound('incorrect');
        displayCharacter('üòü', "V√©rifiez vos calculs, la pr√©cision est cl√© en VRD !", 2000); // Incorrect message
    }

    // Record answer
    gameState.answers.push({
        levelIndex: gameState.currentLevel,
        type: level.type,
        question: level.question,
        userAnswer: input ? input.value : "N/A", // Added null check
        correctAnswer: correctAnswer.toFixed(2), // Format correct answer for display
        isCorrect: isCorrect,
        pointsEarned: pointsEarned
    });
    // Update skill score
    gameState.skillScores[level.type].total++;
    if (isCorrect) {
        gameState.skillScores[level.type].correct++;
    }

    // Reset bonus multiplier after it's used for a regular question
    if (!gameState.isBonusRound) {
        gameState.bonusMultiplier = 1;
    }

    updateHeader();
    setTimeout(nextLevel, 1500);
}

// Network Level
function renderNetworkLevel(level) {
    const gameScreen = document.getElementById('gameScreen');
    if (!gameScreen) return; // Added null check

    // Use the nodes from the level data
    const nodes = level.nodes;
    // Use the correctPath from the level data
    const correctPathForRender = level.correctPath || []; // Fallback if not defined

    gameScreen.innerHTML = `
        <h2 id="questionText">${level.question}</h2>
        <svg class="network-svg" viewBox="0 0 500 500">
            <defs>
                <marker id="arrow" markerWidth="10" markerHeight="10" refX="8" refY="3" orient="auto" markerUnits="strokeWidth">
                    <path d="M0,0 L0,6 L9,3 z" fill="#667eea" />
                </marker>
            </defs>
            ${nodes.map(node => `
                <circle class="network-node" id="${node.id}" cx="${node.cx}" cy="${node.cy}" r="15" fill="${node.color}" stroke="white" stroke-width="3" />
            `).join('')}
            <g id="drawnLines"></g>
        </svg>
        <div class="button-center-align"> <!-- Changed to button-center-align -->
            <button class="btn" onclick="checkNetworkAnswer(${level.points}, '${correctPathForRender.join(',')}', '${JSON.stringify(nodes).replace(/'/g, "\\'").replace(/"/g, '&quot;')}', '${level.type}')">Valider le r√©seau</button>
        </div>
    `;

    addNetworkListeners(nodes);
}

let networkSelectedNodes = [];
let networkDrawing = false;
let networkSvg = null;
let currentLine = null;

function addNetworkListeners(nodes) {
    networkSvg = document.querySelector('.network-svg');
    const drawnLinesGroup = document.getElementById('drawnLines');

    if (!networkSvg || !drawnLinesGroup) return; // Added null checks

    networkSvg.addEventListener('mousedown', (e) => {
        const target = e.target;
        if (target.classList.contains('network-node')) {
            networkDrawing = true;
            networkSelectedNodes = [target.id];
            
            // Start drawing a temporary line
            currentLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
            const startNode = nodes.find(n => n.id === target.id);
            if (startNode) { // Added null check
                currentLine.setAttribute('x1', startNode.cx);
                currentLine.setAttribute('y1', startNode.cy);
            }
            currentLine.setAttribute('x2', e.offsetX);
            currentLine.setAttribute('y2', e.offsetY);
            currentLine.setAttribute('stroke', '#667eea');
            currentLine.setAttribute('stroke-width', '4');
            currentLine.setAttribute('stroke-dasharray', '5,5');
            drawnLinesGroup.appendChild(currentLine);
        }
    });

    networkSvg.addEventListener('mousemove', (e) => {
        if (networkDrawing && currentLine) {
            currentLine.setAttribute('x2', e.offsetX);
            currentLine.setAttribute('y2', e.offsetY);
        }
    });

    networkSvg.addEventListener('mouseup', (e) => {
        if (networkDrawing) {
            networkDrawing = false;
            const target = e.target;
            if (target.classList.contains('network-node') && networkSelectedNodes[0] !== target.id) {
                networkSelectedNodes.push(target.id);
                const startNode = nodes.find(n => n.id === networkSelectedNodes[0]);
                const endNode = nodes.find(n => n.id === networkSelectedNodes[1]);

                // Finalize the line
                if (currentLine && endNode) { // Added null check for currentLine and endNode
                    currentLine.setAttribute('x2', endNode.cx);
                    currentLine.setAttribute('y2', endNode.cy);
                    currentLine.setAttribute('marker-end', 'url(#arrow)'); // Add arrow to the end
                }

                // Reset for next line
                networkSelectedNodes = [];
                currentLine = null;
            } else {
                // If not dropped on another node, remove the temporary line
                if (currentLine) {
                    currentLine.remove();
                }
            }
        }
    });
}


function checkNetworkAnswer(points, correctPathString, nodesJsonString, levelType) {
    stopTimer();
    const correctPath = correctPathString.split(',');
    const drawnLines = document.querySelectorAll('#drawnLines line');
    const nodes = JSON.parse(nodesJsonString.replace(/&quot;/g, '"')); // Parse nodes back from JSON string

    let allCorrect = true;
    let userAnswerPath = [];

    if (drawnLines.length === 1) {
        const line = drawnLines[0];
        const x1 = parseFloat(line.getAttribute('x1'));
        const y1 = parseFloat(line.getAttribute('y1'));
        const x2 = parseFloat(line.getAttribute('x2'));
        const y2 = parseFloat(line.getAttribute('y2'));
        
        let lineStartNodeId = null;
        let lineEndNodeId = null;

        nodes.forEach(node => {
            const nodeCx = node.cx;
            const nodeCy = node.cy;
            const nodeR = 15; // Hardcoded radius from renderNetworkLevel

            // Calculate distance from line endpoints to node center
            const distStartToNode = Math.sqrt(Math.pow(x1 - nodeCx, 2) + Math.pow(y1 - nodeCy, 2));
            const distEndToNode = Math.sqrt(Math.pow(x2 - nodeCx, 2) + Math.pow(y2 - nodeCy, 2));

            if (distStartToNode <= nodeR + 5) { // Add a small tolerance
                lineStartNodeId = node.id;
            }
            if (distEndToNode <= nodeR + 5) { // Add a small tolerance
                lineEndNodeId = node.id;
            }
        });

        if (lineStartNodeId && lineEndNodeId) {
            userAnswerPath.push(lineStartNodeId, lineEndNodeId);
            // Check if the connected nodes match the correct path (order doesn't matter for this simple check)
            const sortedUserPath = [...userAnswerPath].sort().join(',');
            const sortedCorrectPath = [...correctPath].sort().join(',');

            if (sortedUserPath === sortedCorrectPath) {
                allCorrect = true;
            } else {
                allCorrect = false;
            }
        } else {
            allCorrect = false; // Line endpoints not connected to valid nodes
        }
    } else {
        allCorrect = false; // Not exactly one line drawn
    }

    const level = gameState.isBonusRound ? gameState.bonusLevelData : gameState.shuffledLevels[gameState.currentLevel];
    let pointsEarned = 0;
    let basePoints = points;

    if (allCorrect) {
        pointsEarned = basePoints;
        if (!gameState.isBonusRound) { // Only apply bonus multiplier for regular questions
            pointsEarned *= gameState.bonusMultiplier; 
        }
        gameState.score += pointsEarned;
        playSound('correct');
        if (gameState.bonusMultiplier > 1 && !gameState.isBonusRound) {
             displayCharacter('üéâ', "BONUS ACTIV√â ! Points doubl√©s !", 2000);
        } else {
            displayCharacter('üòä', "Excellent ! Le r√©seau est bien trac√© !", 2000); // Correct message
        }
        drawnLines.forEach(line => line.setAttribute('stroke', '#4caf50'));
    } else {
        pointsEarned = -Math.floor(basePoints / 2);
        gameState.score = Math.max(0, gameState.score + pointsEarned);
        playSound('incorrect');
        displayCharacter('üòü', "Le trac√© n'est pas optimal. Essayez √† nouveau !", 2000); // Incorrect message
        drawnLines.forEach(line => line.setAttribute('stroke', '#f44336'));
    }

    // Record answer
    gameState.answers.push({
        levelIndex: gameState.currentLevel,
        type: level.type,
        question: level.question,
        userAnswer: userAnswerPath.length > 0 ? userAnswerPath.join(' -> ') : "Aucun trac√©",
        correctAnswer: getCorrectAnswerForLevel(level),
        isCorrect: allCorrect,
        pointsEarned: pointsEarned
    });
    // Update skill score
    gameState.skillScores[level.type].total++;
    if (allCorrect) {
        gameState.skillScores[level.type].correct++;
    }

    // Reset bonus multiplier after it's used for a regular question
    if (!gameState.isBonusRound) {
        gameState.bonusMultiplier = 1;
    }

    updateHeader();
    const gameScreenBtn = document.getElementById('gameScreen').querySelector('.btn');
    if (gameScreenBtn) { // Added null check
        gameScreenBtn.disabled = true;
    }
    setTimeout(nextLevel, 2000);
}


// Scenario Level
function renderScenarioLevel(level) {
    const quizScreen = document.getElementById('quizScreen');
    if (!quizScreen) return; // Added null check

    // Create a mutable copy of actions with their correct status
    const actionsWithStatus = level.actions.map((action, index) => ({
        text: action,
        isCorrect: index === level.correct
    }));
    shuffleArray(actionsWithStatus); // Shuffle the actions

    quizScreen.innerHTML = `
        <div class="scenario-alert">
            <div class="scenario-icon">üö®</div>
            <h2 id="questionText">${level.question}</h2>
        </div>
        <div class="answer-grid">
            ${actionsWithStatus.map((action, index) => `
                <button class="answer-btn" data-original-font-size="20" 
                        data-is-correct="${action.isCorrect}"
                        onclick="checkScenarioAnswer(${index}, ${action.isCorrect}, ${level.points}, '${action.text.replace(/'/g, "\\'")}', '${level.type}')">
                    ${action.text}
                </button>
            `).join('')}
        </div>
    `;
}

// Modified checkScenarioAnswer to use isCorrect flag and user's answer text
function checkScenarioAnswer(selectedIndex, isCorrectFlag, points, userAnswerText, levelType) {
    stopTimer();
    const buttons = document.querySelectorAll('.answer-btn');
    buttons.forEach((btn, index) => {
        btn.disabled = true;
        // The correct button is the one with the isCorrectFlag true
        if (btn.getAttribute('onclick') && btn.getAttribute('onclick').includes('true')) { // Added null check for getAttribute
            btn.classList.add('correct');
        } else if (index === selectedIndex) {
            btn.classList.add('incorrect');
        }
    });

    const level = gameState.isBonusRound ? gameState.bonusLevelData : gameState.shuffledLevels[gameState.currentLevel];
    let pointsEarned = 0;
    let basePoints = points;

    if (isCorrectFlag) {
        pointsEarned = basePoints;
        if (!gameState.isBonusRound) { // Only apply bonus multiplier for regular questions
            pointsEarned *= gameState.bonusMultiplier; 
        }
        gameState.score += pointsEarned;
        playSound('correct');
        if (gameState.bonusMultiplier > 1 && !gameState.isBonusRound) {
             displayCharacter('üéâ', "BONUS ACTIV√â ! Points doubl√©s !", 2000);
        } else {
            displayCharacter('üòä', "Bonne d√©cision ! La s√©curit√© avant tout.", 2000); // Correct message
        }
    } else {
        pointsEarned = -Math.floor(basePoints / 4);
        gameState.score = Math.max(0, gameState.score + pointsEarned);
        playSound('incorrect');
        displayCharacter('üòü', "Attention ! Une mauvaise d√©cision peut avoir des cons√©quences !", 2000); // Incorrect message
    }

    // Record answer
    gameState.answers.push({
        levelIndex: gameState.currentLevel,
        type: level.type,
        question: level.question,
        userAnswer: userAnswerText,
        correctAnswer: getCorrectAnswerForLevel(level),
        isCorrect: isCorrectFlag,
        pointsEarned: pointsEarned
    });
    // Update skill score
    gameState.skillScores[level.type].total++;
    if (isCorrectFlag) {
        gameState.skillScores[level.type].correct++;
    }

    // Reset bonus multiplier after it's used for a regular question
    if (!gameState.isBonusRound) {
        gameState.bonusMultiplier = 1;
    }

    updateHeader();
    setTimeout(nextLevel, 1500);
}

// New Bonus Level Types

// Conflict Detection Level
function renderConflictDetectionLevel(level) {
    const quizScreen = document.getElementById('quizScreen');
    if (!quizScreen) return; // Added null check

    const optionsWithStatus = level.options.map((option, index) => ({
        text: option,
        isCorrect: index === level.correct
    }));
    shuffleArray(optionsWithStatus);

    quizScreen.innerHTML = `
        <div class="scenario-alert" style="background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);">
            <div class="scenario-icon">‚ö†Ô∏è</div>
            <h2 id="questionText" style="color: #333;">${level.question}</h2>
        </div>
        <div class="answer-grid">
            ${optionsWithStatus.map((option, index) => `
                <button class="answer-btn" data-original-font-size="20" 
                        data-is-correct="${option.isCorrect}"
                        onclick="checkConflictDetectionAnswer(${index}, ${option.isCorrect}, ${level.points}, '${option.text.replace(/'/g, "\\'")}', '${level.type}')">
                    ${option.text}
                </button>
            `).join('')}
        </div>
    `;
}

function checkConflictDetectionAnswer(selectedIndex, isCorrectFlag, points, userAnswerText, levelType) {
    stopTimer();
    const buttons = document.querySelectorAll('.answer-btn');
    buttons.forEach((btn, index) => {
        btn.disabled = true;
        if (btn.getAttribute('onclick') && btn.getAttribute('onclick').includes('true')) { // Added null check for getAttribute
            btn.classList.add('correct');
        } else if (index === selectedIndex) {
            btn.classList.add('incorrect');
        }
    });

    const level = gameState.isBonusRound ? gameState.bonusLevelData : gameState.shuffledLevels[gameState.currentLevel];
    let pointsEarned = 0;
    let basePoints = points;

    if (isCorrectFlag) {
        pointsEarned = basePoints;
        // Bonus levels themselves don't get multiplied, they set the multiplier for the *next* regular question
        gameState.score += pointsEarned;
        playSound('correct');
        displayCharacter('‚úÖ', "Conflit bien identifi√© ! Excellente analyse !", 2000);
    } else {
        pointsEarned = -Math.floor(basePoints / 3);
        gameState.score = Math.max(0, gameState.score + pointsEarned);
        playSound('incorrect');
        displayCharacter('‚ùå', "Attention aux d√©tails ! Ce conflit est critique.", 2000);
    }

    gameState.answers.push({
        levelIndex: gameState.currentLevel,
        type: level.type,
        question: level.question,
        userAnswer: userAnswerText,
        correctAnswer: getCorrectAnswerForLevel(level),
        isCorrect: isCorrectFlag,
        pointsEarned: pointsEarned
    });
    gameState.skillScores[level.type].total++;
    if (isCorrectFlag) {
        gameState.skillScores[level.type].correct++;
    }

    // After a bonus round, the bonus multiplier is set for the *next* regular question.
    // We don't reset it here, it will be reset by the next regular loadLevel.

    updateHeader();
    setTimeout(nextLevel, 1500);
}

// Volume Calculation Level
function renderVolumeCalcLevel(level) {
    const quizScreen = document.getElementById('quizScreen');
    if (!quizScreen) return; // Added null check

    quizScreen.innerHTML = `
        <h2 id="questionText">${level.question}</h2>
        <input type="number" id="elevationInput" class="elevation-input" placeholder="Entrez votre r√©ponse (m¬≥)" step="0.01">
        <div class="button-center-align">
            <button class="btn" id="validateCalcBtn" onclick="checkVolumeCalcAnswer(${level.answer}, ${level.points}, '${level.type}')">Valider</button>
        </div>
    `;
}

function checkVolumeCalcAnswer(correctAnswer, points, levelType) {
    stopTimer();
    const input = document.getElementById('elevationInput');
    const validateBtn = document.getElementById('validateCalcBtn');

    let userAnswer = null;
    if (input) { // Added null check
        userAnswer = parseFloat(input.value);
        input.disabled = true;
    }
    if (validateBtn) { // Added null check
        validateBtn.disabled = true;
    }

    const tolerance = 0.01;

    const level = gameState.isBonusRound ? gameState.bonusLevelData : gameState.shuffledLevels[gameState.currentLevel];
    let isCorrect = false;
    let pointsEarned = 0;
    let basePoints = points;

    if (userAnswer !== null && Math.abs(userAnswer - correctAnswer) < tolerance) { // Added null check for userAnswer
        isCorrect = true;
        pointsEarned = basePoints;
        // Bonus levels themselves don't get multiplied, they set the multiplier for the *next* regular question
        gameState.score += pointsEarned;
        playSound('correct');
        displayCharacter('üìà', "Calcul de volume pr√©cis ! Impressionnant !", 2000);
    } else {
        pointsEarned = -Math.floor(basePoints / 3);
        if (input) { // Added null check
            input.style.borderColor = '#f44336';
            input.style.boxShadow = '0 0 0 3px rgba(244, 67, 54, 0.2)';
        }
        gameState.score = Math.max(0, gameState.score + pointsEarned);
        playSound('incorrect');
        displayCharacter('üìâ', "Revoyez vos formules de volume. Chaque m√®tre cube compte !", 2000);
    }

    gameState.answers.push({
        levelIndex: gameState.currentLevel,
        type: level.type,
        question: level.question,
        userAnswer: input ? input.value : "N/A", // Added null check
        correctAnswer: correctAnswer.toFixed(2),
        isCorrect: isCorrect,
        pointsEarned: pointsEarned
    });
    gameState.skillScores[level.type].total++;
    if (isCorrect) {
        gameState.skillScores[level.type].correct++;
    }

    // After a bonus round, the bonus multiplier is set for the *next* regular question.
    // We don't reset it here, it will be reset by the next regular loadLevel.

    updateHeader();
    setTimeout(nextLevel, 1500);
}


// New Pipe Connect Mini-Game Functions
let currentPipeGrid = []; // Stores the state of the grid: { type: 'straight'/'bend'/'t_junction'/'cross', rotation: 0/90/180/270 }
let pipeTrayCounts = {}; // Stores counts of available pipes

// SVG definitions for pipe pieces
function getPipeSVG(type) {
    const strokeWidth = 10;
    const half = 50; // Half of 100px cell size for center
    const quarter = 25; // Quarter for offsets

    switch (type) {
        case 'straight':
            return `<svg viewBox="0 0 100 100"><path d="M${half},0 V100" stroke="currentColor" stroke-width="${strokeWidth}" fill="none" stroke-linecap="round"/></svg>`;
        case 'bend':
            return `<svg viewBox="0 0 100 100"><path d="M0,${half} H${half} V100" stroke="currentColor" stroke-width="${strokeWidth}" fill="none" stroke-linecap="round"/></svg>`;
        case 't_junction':
            return `<svg viewBox="0 0 100 100"><path d="M0,${half} H100 M${half},0 V100" stroke="currentColor" stroke-width="${strokeWidth}" fill="none" stroke-linecap="round"/></svg`;
        case 'cross':
            return `<svg viewBox="0 0 100 100"><path d="M0,${half} H100 M${half},0 V100" stroke="currentColor" stroke-width="${strokeWidth}" fill="none" stroke-linecap="round"/></svg>`;
        default:
            return '';
    }
}

function renderPipeConnectLevel(level) {
    const gameScreen = document.getElementById('gameScreen');
    if (!gameScreen) return;

    gameScreen.innerHTML = `
        <h2 id="questionText">${level.question}</h2>
        <div class="pipe-game-container">
            <div id="pipeTray" class="pipe-tray"></div>
            <div id="pipeGridContainer" class="pipe-grid-container"></div>
            <div class="button-center-align">
                <button class="btn" id="validatePipeConnectBtn" onclick="checkPipeConnectAnswer(${level.points}, ${level.gridSize}, ${level.start.row}, ${level.start.col}, ${level.end.row}, ${level.end.col}, '${level.type}')">Valider le r√©seau</button>
            </div>
        </div>
    `;

    const pipeTray = document.getElementById('pipeTray');
    const pipeGridContainer = document.getElementById('pipeGridContainer');

    // Initialize grid state with nulls and set up grid display
    currentPipeGrid = Array(level.gridSize).fill(0).map(() => Array(level.gridSize).fill(null));
    pipeGridContainer.style.gridTemplateColumns = `repeat(${level.gridSize}, 100px)`;

    // Render grid cells
    for (let r = 0; r < level.gridSize; r++) {
        for (let c = 0; c < level.gridSize; c++) {
            const cell = document.createElement('div');
            cell.classList.add('grid-cell');
            cell.dataset.row = r;
            cell.dataset.col = c;

            if (r === level.start.row && c === level.start.col) {
                cell.classList.add('start-node');
                cell.textContent = 'D√©part';
            } else if (r === level.end.row && c === level.end.col) {
                cell.classList.add('end-node');
                cell.textContent = 'Arriv√©e';
            }

            cell.addEventListener('dragover', (e) => {
                e.preventDefault(); // Allow drop
                cell.classList.add('hover');
            });
            cell.addEventListener('dragleave', () => cell.classList.remove('hover'));
            cell.addEventListener('drop', (e) => handlePipeDrop(e, cell, level));
            pipeGridContainer.appendChild(cell);
        }
    }

    // Initialize pipe tray
    pipeTrayCounts = {};
    level.availablePieces.forEach(piece => {
        pipeTrayCounts[piece.type] = piece.count;
        createDraggablePipe(piece.type, pipeTray);
    });
}

function createDraggablePipe(type, container) {
    const pieceDiv = document.createElement('div');
    pieceDiv.classList.add('pipe-piece-draggable');
    pieceDiv.draggable = true;
    pieceDiv.dataset.type = type;
    pieceDiv.dataset.rotation = 0; // Initial rotation

    pieceDiv.innerHTML = getPipeSVG(type);

    const countSpan = document.createElement('span');
    countSpan.classList.add('pipe-count');
    countSpan.textContent = pipeTrayCounts[type];
    pieceDiv.appendChild(countSpan);

    pieceDiv.addEventListener('dragstart', (e) => {
        e.dataTransfer.setData('text/plain', JSON.stringify({ type: pieceDiv.dataset.type, rotation: pieceDiv.dataset.rotation }));
        e.dataTransfer.effectAllowed = 'move';
        pieceDiv.classList.add('dragging');
    });

    pieceDiv.addEventListener('dragend', () => {
        pieceDiv.classList.remove('dragging');
    });

    container.appendChild(pieceDiv);
    updatePipeTrayDisplay(); // Update counts
}

function handlePipeDrop(e, targetCell, level) {
    e.preventDefault();
    targetCell.classList.remove('hover');

    if (targetCell.classList.contains('start-node') || targetCell.classList.contains('end-node')) {
        displayCharacter('üö´', "Vous ne pouvez pas placer de tuyau sur les points de d√©part/arriv√©e !", 2000);
        return;
    }

    const data = JSON.parse(e.dataTransfer.getData('text/plain'));
    const type = data.type;
    let rotation = parseInt(data.rotation);

    const row = parseInt(targetCell.dataset.row);
    const col = parseInt(targetCell.dataset.col);

    // If there's already a pipe in the cell, remove it and return to tray
    if (currentPipeGrid[row][col]) {
        const existingPipe = currentPipeGrid[row][col];
        pipeTrayCounts[existingPipe.type]++; // Return to tray
        updatePipeTrayDisplay();
        targetCell.innerHTML = ''; // Clear cell
    }

    // Place the new pipe if available
    if (pipeTrayCounts[type] > 0) {
        pipeTrayCounts[type]--;
        currentPipeGrid[row][col] = { type: type, rotation: rotation };

        const pipeDiv = document.createElement('div');
        pipeDiv.classList.add('pipe-piece-placed');
        pipeDiv.innerHTML = getPipeSVG(type);
        pipeDiv.style.transform = `rotate(${rotation}deg)`;
        pipeDiv.dataset.type = type;
        pipeDiv.dataset.rotation = rotation; // Store current rotation

        pipeDiv.addEventListener('click', () => rotatePipe(pipeDiv, row, col));
        targetCell.appendChild(pipeDiv);
        updatePipeTrayDisplay();
    } else {
        displayCharacter('ü§î', "Plus de pi√®ces de ce type disponibles dans le plateau !", 2000);
    }
}

function rotatePipe(pipeDiv, row, col) {
    let currentRotation = parseInt(pipeDiv.dataset.rotation);
    currentRotation = (currentRotation + 90) % 360;
    pipeDiv.style.transform = `rotate(${currentRotation}deg)`;
    pipeDiv.dataset.rotation = currentRotation; // Update stored rotation

    if (currentPipeGrid[row][col]) {
        currentPipeGrid[row][col].rotation = currentRotation;
    }
    playSound('buttonClick');
}

function updatePipeTrayDisplay() {
    const pipeTray = document.getElementById('pipeTray');
    if (!pipeTray) return;

    // Clear existing draggables to re-render with updated counts
    pipeTray.innerHTML = ''; 

    for (const type in pipeTrayCounts) {
        if (pipeTrayCounts[type] > 0) {
            const pieceDiv = document.createElement('div');
            pieceDiv.classList.add('pipe-piece-draggable');
            pieceDiv.draggable = true;
            pieceDiv.dataset.type = type;
            pieceDiv.dataset.rotation = 0; // Draggable pieces always start at 0 rotation visually in tray

            pieceDiv.innerHTML = getPipeSVG(type);

            const countSpan = document.createElement('span');
            countSpan.classList.add('pipe-count');
            countSpan.textContent = pipeTrayCounts[type];
            pieceDiv.appendChild(countSpan);

            pieceDiv.addEventListener('dragstart', (e) => {
                e.dataTransfer.setData('text/plain', JSON.stringify({ type: pieceDiv.dataset.type, rotation: pieceDiv.dataset.rotation }));
                e.dataTransfer.effectAllowed = 'move';
                pieceDiv.classList.add('dragging');
            });

            pieceDiv.addEventListener('dragend', () => {
                pieceDiv.classList.remove('dragging');
            });
            pipeTray.appendChild(pieceDiv);
        }
    }
}


// Define connections for each pipe type and rotation
// Each entry maps a rotation to an array of connected sides (0=top, 1=right, 2=bottom, 3=left)
const PIPE_CONNECTIONS = {
    'straight': {
        0: [0, 2], // Vertical: top, bottom
        90: [1, 3], // Horizontal: right, left
        180: [0, 2],
        270: [1, 3]
    },
    'bend': {
        0: [0, 1], // Top-right bend
        90: [1, 2], // Right-bottom bend
        180: [2, 3], // Bottom-left bend
        270: [3, 0]  // Left-top bend
    },
    't_junction': {
        0: [0, 1, 3], // T-up: top, right, left
        90: [0, 1, 2], // T-right: top, right, bottom
        180: [1, 2, 3], // T-down: right, bottom, left
        270: [0, 2, 3]  // T-left: top, bottom, left
    },
    'cross': {
        0: [0, 1, 2, 3] // All sides connected
    }
};

function checkPipeConnectAnswer(points, gridSize, startRow, startCol, endRow, endCol, levelType) {
    stopTimer();
    const validateButton = document.getElementById('validatePipeConnectBtn');
    if (validateButton) validateButton.disabled = true;

    // Clear previous path highlights
    document.querySelectorAll('.grid-cell').forEach(cell => {
        cell.classList.remove('correct-path', 'incorrect-path');
        const pipe = cell.querySelector('.pipe-piece-placed svg');
        if (pipe) {
            pipe.style.fill = '#3b82f6'; // Reset to default blue
            pipe.style.stroke = '#1e40af';
        }
    });

    let isCorrect = false;
    let pointsEarned = 0;
    let basePoints = points;
    let userAnswerPath = "Chemin non trouv√© ou incomplet.";

    // Check if all available pieces are used
    let allPiecesUsed = true;
    for (const type in pipeTrayCounts) {
        if (pipeTrayCounts[type] > 0) {
            allPiecesUsed = false;
            break;
        }
    }

    if (!allPiecesUsed) {
        displayCharacter('ü§î', "Toutes les pi√®ces ne sont pas utilis√©es ou le chemin est incomplet !", 3000);
        pointsEarned = -Math.floor(basePoints / 3);
        gameState.score = Math.max(0, gameState.score + pointsEarned);
        playSound('incorrect');
        recordPipeConnectAnswer(levelType, userAnswerPath, false, pointsEarned);
        setTimeout(nextLevel, 2000);
        return;
    }

    // BFS to find a path from start to end
    const queue = [{ r: startRow, c: startCol, path: [`${startRow}-${startCol}`] }];
    const visited = new Set([`${startRow}-${startCol}`]);

    while (queue.length > 0) {
        const { r, c, path } = queue.shift();

        // Check if we reached the end
        if (r === endRow && c === endCol) {
            isCorrect = true;
            userAnswerPath = path.join(' -> ');
            break;
        }

        // Determine outgoing connections from current pipe (or start node)
        let outgoingConnections = [];
        if (r === startRow && c === startCol) {
            // Start node connects to its right (assuming start is always on left edge, facing right)
            // Or, more generally, it connects to the cell (r, c+1) on its right.
            // For a start node at (0,0), it should connect to a pipe at (0,1) that has a 'left' opening.
            // This is a simplification. A more robust start/end node would have explicit "openings".
            // For now, let's assume start has an opening to the right, and end has an opening to the left.
            outgoingConnections = [1]; // Right side (for start node)
        } else {
            const pipe = currentPipeGrid[r][c];
            if (!pipe) continue; // Should not happen if all pieces are used

            outgoingConnections = PIPE_CONNECTIONS[pipe.type][pipe.rotation];
        }

        // Explore neighbors
        const neighbors = [
            { dr: -1, dc: 0, incomingSide: 2, r: r - 1, c: c }, // Top (expecting bottom connection)
            { dr: 0, dc: 1, incomingSide: 3, r: r, c: c + 1 }, // Right (expecting left connection)
            { dr: 1, dc: 0, incomingSide: 0, r: r + 1, c: c }, // Bottom (expecting top connection)
            { dr: 0, dc: -1, incomingSide: 1, r: r, c: c - 1 }  // Left (expecting right connection)
        ];

        neighbors.forEach(neighbor => {
            const nr = neighbor.r;
            const nc = neighbor.c;

            // Check bounds
            if (nr < 0 || nr >= gridSize || nc < 0 || nc >= gridSize) return;

            // Check if already visited
            if (visited.has(`${nr}-${nc}`)) return;

            // Check if current pipe connects to this neighbor
            const currentPipeHasOutgoing = outgoingConnections.includes(neighbor.incomingSide === 0 ? 2 : neighbor.incomingSide === 1 ? 3 : neighbor.incomingSide === 2 ? 0 : 1); // Map incoming to outgoing

            if (!currentPipeHasOutgoing) return;

            // Check if neighbor is the end node
            if (nr === endRow && nc === endCol) {
                // Special check for end node: it must have an opening that connects to the incoming pipe
                // Assuming end node needs an incoming connection from its left (side 3)
                // This needs to be dynamic based on end node position.
                // For now, assume end node is at (3,3) and expects connection from left (side 3) or top (side 0).
                // Simplified: if it's the end node, and we can reach it, it's a valid connection.
                 if (currentPipeHasOutgoing) { // Ensure the pipe leading to end has an opening towards end
                    queue.push({ r: nr, c: nc, path: [...path, `${nr}-${nc}`] });
                    visited.add(`${nr}-${nc}`);
                    return;
                }
            }

            // Check if neighbor cell has a pipe
            const neighborPipe = currentPipeGrid[nr][nc];
            if (!neighborPipe) return;

            // Check if neighbor pipe has an incoming connection from current pipe
            const neighborIncomingConnections = PIPE_CONNECTIONS[neighborPipe.type][neighborPipe.rotation];
            const neighborHasIncoming = neighborIncomingConnections.includes(neighbor.incomingSide);

            if (neighborHasIncoming) {
                queue.push({ r: nr, c: nc, path: [...path, `${nr}-${nc}`] });
                visited.add(`${nr}-${nc}`);
            }
        });
    }

    if (isCorrect) {
        pointsEarned = basePoints;
        if (!gameState.isBonusRound) { // Only apply bonus multiplier for regular questions
            pointsEarned *= gameState.bonusMultiplier; 
        }
        gameState.score += pointsEarned;
        playSound('correct');
        displayCharacter('üéâ', "R√©seau parfait ! Vous √™tes un expert en plomberie VRD !", 2000);
        // Highlight correct path
        userAnswerPath.split(' -> ').forEach(coordStr => {
            const [r, c] = coordStr.split('-').map(Number);
            const cell = document.querySelector(`.grid-cell[data-row="${r}"][data-col="${c}"]`);
            if (cell) {
                cell.classList.add('correct-path');
                const pipe = cell.querySelector('.pipe-piece-placed svg');
                if (pipe) {
                    pipe.style.fill = '#10b981'; // Green fill
                    pipe.style.stroke = '#065f46'; // Darker green stroke
                }
            }
        });
    } else {
        pointsEarned = -Math.floor(basePoints / 2);
        gameState.score = Math.max(0, gameState.score + pointsEarned);
        playSound('incorrect');
        displayCharacter('üòü', "Le r√©seau n'est pas fonctionnel. V√©rifiez vos connexions !", 2000);
        // Highlight incorrect path (all placed pipes for this case)
        for (let r = 0; r < gridSize; r++) {
            for (let c = 0; c < gridSize; c++) {
                const cell = document.querySelector(`.grid-cell[data-row="${r}"][data-col="${c}"]`);
                if (cell && currentPipeGrid[r][c]) {
                    cell.classList.add('incorrect-path');
                    const pipe = cell.querySelector('.pipe-piece-placed svg');
                    if (pipe) {
                        pipe.style.fill = '#ef4444'; // Red fill
                        pipe.style.stroke = '#b91c1c'; // Darker red stroke
                    }
                }
            }
        }
    }

    recordPipeConnectAnswer(levelType, userAnswerPath, isCorrect, pointsEarned);
    setTimeout(nextLevel, 2000);
}

function recordPipeConnectAnswer(levelType, userAnswerText, isCorrect, pointsEarned) {
    const level = gameState.isBonusRound ? gameState.bonusLevelData : gameState.shuffledLevels[gameState.currentLevel];
    gameState.answers.push({
        levelIndex: gameState.currentLevel,
        type: level.type,
        question: level.question,
        userAnswer: userAnswerText,
        correctAnswer: getCorrectAnswerForLevel(level),
        isCorrect: isCorrect,
        pointsEarned: pointsEarned
    });
    gameState.skillScores[level.type].total++;
    if (isCorrect) {
        gameState.skillScores[level.type].correct++;
    }
    if (!gameState.isBonusRound) {
        gameState.bonusMultiplier = 1;
    }
    updateHeader();
}


// Font Size Adjustment Functions
function applyFontSize() {
    const root = document.documentElement;
    root.style.fontSize = `${gameState.baseFontSize}px`;

    // Elements that are always expected to be in the DOM or are handled by specific screen rendering
    // and might need scaling.
    const elementsToScale = [
        { selector: 'h1', baseRem: 3.5 }, // For general H1 (final screen)
        { selector: 'h2', baseRem: 2.5 }, // For general H2 (quiz, game, modals)
        { selector: 'p', baseRem: 1.1 }, // For general paragraphs
        { selector: '.answer-btn', baseRem: 1.2 },
        { selector: '.draggable', baseRem: 1.1 },
        { selector: '.drop-zone', baseRem: 1.1 },
        { selector: '.elevation-input', baseRem: 1.8 },
        { selector: '.material-text', baseRem: 1.0 },
        { selector: '.material-icon', baseRem: 4.0 },
        { selector: '#speechBubbleText', baseRem: 1.0 }, // Speech bubble text
        { selector: '.logo span', baseRem: 2.0 }, // Header logo text
        { selector: '.logo-icon', baseRem: 2.2 }, // Header logo icon and home screen logo icon
        { selector: '.header-item', baseRem: 1.7 }, // Header stats
        { selector: '.score-icon', baseRem: 2.0 },
        { selector: '.timer-icon', baseRem: 2.0 },
        { selector: '.progress-fill-chronological', baseRem: 0.8 },
        { selector: '.tips-bar-content', baseRem: 1.0 },
        { selector: '.control-btn', baseRem: 1.7 },
        { selector: '#homeScreen h1', baseRem: 5.5 }, // Home screen specific (updated)
        { selector: '#homeScreen p', baseRem: 1.8 }, // Home screen specific (updated)
        { selector: '#homeScreen .logo-icon', baseRem: 8.0 }, // Home screen specific (updated)
        { selector: '#homeScreen .btn', baseRem: 2.0 }, // Home screen specific (updated)
        { selector: '.home-features', baseRem: 1.2 }, // Home screen specific (updated)
        { selector: '#helpModal h2', baseRem: 1.8 },
        { selector: '#helpModal h3', baseRem: 1.4 },
        { selector: '#helpModal p', baseRem: 1.1 },
        { selector: '#confirmModal h2', baseRem: 1.8 },
        { selector: '#confirmModal p', baseRem: 1.2 },
        { selector: '#correctionModal h2', baseRem: 1.8 },
        { selector: '#correctionModal #correctionReportContent', baseRem: 1.1 },
        { selector: '.scenario-icon', baseRem: 4.0 },
        { selector: '.stat-number', baseRem: 3.2 },
        { selector: '.stat-label', baseRem: 1.1 },
        { selector: '#customAlert', baseRem: 1.1 },
        { selector: '.pipe-piece-draggable', baseRem: 1.0 },
        { selector: '.pipe-count', baseRem: 0.7 },
        { selector: '.grid-cell', baseRem: 1.0 }
    ];

    elementsToScale.forEach(item => {
        document.querySelectorAll(item.selector).forEach(el => {
            if (el) { // Check if the element exists before trying to set style
                el.style.fontSize = `${item.baseRem * (gameState.baseFontSize / 14)}rem`;
            }
        });
    });
}

function increaseFontSize() {
    if (gameState.baseFontSize < 20) { /* Adjusted max font size limit */
        gameState.baseFontSize += 2; // Increase by 2px
        localStorage.setItem('ltdSimFontSize', gameState.baseFontSize);
        applyFontSize();
        playSound('buttonClick');
    }
}

function decreaseFontSize() {
    if (gameState.baseFontSize > 10) { /* Adjusted min font size limit */
        gameState.baseFontSize -= 2; // Decrease by 2px
        localStorage.setItem('ltdSimFontSize', gameState.baseFontSize);
        applyFontSize();
        playSound('buttonClick');
    }
}

// Character and Speech Bubble Functions
function displayCharacter(emoji, message, duration = 3000) {
    const characterDiv = document.getElementById('gameCharacter');
    const speechBubble = document.getElementById('speechBubble');
    const speechBubbleText = document.getElementById('speechBubbleText');

    if (!characterDiv || !speechBubble || !speechBubbleText) return; // Ensure all elements exist

    // Stop any current tip interval
    clearInterval(gameState.characterTipInterval);

    characterDiv.textContent = emoji;
    characterDiv.style.display = 'block';
    speechBubbleText.textContent = message;
    speechBubble.classList.add('active');
    speechBubble.style.display = 'block';
    applyFontSize(); // Re-apply font size to speech bubble text

    // Set a timeout to hide the bubble and potentially restart tips
    setTimeout(() => {
        if (speechBubble) { // Added null check
            speechBubble.classList.remove('active');
        }
        // speechBubble.style.display = 'none'; // Keep hidden until next message
        // characterDiv.style.display = 'none'; // Keep character visible
        // Restart tips after a short delay if game is active
        if (document.getElementById('quizScreen').classList.contains('active') || document.getElementById('gameScreen').classList.contains('active')) {
            startCharacterTips();
        }
    }, duration);
}

function startCharacterTips() {
    // Clear any existing interval to prevent duplicates
    clearInterval(gameState.characterTipInterval); 
    gameState.characterTipInterval = setInterval(() => {
        const tip = gameTips[currentTipIndex];
        displayCharacter('ü§î', tip, 5000); // Display tip for 5 seconds
        currentTipIndex = (currentTipIndex + 1) % gameTips.length;
    }, 10000); // Change tip every 10 seconds
}

// Tips Marquee Functions (kept for the bottom bar, though character will also give tips)
function startTipsMarquee() {
    const tipsBarContent = document.getElementById('tipsBarContent');
    if (!tipsBarContent) return; // Ensure element exists

    // Clear any existing animation to reset
    tipsBarContent.style.animation = 'none';
    tipsBarContent.offsetHeight; // Trigger reflow
    tipsBarContent.style.animation = null;

    tipsBarContent.textContent = gameTips[currentTipIndex];
    currentTipIndex = (currentTipIndex + 1) % gameTips.length;

    // Calculate animation duration based on content length to make speed consistent
    const textLength = tipsBarContent.textContent.length;
    const duration = Math.max(10, textLength * 0.15); // Min 10s, 0.15s per character
    tipsBarContent.style.animationDuration = `${duration}s`;

    // Restart animation on completion to cycle tips
    tipsBarContent.onanimationiteration = () => {
        tipsBarContent.textContent = gameTips[currentTipIndex];
        currentTipIndex = (currentTipIndex + 1) % gameTips.length;
        // Re-calculate duration for the new text
        const newTextLength = tipsBarContent.textContent.length;
        const newDuration = Math.max(10, newTextLength * 0.15);
        tipsBarContent.style.animationDuration = `${newDuration}s`;
    };
}

function stopTipsMarquee() {
    const tipsBarContent = document.getElementById('tipsBarContent');
    if (tipsBarContent) {
        tipsBarContent.style.animationPlayState = 'paused';
        tipsBarContent.onanimationiteration = null; // Remove event listener
    }
}

// Confetti effect (from previous versions)
function triggerConfetti() {
    const confettiCount = 100;
    for (let i = 0; i < confettiCount; i++) {
        const confetti = document.createElement('div');
        confetti.classList.add('confetti');
        confetti.style.left = Math.random() * 100 + 'vw';
        confetti.style.backgroundColor = `hsl(${Math.random() * 360}, 100%, 70%)`;
        confetti.style.animationDelay = `${Math.random() * 2}s`;
        document.body.appendChild(confetti);
        confetti.addEventListener('animationend', () => {
            confetti.remove();
        });
    }
}

// New function to check and enable/disable the finish game button
function checkFinishGameButton() {
    const finishGameBtn = document.getElementById('finishGameBtn');
    if (finishGameBtn) {
        if (gameState.score >= 1000) {
            finishGameBtn.disabled = false;
        } else {
            finishGameBtn.disabled = true;
        }
    }
}

// New function to confirm and finish the game early
function confirmFinishGame() {
    if (gameState.score >= 1000) {
        showConfirmModal(
            "Finir le jeu ?", 
            "Vous avez atteint un score de 1000 points ou plus. Voulez-vous terminer le jeu maintenant ?", 
            () => {
                endGame(); // Call endGame if confirmed
            }
        );
    } else {
        displayCharacter('ü§î', "Vous devez avoir au moins 1000 points pour finir le jeu plus t√¥t !", 3000);
        playSound('incorrect');
    }
}


// Initialisation
window.onload = function() {
    // Load saved font size
    const savedFontSize = localStorage.getItem('ltdSimFontSize');
    if (savedFontSize) {
        gameState.baseFontSize = parseInt(savedFontSize);
    }
    applyFontSize(); // Apply initial or saved font size
};

</script>
</body>
</html>
