<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Simulateur pour découvrir le métier de projeteur VRD avec deux modes de jeu.">
    <title>LTD Simulator - Projeteur VRD</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500&family=Poppins:wght@700;800&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <style>
        /* --- THÈME GLOBAL (issu du site principal) --- */
        :root {
            /* Colors */
            --primary: #6366f1;
            --primary-dark: #4f46e5;
            --primary-light: #a5b4fc;
            --secondary: #10b981;
            --secondary-dark: #059669;
            --accent: #f59e0b;
            --accent-dark: #d97706;
            --correct: #22c55e;
            --incorrect: #ef4444;
            
            /* Surfaces */
            --background: #0f172a;
            --surface: #1e293b;
            --surface-elevated: #334155;
            --surface-hover: #475569;
            --glass: rgba(255, 255, 255, 0.05);
            --glass-border: rgba(255, 255, 255, 0.15);
            
            /* Text */
            --text-primary: #f8fafc;
            --text-secondary: #cbd5e1;
            --text-muted: #94a3b8;
            
            /* Shadows */
            --shadow-glow: 0 0 15px 0px rgba(99, 102, 241, 0.3);
            --shadow-lg: 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);
            --shadow-xl: 0 25px 50px -12px rgb(0 0 0 / 0.25);

            /* Animation */
            --transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            --transition-slow: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            
            /* Spacing */
            --spacing-xs: 0.5rem;
            --spacing-sm: 1rem;
            --spacing-md: 1.5rem;
            --spacing-lg: 2rem;
            --spacing-xl: 3rem;
            
            /* Borders */
            --radius-sm: 0.375rem;
            --radius: 0.5rem;
            --radius-md: 0.75rem;
            --radius-lg: 1rem;
            --radius-xl: 1.5rem;
            --radius-full: 9999px;
        }

        body.light-mode {
            --background: #f1f5f9;
            --surface: #ffffff;
            --surface-elevated: #e2e8f0;
            --surface-hover: #cbd5e1;
            --glass: rgba(0, 0, 0, 0.05);
            --glass-border: rgba(0, 0, 0, 0.1);
            --text-primary: #1e293b;
            --text-secondary: #475569;
            --text-muted: #64748b;
            --shadow-glow: 0 0 15px 0px rgba(99, 102, 241, 0.2);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }
        html { scroll-behavior: smooth; }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--background);
            color: var(--text-primary);
            line-height: 1.6;
            overflow-x: hidden;
            transition: var(--transition-slow);
        }

        body::before {
            content: ''; position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: radial-gradient(circle at 15% 50%, rgba(99, 102, 241, 0.15) 0%, transparent 40%), radial-gradient(circle at 85% 30%, rgba(16, 185, 129, 0.15) 0%, transparent 40%), radial-gradient(circle at 50% 85%, rgba(245, 158, 11, 0.1) 0%, transparent 40%);
            pointer-events: none; z-index: -1; animation: background-pan 30s linear infinite;
        }
        
        @keyframes background-pan { 0% { background-position: 0% 50%; } 50% { background-position: 100% 50%; } 100% { background-position: 0% 50%; } }
        
        [onclick], .nav-link, .mobile-nav-item, .theme-toggle, .mobile-toggle, .btn { cursor: pointer; }

        .header { position: fixed; top: 0; left: 0; right: 0; z-index: 1000; backdrop-filter: blur(20px) saturate(180%); background: rgba(15, 23, 42, 0.8); border-bottom: 1px solid var(--glass-border); transition: var(--transition); }
        body.light-mode .header { background: rgba(255, 255, 255, 0.8); }
        .nav-container { max-width: 1400px; margin: 0 auto; padding: 0 var(--spacing-sm); display: flex; align-items: center; justify-content: space-between; height: 4.5rem; gap: var(--spacing-md); }
        .logo { display: flex; align-items: center; gap: var(--spacing-sm); text-decoration: none; color: var(--text-primary); font-weight: 800; font-size: 1.2rem; transition: var(--transition); }
        .logo:hover { transform: scale(1.05); text-shadow: 0 0 10px var(--primary-light); }
        .logo-icon { height: 1.8rem; width: auto; vertical-align: -0.4rem; }
        .logo-text-extended { display: none; }
        .nav-desktop { display: none; }
        .nav-menu { display: flex; align-items: center; gap: var(--spacing-xs); list-style: none; }
        .nav-item { position: relative; }
        .nav-link { display: flex; align-items: center; gap: var(--spacing-xs); padding: var(--spacing-xs) var(--spacing-sm); color: var(--text-secondary); text-decoration: none; font-weight: 500; border-radius: var(--radius); transition: var(--transition); }
        .nav-link:hover { color: var(--text-primary); background: var(--glass); }
        .nav-link.active { color: var(--text-primary); background: linear-gradient(45deg, rgba(99, 102, 241, 0.1), rgba(99, 102, 241, 0.2)); font-weight: 600; }
        .header-search { position: relative; }
        .header-search input { width: 100%; background-color: var(--surface); border: 1px solid var(--glass-border); color: var(--text-secondary); border-radius: var(--radius); padding: 0.5rem 1rem 0.5rem 2.5rem; font-size: 0.9rem; transition: var(--transition); }
        .header-search input::placeholder { color: var(--text-muted); }
        .header-search input:focus { background-color: var(--surface-elevated); border-color: var(--primary); color: var(--text-primary); box-shadow: 0 0 0 2px var(--primary-dark); outline: none; }
        .header-search .fa-search { position: absolute; left: 1rem; top: 50%; transform: translateY(-50%); color: var(--text-muted); }
        .nav-actions { display: flex; align-items: center; gap: var(--spacing-sm); }
        .theme-toggle { display: flex; align-items: center; justify-content: center; width: 2.5rem; height: 2.5rem; background: var(--glass); border: 1px solid var(--glass-border); border-radius: var(--radius); color: var(--text-secondary); transition: var(--transition); }
        .theme-toggle:hover { background: var(--surface-elevated); color: var(--text-primary); transform: rotate(15deg); }
        .mobile-toggle { display: flex; flex-direction: column; justify-content: center; align-items: center; width: 2.5rem; height: 2.5rem; background: var(--glass); border: 1px solid var(--glass-border); border-radius: var(--radius); transition: var(--transition); }
        .hamburger { position: relative; width: 1.25rem; height: 1rem; }
        .hamburger span { position: absolute; left: 0; width: 100%; height: 2px; background: var(--text-primary); border-radius: 1px; transition: var(--transition); }
        .hamburger span:nth-child(1) { top: 0; }
        .hamburger span:nth-child(2) { top: 50%; transform: translateY(-50%); }
        .hamburger span:nth-child(3) { bottom: 0; }
        .mobile-toggle.active .hamburger span:nth-child(1) { top: 50%; transform: translateY(-50%) rotate(45deg); }
        .mobile-toggle.active .hamburger span:nth-child(2) { opacity: 0; }
        .mobile-toggle.active .hamburger span:nth-child(3) { bottom: 50%; transform: translateY(50%) rotate(-45deg); }
        .mobile-menu { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: var(--background); z-index: 999; display: flex; flex-direction: column; opacity: 0; visibility: hidden; transition: var(--transition-slow); }
        .mobile-menu.active { opacity: 1; visibility: visible; }
        .mobile-menu-header { display: flex; align-items: center; justify-content: space-between; padding: 0 var(--spacing-sm); height: 4.5rem; border-bottom: 1px solid var(--glass-border); }
        .mobile-menu-close { width: 2.5rem; height: 2.5rem; display: flex; align-items: center; justify-content: center; background: var(--glass); border: 1px solid var(--glass-border); border-radius: var(--radius); color: var(--text-primary); }
        .mobile-menu-content { flex: 1; padding: var(--spacing-lg) var(--spacing-sm); overflow-y: auto; }
        .mobile-search-wrapper { padding-bottom: var(--spacing-lg); margin-bottom: var(--spacing-lg); border-bottom: 1px solid var(--glass-border); }
        .mobile-search-wrapper .header-search { width: 100%; }
        .mobile-nav-section h3 { color: var(--text-muted); font-size: 0.75rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.1em; margin-bottom: var(--spacing-md); }
        .mobile-nav-items { display: flex; flex-direction: column; gap: var(--spacing-xs); }
        .mobile-nav-item { display: flex; align-items: center; gap: var(--spacing-sm); padding: var(--spacing-md); color: var(--text-secondary); text-decoration: none; border-radius: var(--radius-md); }
        .mobile-nav-item-icon { font-size: 1.25rem; width: 2.5rem; height: 2.5rem; display: flex; align-items: center; justify-content: center; background: var(--glass); border-radius: var(--radius); }
        .mobile-nav-item:hover { background: var(--glass); color: var(--text-primary); }
        .main-content { margin-top: 4.5rem; padding: var(--spacing-lg) var(--spacing-sm); max-width: 1400px; margin-left: auto; margin-right: auto; }
        @media (min-width: 768px) { .nav-container { padding: 0 var(--spacing-md); } .main-content { padding: var(--spacing-xl) var(--spacing-md); } }
        @media (min-width: 1024px) { .mobile-toggle { display: none; } .nav-desktop { display: flex; align-items: center; flex-grow: 1; justify-content: flex-end; gap: var(--spacing-sm); } .header-search { width: 280px; } .nav-menu { gap: var(--spacing-xs); } }
        @media (min-width: 1280px) { .logo-text-extended { display: inline; } }

        /* --- STYLES SPÉCIFIQUES AU JEU VRD (adaptés au thème) --- */
        .game-card {
            background: var(--surface); border: 1px solid var(--glass-border); border-radius: var(--radius-xl);
            padding: var(--spacing-lg); width: 100%; box-shadow: var(--shadow-xl);
            backdrop-filter: blur(10px); text-align: center; animation: fadeIn 0.5s ease-out;
            max-width: 1200px; margin: 0 auto;
        }
        @media (min-width: 768px) { .game-card { padding: var(--spacing-xl); } }
        @keyframes fadeIn { from { opacity: 0; transform: scale(0.98); } to { opacity: 1; transform: scale(1); } }
        
        .screen { display: none; flex: 1; }
        .screen.active { display: flex; flex-direction: column; align-items: center; justify-content: center; }

        .game-card h1 {
            font-family: 'Poppins', sans-serif; font-size: clamp(2.2rem, 6vw, 3.5rem);
            font-weight: 800; color: var(--primary-light); margin-bottom: var(--spacing-sm);
        }
        .game-card h2 {
            font-family: 'Poppins', sans-serif; font-size: clamp(1.5rem, 4vw, 2rem);
            font-weight: 700; color: var(--text-primary); margin-bottom: var(--spacing-md);
            line-height: 1.4; max-width: 900px;
        }
        .game-card p { font-size: 1.2rem; color: var(--text-secondary); margin-bottom: var(--spacing-md); max-width: 700px; }
        
        .btn {
            display: inline-flex; align-items: center; justify-content: center; gap: 0.5rem;
            background: var(--primary); color: white; border: none; padding: 1rem 2rem;
            border-radius: var(--radius-full); font-size: 1.1rem; font-weight: 600;
            transition: var(--transition); box-shadow: 0 4px 10px rgba(99, 102, 241, 0.2);
        }
        .btn:hover { background: var(--primary-dark); transform: translateY(-2px); box-shadow: var(--shadow-glow); }
        .btn:active { transform: translateY(0); }
        .btn:disabled { opacity: 0.7; cursor: not-allowed; background: var(--surface-hover); box-shadow: none; }
        .btn.secondary { background: var(--surface-elevated); color: var(--text-primary); }
        .btn.secondary:hover { background: var(--surface-hover); }

        .mode-selection { display: flex; flex-direction: column; gap: var(--spacing-md); margin-top: var(--spacing-lg); width: 100%; max-width: 600px; }
        @media (min-width: 640px) { .mode-selection { flex-direction: row; } }
        .mode-selection .btn { flex: 1; flex-direction: column; height: auto; padding: 1.5rem; }
        .mode-selection .btn span { font-size: 0.9rem; font-weight: 400; color: var(--text-secondary); margin-top: 0.5rem; }
        body.light-mode .mode-selection .btn span { color: var(--text-muted); }

        .game-header { display: flex; justify-content: space-between; align-items: center; width: 100%; margin-bottom: var(--spacing-md); }
        .game-header-stats { display: flex; gap: var(--spacing-md); align-items: center; justify-content: center; flex-wrap: wrap; }
        .game-header-item { display: flex; align-items: center; gap: var(--spacing-xs); font-size: 1.3rem; font-weight: 700; font-family: 'JetBrains Mono', monospace; background: var(--surface-elevated); padding: 0.6rem 1.5rem; border-radius: var(--radius-full); }
        .timer-display.warning { animation: pulse 1s infinite; color: var(--incorrect); }
        @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.05); } }
        
        .answer-grid { display: grid; grid-template-columns: 1fr; gap: var(--spacing-sm); width: 100%; max-width: 1000px; margin-top: var(--spacing-md); }
        @media (min-width: 640px) { .answer-grid { grid-template-columns: 1fr 1fr; gap: var(--spacing-md); } }

        .answer-btn {
            width: 100%; background: var(--surface-elevated); color: var(--text-secondary);
            padding: 1.2rem; border: 1px solid var(--glass-border); border-radius: var(--radius-md);
            text-align: center; font-size: 1.1rem; transition: var(--transition);
        }
        .answer-btn:not(:disabled):hover { background: var(--surface-hover); border-color: var(--primary); color: var(--text-primary); transform: translateY(-2px); }
        .answer-btn.correct { background: var(--correct) !important; color: var(--text-primary) !important; border-color: var(--correct) !important; animation: bounce 0.5s ease; }
        .answer-btn.incorrect { background: var(--incorrect) !important; color: var(--text-primary) !important; border-color: var(--incorrect) !important; animation: shake 0.5s ease; }
        .answer-btn:disabled { cursor: not-allowed; }

        @keyframes bounce { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-6px); } }
        @keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-5px); } 75% { transform: translateX(5px); } }

        .feedback-text { margin-top: var(--spacing-md); font-size: 1.2rem; font-weight: bold; }
        .feedback-solution { font-size: 1rem; font-weight: normal; color: var(--text-secondary); margin-top: var(--spacing-xs); }

        .material-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 1.5rem; width: 100%; max-width: 1100px; margin-top: 2rem; }
        .material-card { background: var(--surface-elevated); border: 2px solid var(--glass-border); color: var(--text-secondary); border-radius: 1rem; padding: 1.5rem; text-align: center; cursor: pointer; transition: all 0.3s ease; display: flex; flex-direction: column; align-items: center; gap: 1rem; }
        .material-icon { font-size: 3.5rem; line-height: 1; }
        .material-card:not(.disabled):hover { transform: translateY(-5px); border-color: var(--primary); color: var(--text-primary); box-shadow: var(--shadow-glow); }
        .material-card.selected { border-color: var(--secondary); box-shadow: 0 0 0 3px var(--secondary); }
        .material-card.correct { background: var(--correct) !important; color: white !important; border-color: var(--correct) !important; }
        .material-card.incorrect { background: var(--incorrect) !important; color: white !important; border-color: var(--incorrect) !important; }
        .material-card.disabled { cursor: not-allowed; opacity: 0.7; }

        .elevation-input, .text-input { font-size: 1.8rem; padding: 1rem 2rem; border: 1px solid var(--glass-border); border-radius: var(--radius-md); text-align: center; width: 100%; max-width: 450px; transition: all 0.3s ease; margin: 1rem 0; background-color: var(--surface-elevated); color: var(--text-primary); }
        .elevation-input:focus, .text-input:focus { outline: none; border-color: var(--primary); box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.3); }
        
        .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1.5rem; width: 100%; max-width: 800px; margin: 2rem 0; }
        .stat-card { background: var(--surface-elevated); padding: 1.5rem; border-radius: 1rem; text-align: center; border: 1px solid var(--glass-border); }
        .stat-label { font-weight: 500; color: var(--text-secondary); margin-bottom: 0.5rem; }
        .stat-number { font-weight: 800; font-size: 2.5rem; color: var(--primary); }

        .pipe-game-container { display: flex; flex-direction: column; align-items: center; gap: 1.5rem; width: 100%; }
        .pipe-tray { display: flex; gap: 1rem; background: var(--surface-elevated); padding: 1rem; border-radius: 1rem; flex-wrap: wrap; justify-content: center; }
        .pipe-piece-draggable { width: 60px; height: 60px; cursor: grab; position: relative; }
        .pipe-piece-draggable.dragging { opacity: 0.5; }
        .pipe-count { position: absolute; bottom: -5px; right: -5px; background: var(--primary); color: white; border-radius: 50%; width: 22px; height: 22px; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 0.9rem; }
        .pipe-grid-container { 
            display: grid; 
            grid-template-columns: repeat(var(--grid-cols, 5), 1fr); 
            border: 2px solid var(--glass-border); 
            border-radius: 1rem; 
            overflow: hidden; 
            background: var(--background); 
            width: clamp(320px, 90vw, 800px);
            margin-left: auto;
            margin-right: auto;
        }
        .grid-cell { border: 1px solid var(--glass-border); display: flex; align-items: center; justify-content: center; position: relative; background-color: var(--surface); aspect-ratio: 1 / 1; }
        .grid-cell.start-node { background-color: var(--correct); color: white; font-weight: bold; font-size: 1.5rem; }
        .grid-cell.end-node { background-color: var(--incorrect); color: white; font-weight: bold; font-size: 1.5rem; }
        .pipe-piece-placed { width: 100%; height: 100%; transition: transform 0.2s ease; cursor: pointer; }
        .grid-cell.obstacle-node { background-color: var(--surface-hover); display: flex; align-items: center; justify-content: center; }

        .draggable { padding: 0.75rem 1.25rem; background: var(--surface-elevated); border: 1px solid var(--glass-border); border-radius: 0.5rem; cursor: grab; transition: all 0.2s ease; user-select: none; text-align: center; }
        .draggable:active { cursor: grabbing; background: var(--surface-hover); }
        .draggable.correct { background: var(--correct) !important; color: white !important; }
        .draggable.incorrect { background: var(--incorrect) !important; color: white !important; }

        .drop-zone-container { display: flex; flex-direction: column; align-items: center; gap: 2rem; width: 100%; }
        .draggable-container { display: flex; flex-wrap: wrap; gap: 0.75rem; justify-content: center; background: var(--surface); padding: 1rem; border-radius: 1rem; width: 100%; max-width: 1000px; }
        .category-container { display: flex; gap: 1.5rem; width: 100%; justify-content: space-around; flex-direction: column; max-width: 1100px; }
        @media (min-width: 768px) { .category-container { flex-direction: row; } }
        .category-zone { border: 2px dashed var(--glass-border); border-radius: 1rem; background: var(--surface); transition: all 0.2s ease; min-height: 200px; padding: 1rem; display: flex; flex-direction: column; gap: 0.75rem; align-items: center; flex: 1; width: 100%; }
        .category-zone h4 { color: var(--text-secondary); margin-bottom: 1rem; font-size: 1.2rem; border-bottom: 2px solid var(--glass-border); padding-bottom: 0.5rem; width: 100%; }
        .category-zone.hover { border-color: var(--primary); background: var(--surface-hover); }

        .confetti { position: fixed; width: 10px; height: 10px; top: -20px; animation: fall 3s linear forwards; }
        @keyframes fall { to { transform: translateY(100vh) rotate(360deg); } }
    </style>
</head>
<body>

    <!-- Header -->
    <header class="header" id="header">
        <nav class="nav-container">
            <a href="index.html" class="logo" onclick="event.preventDefault(); navigateTo('index.html');">
                <svg class="logo-icon" viewBox="20 10 60 75" xmlns="http://www.w3.org/2000/svg" fill="none">
                    <path d="M20 85V40C20 34.4772 24.4772 30 30 30H40C45.5228 30 50 34.4772 50 40V85H20Z" fill="var(--primary-light)" fill-opacity="0.7"></path>
                    <path d="M50 85V20C50 14.4772 54.4772 10 60 10H70C75.5228 10 80 14.4772 80 20V85H50Z" fill="var(--primary)"></path>
                </svg>
                <span class="logo-text">LTD<span class="logo-text-extended">&nbsp;Simulator</span></span>
            </a>
            <div class="nav-desktop">
                 <form action="recherche.html" method="GET" class="header-search">
                     <i class="fas fa-search"></i>
                     <input type="search" name="query" placeholder="Rechercher..." aria-label="Rechercher">
                 </form>
                 <ul class="nav-menu">
                     <li class="nav-item"><a href="index.html" class="nav-link" onclick="event.preventDefault(); navigateTo('index.html')"><i class="fas fa-home"></i>&nbsp;Accueil</a></li>
                     <li class="nav-item"><a href="simulateur.html" class="nav-link active" onclick="event.preventDefault(); navigateTo('simulateur.html')"><i class="fas fa-gamepad"></i>&nbsp;Simulateurs</a></li>
                     <li class="nav-item"><a href="test.html" class="nav-link" onclick="event.preventDefault(); navigateTo('test.html')"><i class="fas fa-brain"></i>&nbsp;Tests</a></li>
                     <li class="nav-item"><a href="challenges.html" class="nav-link" onclick="event.preventDefault(); navigateTo('challenges.html')"><i class="fas fa-trophy"></i>&nbsp;Challenges</a></li>
                     <li class="nav-item"><a href="emploi.html" class="nav-link" onclick="event.preventDefault(); navigateTo('emploi.html')"><i class="fas fa-briefcase"></i>&nbsp;Nos offres d'emploi</a></li>
                     <li class="nav-item"><a href="histoire.html" class="nav-link" onclick="event.preventDefault(); navigateTo('histoire.html')"><i class="fas fa-scroll"></i>&nbsp;Histoire du BTP</a></li>
                     <li class="nav-item"><a href="#" class="nav-link" onclick="event.preventDefault(); navigateTo('quiz.html')"><i class="fas fa-question-circle"></i>&nbsp;Quiz</a></li>
                 </ul>
                 <div class="nav-actions">
                     <button class="theme-toggle" id="themeToggle" onclick="toggleTheme()" title="Changer de thème">
                         <i class="fas fa-moon" id="themeIcon"></i>
                     </button>
                 </div>
            </div>
            <button class="mobile-toggle" id="mobileToggle" onclick="toggleMobileMenu()">
                <span class="hamburger"><span></span><span></span><span></span></span>
            </button>
        </nav>
    </header>

    <!-- Mobile Menu -->
    <div class="mobile-menu" id="mobileMenu">
        <div class="mobile-menu-header">
            <a href="index.html" class="logo" onclick="event.preventDefault(); toggleMobileMenu(); navigateTo('index.html');">
                <svg class="logo-icon" viewBox="20 10 60 75" xmlns="http://www.w3.org/2000/svg" fill="none">
                    <path d="M20 85V40C20 34.4772 24.4772 30 30 30H40C45.5228 30 50 34.4772 50 40V85H20Z" fill="var(--primary-light)" fill-opacity="0.7"></path>
                    <path d="M50 85V20C50 14.4772 54.4772 10 60 10H70C75.5228 10 80 14.4772 80 20V85H50Z" fill="var(--primary)"></path>
                </svg>
                <span class="logo-text">LTD<span class="logo-text-extended">&nbsp;Simulator</span></span>
            </a>
            <button class="mobile-menu-close" onclick="toggleMobileMenu()"><i class="fas fa-times"></i></button>
        </div>
        <div class="mobile-menu-content">
            <div class="mobile-search-wrapper">
                <form action="recherche.html" method="GET" class="header-search">
                    <i class="fas fa-search"></i>
                    <input type="search" name="query" placeholder="Rechercher..." aria-label="Rechercher">
                </form>
            </div>
            <div class="mobile-nav-section">
                <h3>Navigation</h3>
                <div class="mobile-nav-items">
                    <!-- Mobile nav items will be populated by JS -->
                </div>
            </div>
        </div>
    </div>

    <!-- Main Content -->
    <main class="main-content">
        <div id="game-container">
            <!-- Écran d'accueil -->
            <div id="homeScreen" class="screen active game-card">
                <h1>Simulateur Projeteur VRD</h1>
                <p>Choisissez votre mode de jeu pour commencer.</p>
                <div class="mode-selection">
                    <button id="startDiscoveryBtn" class="btn">
                        <i class="fas fa-search-plus fa-2x"></i>
                        Mode Découverte
                        <span>Apprenez les bases du métier avec des jeux et explications.</span>
                    </button>
                    <button id="startProBtn" class="btn secondary">
                        <i class="fas fa-award fa-2x"></i>
                        Simulation Pro
                        <span>Testez vos connaissances avec des scénarios complexes.</span>
                    </button>
                </div>
            </div>

            <!-- Écran de question -->
            <div id="questionScreen" class="screen game-card">
                <div class="game-header">
                    <button id="changeModeBtn" class="btn secondary" title="Retour à l'accueil"><i class="fas fa-sign-out-alt"></i> Changer de Mode</button>
                    <div class="game-header-stats">
                        <div id="scoreDisplay" class="game-header-item">
                            <span>⭐</span>
                            <span id="score">0</span>
                        </div>
                        <div id="timerDisplay" class="game-header-item timer-display">
                            <span>⏰</span>
                            <span id="timer">--:--</span>
                        </div>
                    </div>
                </div>
                <h2 id="questionText"></h2>
                <div id="answerContainer"></div>
                <div id="feedbackText" class="feedback-text"></div>
                <div style="text-align: center; margin-top: 1.5rem;">
                    <button id="nextBtn" class="btn" style="display: none;">Question Suivante <i class="fas fa-arrow-right"></i></button>
                </div>
            </div>

            <!-- Écran final -->
            <div id="finalScreen" class="screen game-card">
                <h1>Simulation Terminée !</h1>
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-label">Score Final</div>
                        <div id="finalScore" class="stat-number">0</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Bonnes Réponses</div>
                        <div id="correctAnswers" class="stat-number">0 / 0</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Temps Total</div>
                        <div id="totalTime" class="stat-number">00:00</div>
                    </div>
                </div>
                <p id="finalMessage" style="font-size: 1.5rem; margin-top: 1rem; margin-bottom: 2rem;"></p>
                <button id="restartBtnFinal" class="btn">Recommencer le même mode <i class="fas fa-redo"></i></button>
                <button id="homeBtnFinal" class="btn secondary" style="margin-top: 1rem;">Retour à l'accueil</button>
            </div>
        </div>
    </main>

    <script>
        // --- HEADER & NAVIGATION SCRIPT ---
        let currentTheme = localStorage.getItem('theme') || 'dark';
        function navigateTo(pageFile) { window.location.href = pageFile; }
        function updateThemeUI() {
            const themeIcon = document.getElementById('themeIcon');
            if (!themeIcon) return;
            document.body.classList.toggle('light-mode', currentTheme === 'light');
            themeIcon.className = currentTheme === 'light' ? 'fas fa-sun' : 'fas fa-moon';
        }
        function toggleTheme() {
            currentTheme = currentTheme === 'light' ? 'dark' : 'light';
            localStorage.setItem('theme', currentTheme);
            updateThemeUI();
        }
        function toggleMobileMenu() {
            const mobileToggle = document.getElementById('mobileToggle');
            const mobileMenu = document.getElementById('mobileMenu');
            mobileToggle.classList.toggle('active');
            mobileMenu.classList.toggle('active');
            document.body.style.overflow = mobileMenu.classList.contains('active') ? 'hidden' : '';
        }

        // --- VRD SIMULATOR SCRIPT ---
        document.addEventListener('DOMContentLoaded', () => {
            // --- Initialisation du Header ---
            updateThemeUI();
            const desktopNav = document.querySelector('.nav-desktop .nav-menu');
            const mobileNavContainer = document.querySelector('.mobile-menu .mobile-nav-items');
            if(desktopNav && mobileNavContainer) {
                mobileNavContainer.innerHTML = '';
                desktopNav.querySelectorAll('.nav-item').forEach(item => {
                    const link = item.querySelector('a');
                    const newNavItem = document.createElement('a');
                    newNavItem.href = link.href;
                    newNavItem.className = 'mobile-nav-item';
                    newNavItem.onclick = (e) => {
                        e.preventDefault();
                        toggleMobileMenu();
                        if (link.href && !link.href.endsWith('#')) {
                            navigateTo(link.getAttribute('href'));
                        }
                    };
                    const iconDiv = document.createElement('div');
                    iconDiv.className = 'mobile-nav-item-icon';
                    iconDiv.innerHTML = link.querySelector('i').outerHTML;
                    const textNode = document.createElement('h4');
                    textNode.textContent = link.textContent.trim();
                    newNavItem.appendChild(iconDiv);
                    newNavItem.appendChild(textNode);
                    mobileNavContainer.appendChild(newNavItem);
                });
            }

            // --- SÉLECTION DES ÉLÉMENTS DU DOM ---
            const dom = {
                screens: { home: document.getElementById('homeScreen'), question: document.getElementById('questionScreen'), final: document.getElementById('finalScreen'), },
                buttons: { 
                    startDiscovery: document.getElementById('startDiscoveryBtn'), 
                    startPro: document.getElementById('startProBtn'), 
                    next: document.getElementById('nextBtn'), 
                    restartFinal: document.getElementById('restartBtnFinal'),
                    homeFinal: document.getElementById('homeBtnFinal'),
                    changeMode: document.getElementById('changeModeBtn')
                },
                displays: { 
                    score: document.getElementById('score'), 
                    scoreContainer: document.getElementById('scoreDisplay'),
                    timer: document.getElementById('timer'), 
                    timerContainer: document.getElementById('timerDisplay'), 
                    questionText: document.getElementById('questionText'), 
                    answerContainer: document.getElementById('answerContainer'), 
                    feedback: document.getElementById('feedbackText'), 
                    finalScore: document.getElementById('finalScore'), 
                    correctAnswers: document.getElementById('correctAnswers'), 
                    totalTime: document.getElementById('totalTime'), 
                    finalMessage: document.getElementById('finalMessage'), 
                },
            };

            // --- DONNÉES DU JEU ---
            const proQuestions = [
                // Set 1 & 2
                { type: 'qcm', text: "Quel est le rôle principal d'un Projeteur VRD ?", answers: [{ text: "Concevoir les bâtiments", correct: false }, { text: "Aménager les espaces extérieurs et réseaux", correct: true }, { text: "Gérer la comptabilité du chantier", correct: false }, { text: "Peindre les murs", correct: false }], solution: "Le Projeteur VRD (Voirie et Réseaux Divers) conçoit les routes, les systèmes d'assainissement, les réseaux d'eau, de gaz, d'électricité et de télécommunications.", points: 100, time: 30, },
                { type: 'multiple-choice', text: "Identifiez les matériaux adaptés pour une couche de fondation de chaussée. (Plusieurs réponses possibles)", answers: [{ text: "Terre végétale", correct: false, icon: "🌱" }, { text: "Grave non traitée (GNT)", correct: true, icon: "🪨" }, { text: "Sable", correct: false, icon: "🏖️" }, { text: "Grave-ciment", correct: true, icon: "🧱" }], solution: "La couche de fondation assure la portance de la chaussée. Les graves non traitées (GNT) et les graves traitées (comme le grave-ciment) sont des matériaux couramment utilisés.", points: 150, time: 45, },
                { type: 'calculation', text: "Un regard A est à une altitude de 125.50m. Un regard B, distant de 50m, est à 124.75m. Quelle est la pente du réseau en % ?", solution: "Calcul : ((125.50 - 124.75) / 50) * 100 = 1.5%.", correctAnswer: 1.5, tolerance: 0.01, points: 200, time: 60, },
                { type: 'pipe-connect', text: "Connectez le réseau d'eaux usées du point A au point B.", gridSize: { rows: 5, cols: 7 }, start: { row: 2, col: 0 }, end: { row: 2, col: 6 }, pieces: { straight: 5, corner: 4 }, solution: "Il faut créer un chemin continu de A à B en utilisant les pièces disponibles.", points: 350, time: 180, pipeColor: '#8B5CF6' },
                { type: 'chronological-order', text: "Mettez dans l'ordre les étapes de la construction d'une voirie simple.", items: ["Terrassement", "Mise en place de la couche de fondation", "Pose des bordures et caniveaux", "Application du revêtement (enrobé)", "Signalisation et finitions"], solution: "L'ordre logique est : Terrassement > Couche de fondation > Bordures/Caniveaux > Revêtement > Signalisation.", points: 250, time: 90, },
                { type: 'scenario', text: "Scénario : Erreur de conception", scenario: "Vous recevez un plan où un réseau d'eaux pluviales (EP) est connecté directement en amont d'une station d'épuration conçue uniquement pour les eaux usées (EU). Quelle est l'erreur majeure et que proposez-vous ?", answers: [{ text: "Aucune erreur, c'est une pratique standard.", correct: false }, { text: "L'erreur est le mélange des réseaux. Il faut créer un exutoire séparé pour les EP.", correct: true }, { text: "Il faut juste une plus grosse canalisation.", correct: false }, { text: "Il faut inverser le sens de la pente.", correct: false }], solution: "Les réseaux d'eaux pluviales et d'eaux usées doivent être séparatifs. Les EP n'ont pas besoin d'être traitées en station d'épuration et risqueraient de la saturer.", points: 300, time: 75, },
                { type: 'qcm', text: "De quelle couleur est le grillage avertisseur pour un réseau électrique enterré ?", answers: [{ text: "Bleu", correct: false }, { text: "Jaune", correct: false }, { text: "Rouge", correct: true }, { text: "Vert", correct: false }], solution: "Le grillage avertisseur rouge signale la présence d'un câble ou d'une canalisation électrique.", points: 100, time: 25 },
                { type: 'text-input', text: "Quel logiciel de CAO/DAO est le plus utilisé par les projeteurs VRD ?", correctAnswer: "AutoCAD", solution: "AutoCAD est le standard de l'industrie pour le dessin technique en 2D et 3D.", points: 120, time: 30 },
                { type: 'calculation', text: "Une route de 6m de large a une pente en travers de 2.5% depuis l'axe. Quelle est la différence de niveau (en cm) entre l'axe et le bord ?", correctAnswer: 7.5, tolerance: 0.1, solution: "Calcul : (6m / 2) * 0.025 = 0.075m, soit 7.5 cm.", points: 200, time: 60 },
                { type: 'multiple-choice', text: "Quels éléments font partie des 'réseaux secs' ?", answers: [{ text: "Adduction d'Eau Potable", correct: false, icon: "💧" }, { text: "Électricité (Basse Tension)", correct: true, icon: "⚡" }, { text: "Télécommunications (Fibre)", correct: true, icon: "📡" }, { text: "Assainissement EU", correct: false, icon: "🚽" }], solution: "Les réseaux secs transportent de l'énergie ou de l'information (électricité, télécom), par opposition aux réseaux humides (eau, assainissement).", points: 150, time: 40 },
                { type: 'chronological-order', text: "Ordonnez les couches d'une structure de chaussée, de la plus profonde à la surface.", items: ["Couche de forme", "Couche de fondation", "Couche de base", "Couche de roulement"], solution: "La structure est bâtie depuis le terrain naturel (couche de forme) jusqu'à la surface (couche de roulement).", points: 250, time: 70 },
                { type: 'qcm', text: "Que signifie 'DT-DICT' ?", answers: [{ text: "Document Technique - Dessin Industriel et Commercial", correct: false }, { text: "Déclaration de Travaux - Demande d'Intervention sur la Chaussée", correct: false }, { text: "Déclaration de projet de Travaux - Déclaration d'Intention de Commencement de Travaux", correct: true }, { text: "Dossier Technique - Directive Interne de Chantier", correct: false }], solution: "La DT-DICT est une procédure obligatoire pour s'informer sur la présence de réseaux enterrés avant de commencer des travaux.", points: 180, time: 45 },
                { type: 'calculation', text: "Un bassin de rétention a une surface de 200m². Il pleut 30 litres/m². Quel volume d'eau (en m³) le bassin doit-il stocker ?", correctAnswer: 6, tolerance: 0.1, solution: "Calcul : 200 m² * 30 L/m² = 6000 Litres. Comme 1000L = 1m³, le volume est de 6 m³.", points: 220, time: 75 },
                { type: 'text-input', text: "Comment nomme-t-on le plan représentant les altitudes du terrain le long d'un axe ?", correctAnswer: "Profil en long", solution: "Le profil en long est une coupe verticale qui montre le relief du terrain et le projet le long d'un axe.", points: 150, time: 40 },
                { type: 'scenario', text: "Scénario : Réseau inconnu", scenario: "En creusant une tranchée, vous découvrez une canalisation non répertoriée. Quelle est la première action à entreprendre ?", answers: [{ text: "Continuer en faisant attention.", correct: false }, { text: "Arrêter les travaux dans la zone et alerter le conducteur de travaux.", correct: true }, { text: "Essayer d'identifier le réseau en le perçant légèrement.", correct: false }, { text: "Recouvrir et ne rien dire.", correct: false }], solution: "La sécurité prime. Il faut immédiatement arrêter les travaux, sécuriser la zone et informer la hiérarchie.", points: 300, time: 60 },
                { type: 'pipe-connect', text: "Connectez le réseau de gaz. Le chemin doit passer par la vanne de coupure.", gridSize: { rows: 6, cols: 8 }, start: { row: 5, col: 3 }, end: { row: 0, col: 7 }, obstacles: [{row: 2, col: 4, type: 'valve'}], pieces: { straight: 8, corner: 6 }, solution: "Le chemin doit être continu de A à B et obligatoirement passer par la case 'valve'.", points: 400, time: 200, bonus: true, pipeColor: '#FBBF24' },
                { type: 'qcm', text: "Que signifie l'acronyme 'PMR' dans le contexte de l'aménagement urbain ?", answers: [{ text: "Personne à Mobilité Réduite", correct: true }, { text: "Plan de Maîtrise des Risques", correct: false }, { text: "Petit Matériel Roulant", correct: false }, { text: "Poste Mobile de Raccordement", correct: false }], solution: "PMR signifie Personne à Mobilité Réduite. Les aménagements VRD doivent garantir l'accessibilité pour tous.", points: 100, time: 30 },
                { type: 'qcm', text: "Dans un profil en travers, que représente le 'dévers' ?", answers: [{ text: "La pente longitudinale de la route", correct: false }, { text: "La pente transversale pour l'évacuation de l'eau", correct: true }, { text: "La hauteur du trottoir", correct: false }, { text: "L'épaisseur de la couche de roulement", correct: false }], solution: "Le dévers est la pente transversale d'une chaussée, essentielle pour évacuer les eaux de pluie vers les caniveaux.", points: 120, time: 35 },
                { type: 'calculation', text: "Un fossé de 80m de long a une section trapézoïdale de 0.5m². Quel volume de déblai (en m³) faut-il excaver ?", correctAnswer: 40, tolerance: 0.1, solution: "Calcul : Volume = Longueur × Section = 80m × 0.5m² = 40 m³.", points: 180, time: 50 },
                { type: 'text-input', text: "Comment s'appelle la partie supérieure intérieure d'une canalisation ?", correctAnswer: "Génératrice supérieure", solution: "La 'génératrice supérieure' est le point le plus haut à l'intérieur d'une conduite. Le point le plus bas est le 'fil d'eau'.", points: 150, time: 40 },
                { type: 'scenario', text: "Un plan montre une nouvelle canalisation de gaz passant à moins de 20 cm sous un câble électrique haute tension. Que faites-vous ?", answers: [{ text: "Valider le plan, la profondeur est suffisante.", correct: false }, { text: "Refuser le plan et exiger une distance de sécurité réglementaire.", correct: true }, { text: "Proposer de mettre les deux dans la même gaine.", correct: false }, { text: "Demander un grillage avertisseur plus épais.", correct: false }], solution: "Les règles de sécurité (norme NF P 98-332) imposent des distances minimales strictes entre les réseaux pour éviter les accidents. Ce croisement est non conforme et dangereux.", points: 300, time: 70 },
                { type: 'multiple-choice', text: "Parmi ces éléments, lesquels sont typiquement indiqués sur un plan de réseaux d'éclairage public ?", answers: [{ text: "Candélabre", correct: true, icon: "💡" }, { text: "Chambre de tirage", correct: true, icon: "🔳" }, { text: "Armoire de commande", correct: true, icon: "🎛️" }, { text: "Bouche à clé", correct: false, icon: "🔑" }], solution: "Un plan d'éclairage public détaille l'emplacement des candélabres, des armoires qui les alimentent et des chambres de tirage pour les câbles. Les bouches à clé concernent les réseaux d'eau.", points: 160, time: 50 },
                { type: 'chronological-order', text: "Ordonnez les phases d'un projet VRD, de l'idée à la réalisation.", items: ["Études préliminaires (AVP)", "Études de projet (PRO)", "Consultation des entreprises (DCE)", "Exécution des travaux (EXE)", "Réception des ouvrages (AOR)"], solution: "L'ordre est : Avant-Projet (AVP) > Projet (PRO) > Dossier de Consultation des Entreprises (DCE) > Exécution (EXE) > Assistance aux Opérations de Réception (AOR).", points: 280, time: 100 },
                { type: 'categorize', text: "Classez ces éléments dans les catégories 'Réseaux Humides' et 'Réseaux Secs'.", items: [{ text: "Eau potable", category: "humides" }, { text: "Fibre optique", category: "secs" }, { text: "Assainissement pluvial", category: "humides" }, { text: "Gaz", category: "secs" }, { text: "Basse tension", category: "secs" }, { text: "Chauffage urbain", category: "humides" }], categories: [{ id: "humides", title: "Réseaux Humides (fluides)" }, { id: "secs", title: "Réseaux Secs (énergie/info)" }], solution: "Humides : Eau potable, Assainissement, Chauffage urbain. Secs : Fibre optique, Gaz, Électricité.", points: 300, time: 80 },
                { type: 'qcm', text: "Qu'est-ce que le 'fil d'eau' d'une canalisation ?", answers: [{ text: "Le niveau le plus haut de l'eau", correct: false }, { text: "L'axe central de la canalisation", correct: false }, { text: "Le niveau intérieur inférieur où l'eau s'écoule", correct: true }, { text: "Un fil de nylon pour le curage", correct: false }], solution: "Le fil d'eau (FE) est la ligne la plus basse à l'intérieur d'un tuyau, déterminant le niveau de l'écoulement. C'est une cote de référence cruciale.", points: 120, time: 35 },
                { type: 'calculation', text: "Une tranchée fait 2m de profondeur et 0.8m de large. Pour 50m de long, quel est le volume de remblai nécessaire (en m³), en considérant un foisonnement de 20% des terres excavées ?", correctAnswer: 96, tolerance: 0.1, solution: "Volume excavé = 2 × 0.8 × 50 = 80 m³. Volume à remblayer avec foisonnement = 80 × 1.20 = 96 m³.", points: 250, time: 90 },
                { type: 'text-input', text: "Quel document contractuel décrit précisément les ouvrages à réaliser et leurs spécifications techniques ?", correctAnswer: "CCTP", solution: "Le CCTP (Cahier des Clauses Techniques Particulières) est la 'recette' technique du chantier. Il est rédigé par le projeteur ou l'ingénieur.", points: 180, time: 50 },
                { type: 'multiple-choice', text: "Quels types de bordures sont utilisés pour délimiter une chaussée d'un trottoir ?", answers: [{ text: "T2", correct: true, icon: "📐" }, { text: "P1", correct: true, icon: "📏" }, { text: "A2", correct: true, icon: "🗺️" }, { text: "Grave-bitume", correct: false, icon: "🧱" }], solution: "Les bordures de type T (Trottoir), P (Piste) et A (Accotement) sont conçues pour cet usage. La grave-bitume est un matériau de structure de chaussée.", points: 160, time: 50 },
                { type: 'scenario', text: "Un client souhaite un enrobé clair pour une place publique afin de lutter contre les îlots de chaleur. Quel est le principal inconvénient technique ?", answers: [{ text: "Son coût est identique à un enrobé classique.", correct: false }, { text: "Il est moins résistant au trafic lourd.", correct: false }, { text: "Il est plus sensible aux taches et plus éblouissant.", correct: true }, { text: "Il n'existe pas d'enrobé de couleur claire.", correct: false }], solution: "Les enrobés clairs, bien que thermiquement efficaces, se salissent plus vite (taches d'huile, etc.) et peuvent augmenter l'éblouissement par réflexion de la lumière (albédo élevé).", points: 280, time: 70 },
                { type: 'chronological-order', text: "Mettez dans l'ordre les couches d'un trottoir standard, du bas vers le haut.", items: ["Fond de forme (terrain naturel)", "Couche de fondation (grave)", "Lit de pose (sable)", "Revêtement (pavés ou enrobé)"], solution: "On construit un trottoir en partant du terrain compacté (fond de forme), puis la fondation, le lit de pose pour régler la surface, et enfin le revêtement final.", points: 250, time: 80 },
                { type: 'pipe-connect', text: "Raccordez le pluvial (A) à l'exutoire (B) en évitant l'ancienne conduite (Obstacle).", gridSize: { rows: 7, cols: 7 }, start: { row: 0, col: 3 }, end: { row: 6, col: 3 }, obstacles: [{row: 3, col: 2}, {row: 3, col: 3}, {row: 3, col: 4}], pieces: { straight: 7, corner: 6 }, solution: "Il fallait contourner l'obstacle central pour relier le départ et l'arrivée.", points: 400, time: 220, bonus: true, pipeColor: '#3B82F6' },
                { type: 'qcm', text: "Quelle est la pente minimale recommandée pour un caniveau à fente ?", answers: [{ text: "0.2%", correct: false }, { text: "0.5%", correct: true }, { text: "1.0%", correct: false }, { text: "Pas de pente minimale", correct: false }], solution: "Une pente d'au moins 0.5% est recommandée pour assurer un bon auto-curage et éviter la stagnation de l'eau et des sédiments dans les caniveaux à fente.", points: 130, time: 40 },
                // Set 3 (New Pro Questions)
                { type: 'qcm', text: "Quelle est la pente maximale réglementaire pour une rampe d'accès PMR sans palier de repos ?", answers: [{ text: "4%", correct: false }, { text: "5%", correct: true }, { text: "8%", correct: false }, { text: "10%", correct: false }], solution: "La réglementation sur l'accessibilité impose une pente maximale de 5% pour les rampes. Au-delà, des paliers de repos sont obligatoires.", points: 180, time: 45 },
                { type: 'text-input', text: "Dans le logiciel COVADIS, quelle commande permet de créer un profil en long à partir d'un axe en plan et d'un MNT ?", correctAnswer: "Covadis 3D > Profils en long par axe", solution: "La fonctionnalité 'Profils en long par axe' est fondamentale dans Covadis pour générer la vue en coupe du terrain naturel.", points: 200, time: 60 },
                { type: 'calculation', text: "Un volume de 100 m³ de terre en place (non remuée) a un coefficient de foisonnement de 1.25. Quel volume de transport (en m³) faut-il prévoir ?", correctAnswer: 125, tolerance: 0.1, solution: "Le volume après excavation sera de 100 m³ * 1.25 = 125 m³. Il faut prévoir des camions pour ce volume foisonné.", points: 220, time: 70 },
                { type: 'scenario', text: "Vous devez concevoir une route dans une zone argileuse sensible au retrait-gonflement. Quelle précaution est indispensable ?", answers: [{ text: "Utiliser un enrobé plus épais.", correct: false }, { text: "Réaliser un traitement de sol à la chaux et/ou au ciment.", correct: true }, { text: "Augmenter la pente de la route.", correct: false }, { text: "Poser un géotextile simple.", correct: false }], solution: "Le traitement des sols argileux à la chaux ou au ciment est une technique courante pour les rendre insensibles à l'eau et garantir la stabilité de la chaussée.", points: 320, time: 80 },
                { type: 'multiple-choice', text: "Quels éléments sont obligatoires dans un Dossier de Consultation des Entreprises (DCE) ?", answers: [{ text: "Le CCTP", correct: true, icon: "📜" }, { text: "L'Acte d'Engagement (AE)", correct: true, icon: "✍️" }, { text: "Le planning prévisionnel des travaux", correct: true, icon: "🗓️" }, { text: "La photo du terrain", correct: false, icon: "🖼️" }], solution: "Le CCTP (spécifications techniques), l'AE (contrat) et le planning sont des pièces maîtresses du DCE qui permettent aux entreprises de chiffrer le projet.", points: 250, time: 75 },
                { type: 'qcm', text: "Qu'est-ce qu'un 'géotextile' et quelle est sa fonction principale sous une voirie ?", answers: [{ text: "Une bâche plastique pour l'étanchéité.", correct: false }, { text: "Un tissu technique qui sépare les couches de matériaux.", correct: true }, { text: "Un filet métallique pour armer le béton.", correct: false }, { text: "Une couche de sable fin.", correct: false }], solution: "Le géotextile est un feutre qui empêche les matériaux fins (sable, terre) de remonter et de 'polluer' la structure de la chaussée, assurant ainsi sa pérennité.", points: 150, time: 50 },
                { type: 'text-input', text: "Comment appelle-t-on l'ouvrage qui permet de retenir la terre sur une forte pente ?", correctAnswer: "Mur de soutènement", solution: "Un mur de soutènement est un ouvrage de génie civil destiné à contenir les terres et à prévenir les glissements de terrain.", points: 160, time: 40 },
                { type: 'calculation', text: "La vitesse de référence d'une route est de 80 km/h. Quel est le dévers minimal à appliquer dans un virage de 200m de rayon pour assurer la sécurité ?", correctAnswer: 4, tolerance: 0.5, solution: "Bien que la formule exacte soit complexe (formule de VATE), un ordre de grandeur commun pour cette situation est un dévers d'environ 4 à 5%.", points: 280, time: 90 },
                { type: 'scenario', text: "Le plan topographique indique un arbre classé 'Espace Boisé Classé' en plein milieu de votre projet de parking. Que faites-vous ?", answers: [{ text: "Vous prévoyez de l'abattre et de le remplacer.", correct: false }, { text: "Vous modifiez l'implantation du parking pour le préserver.", correct: true }, { text: "Vous demandez une dérogation pour l'enlever.", correct: false }, { text: "Vous ignorez l'information.", correct: false }], solution: "Un élément classé est protégé par la loi. Le projet doit impérativement être adapté pour le conserver. C'est une contrainte forte à intégrer dès le début.", points: 300, time: 60 },
                { type: 'qcm', text: "À quoi sert le 'blindage' d'une tranchée ?", answers: [{ text: "À la protéger de la pluie.", correct: false }, { text: "À empêcher les parois de s'effondrer.", correct: true }, { text: "À guider les canalisations.", correct: false }, { text: "À la rendre invisible.", correct: false }], solution: "Le blindage est un dispositif de sécurité essentiel qui soutient les parois d'une fouille pour protéger les travailleurs contre les risques d'ensevelissement.", points: 170, time: 40 }
            ];

            const discoveryQuestions = [
                // Set 1
                { type: 'qcm', text: "Que signifie 'VRD' ?", answers: [{ text: "Vraiment Rapide et Dangereux", correct: false }, { text: "Voirie et Réseaux Divers", correct: true }, { text: "Voitures, Rues, Domiciles", correct: false }], solution: "'VRD' est l'acronyme de Voirie et Réseaux Divers. Cela concerne tout ce qui est construit sur l'espace public : routes, trottoirs, et réseaux souterrains.", points: 10, time: 60 },
                { type: 'multiple-choice', text: "Quels sont les deux grands types de réseaux souterrains ?", answers: [{ text: "Réseaux Humides (eau)", correct: true, icon: "💧" }, { text: "Réseaux Secs (énergie/câbles)", correct: true, icon: "⚡" }, { text: "Réseaux Mous (sable)", correct: false, icon: "🏖️" }, { text: "Réseaux Durs (roche)", correct: false, icon: "🪨" }], solution: "On classe les réseaux en 'humides' pour ceux qui transportent des liquides (eau, assainissement) et 'secs' pour ceux qui transportent de l'énergie ou de l'information (électricité, gaz, fibre).", points: 10, time: 60 },
                { type: 'categorize', text: "Triez ces éléments : où vont-ils ?", items: [{ text: "Un piéton", category: "trottoir" }, { text: "Une voiture", category: "chaussee" }, { text: "Un vélo", category: "chaussee" }, { text: "L'eau de pluie", category: "caniveau" }], categories: [{ id: "trottoir", title: "Trottoir" }, { id: "chaussee", title: "Chaussée (Route)" }, { id: "caniveau", title: "Caniveau" }], solution: "Chaque aménagement a un rôle : le trottoir pour les piétons, la chaussée pour les véhicules, et le caniveau pour récupérer l'eau.", points: 15, time: 90 },
                { type: 'qcm', text: "Pourquoi met-on une pente sur une route ?", answers: [{ text: "Pour que les voitures aillent plus vite", correct: false }, { text: "Pour évacuer l'eau de pluie sur les côtés", correct: true }, { text: "C'est plus joli", correct: false }], solution: "La pente, appelée 'dévers', est cruciale pour que l'eau de pluie ne stagne pas sur la route, ce qui la rendrait glissante et dangereuse.", points: 10, time: 60 },
                { type: 'text-input', text: "Quel est le nom du grand plan qui montre tout le projet vu de dessus ?", correctAnswer: "Plan de masse", solution: "Le 'plan de masse' est une vue aérienne qui présente l'ensemble du projet d'aménagement et sa situation dans l'environnement.", points: 15, time: 75 },
                { type: 'pipe-connect', text: "Jeu : Reliez la maison (A) au réseau d'eau (B).", gridSize: { rows: 4, cols: 5 }, start: { row: 1, col: 0 }, end: { row: 3, col: 4 }, pieces: { straight: 4, corner: 3 }, solution: "Excellent ! Vous avez raccordé la maison au réseau public d'eau potable.", points: 20, time: 120, pipeColor: '#3B82F6' },
                { type: 'qcm', text: "À quoi sert un 'regard' sur un réseau d'assainissement ?", answers: [{ text: "À regarder si l'eau est propre", correct: false }, { text: "À permettre l'accès pour nettoyer ou inspecter", correct: true }, { text: "À décorer le trottoir", correct: false }], solution: "Les regards (les plaques que l'on voit au sol) sont des points d'accès essentiels pour la maintenance des réseaux souterrains.", points: 10, time: 60 },
                { type: 'chronological-order', text: "Jeu : Mettez dans l'ordre ces 3 étapes simples pour faire un trottoir.", items: ["Creuser le sol", "Mettre une couche de cailloux", "Poser le revêtement (pavés)"], solution: "On prépare le sol en creusant, on stabilise avec une couche de base (cailloux), puis on pose la surface sur laquelle on marche.", points: 15, time: 90 },
                // Set 2 (New Discovery Questions)
                { type: 'qcm', text: "Qu'est-ce qu'un 'caniveau' ?", answers: [{ text: "Un petit canal pour guider l'eau de pluie", correct: true }, { text: "Un type de banc public", correct: false }, { text: "Une barrière de sécurité", correct: false }], solution: "Le caniveau, souvent situé le long du trottoir, est essentiel pour collecter l'eau de pluie et l'envoyer vers le réseau d'assainissement.", points: 10, time: 60 },
                { type: 'multiple-choice', text: "Quels éléments de signalisation trouve-t-on sur une route ?", answers: [{ text: "Panneaux de signalisation", correct: true, icon: "🛑" }, { text: "Marquage au sol (lignes blanches)", correct: true, icon: "➖" }, { text: "Feux tricolores", correct: true, icon: "🚦" }, { text: "Arbres", correct: false, icon: "🌳" }], solution: "La sécurité routière dépend de la signalisation : les panneaux, les lignes au sol et les feux guident les conducteurs.", points: 10, time: 60 },
                { type: 'text-input', text: "Comment s'appelle le plan qui montre une 'tranche' de la route pour voir les différentes couches ?", correctAnswer: "Profil en travers", solution: "Le 'profil en travers' est une coupe qui montre la structure de la chaussée, les trottoirs, les pentes, etc. C'est comme une tranche de gâteau !", points: 15, time: 75 },
                { type: 'qcm', text: "Pourquoi les plaques d'égout sont-elles rondes ?", answers: [{ text: "Pour qu'elles ne puissent pas tomber dans le trou", correct: true }, { text: "C'est plus facile à fabriquer", correct: false }, { text: "Pour qu'elles roulent mieux", correct: false }], solution: "Une plaque ronde ne peut pas tomber à travers son propre trou, quelle que soit son orientation. C'est une astuce de conception pour la sécurité !", points: 10, time: 60 },
                { type: 'categorize', text: "Triez ces actions : qui fait quoi ?", items: [{ text: "Dessine les plans", category: "projeteur" }, { text: "Conduit la pelleteuse", category: "conducteur" }, { text: "Pose les tuyaux", category: "ouvrier" }], categories: [{ id: "projeteur", title: "Le Projeteur" }, { id: "conducteur", title: "Le Conducteur d'engins" }, { id: "ouvrier", title: "L'Ouvrier" }], solution: "Chacun a son rôle ! Le projeteur conçoit sur ordinateur, et les équipes sur le chantier réalisent les travaux.", points: 15, time: 90 },
                { type: 'pipe-connect', text: "Jeu : L'eau de pluie du toit (A) doit aller au caniveau (B). Connectez le tuyau !", gridSize: { rows: 4, cols: 4 }, start: { row: 0, col: 1 }, end: { row: 3, col: 3 }, pieces: { straight: 3, corner: 2 }, solution: "Parfait ! Vous avez créé une gouttière pour évacuer l'eau de pluie loin de la maison.", points: 20, time: 120, pipeColor: '#0EA5E9' },
                { type: 'qcm', text: "À quoi sert un 'lampadaire' ?", answers: [{ text: "À faire de l'ombre", correct: false }, { text: "À décorer la ville", correct: false }, { text: "À éclairer les rues la nuit", correct: true }], solution: "L'éclairage public, assuré par les lampadaires (ou candélabres), est un réseau essentiel pour la sécurité et le confort la nuit.", points: 10, time: 60 },
                { type: 'qcm', text: "Quel est l'outil principal d'un projeteur VRD aujourd'hui ?", answers: [{ text: "Une pelle et une pioche", correct: false }, { text: "Un ordinateur avec des logiciels de dessin", correct: true }, { text: "Un camion de chantier", correct: false }], solution: "Le projeteur est avant tout un technicien de bureau d'études. Son outil principal est l'ordinateur, avec des logiciels de Dessin Assisté par Ordinateur (DAO) comme AutoCAD.", points: 10, time: 60 }
            ];
            
            let gameState = {};
            
            // --- GESTION AUDIO ---
            let isSoundOn = false; // Le son est désactivé par défaut
            const sounds = {
                start: new Tone.Synth({ oscillator: { type: "fatsawtooth" }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.3 } }).toDestination(),
                correct: new Tone.Synth({ oscillator: { type: "triangle" }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.2 } }).toDestination(),
                incorrect: new Tone.Synth({ oscillator: { type: "square" }, envelope: { attack: 0.01, decay: 0.3, sustain: 0, release: 0.2 } }).toDestination(),
                finish: new Tone.Synth({ oscillator: { type: "sine" }, envelope: { attack: 0.1, decay: 0.5, sustain: 0.3, release: 1 } }).toDestination(),
                click: new Tone.MembraneSynth({ pitchDecay: 0.01, octaves: 2, envelope: { attack: 0.001, decay: 0.2, sustain: 0 } }).toDestination(),
                timer_tick: new Tone.Synth({ oscillator: { type: 'sine' }, volume: -10, envelope: { attack: 0.001, decay: 0.1, sustain: 0, release: 0.1 } }).toDestination(),
                drag: new Tone.NoiseSynth({ noise: { type: 'pink' }, volume: -15, envelope: { attack: 0.005, decay: 0.05, sustain: 0 } }).toDestination(),
                drop: new Tone.MembraneSynth({ pitchDecay: 0.008, octaves: 4, envelope: { attack: 0.001, decay: 0.3, sustain: 0 } }).toDestination(),
                confetti: new Tone.PluckSynth({ attackNoise: 1, dampening: 4000, resonance: 0.7 }).toDestination()
            };
            
            function playSound(sound, ...args) {
                if (isSoundOn && sound && typeof sound.triggerAttackRelease === 'function') {
                    try {
                        sound.triggerAttackRelease(...args);
                    } catch (e) {
                        console.error("Audio playback error:", e);
                    }
                }
            }

            // --- FONCTIONS PRINCIPALES DU JEU ---
            function initGame() {
                if (gameState.timerInterval) clearInterval(gameState.timerInterval);
                if (gameState.totalTimeInterval) clearInterval(gameState.totalTimeInterval);
                
                gameState = { score: 0, currentQuestionIndex: -1, timeLeft: 0, timerInterval: null, totalTime: 0, totalTimeInterval: null, questions: [], answeredQuestions: [], isQuestionAnswered: false, mode: null };
                updateScore(0);
                switchScreen('home');
                dom.displays.timer.textContent = '--:--';
                dom.displays.timerContainer.classList.remove('warning');
            }

            function startGame(mode) {
                Tone.start().then(() => {
                    isSoundOn = true;
                    playSound(sounds.start, "C4", "8n");
                });
                
                gameState.mode = mode;
                const questionsToLoad = mode === 'discovery' ? discoveryQuestions : proQuestions;
                gameState.questions = shuffleArray([...questionsToLoad]);
                gameState.answeredQuestions = new Array(gameState.questions.length).fill(null);
                
                startTotalTimer();
                nextQuestion();
            }

            function nextQuestion() {
                if (gameState.currentQuestionIndex >= gameState.questions.length - 1) { endGame(); return; }
                gameState.currentQuestionIndex++;
                displayQuestion();
            }

            function displayQuestion() {
                clearInterval(gameState.timerInterval);
                dom.displays.feedback.innerHTML = '';
                dom.buttons.next.style.display = 'none';
                
                const question = gameState.questions[gameState.currentQuestionIndex];
                gameState.isQuestionAnswered = false;
                
                dom.displays.questionText.innerHTML = `Question ${gameState.currentQuestionIndex + 1}/${gameState.questions.length}: ${question.text}`;
                dom.displays.answerContainer.innerHTML = '';
                
                // Affichage conditionnel des stats
                dom.displays.scoreContainer.style.display = gameState.mode === 'pro' ? 'flex' : 'none';
                dom.displays.timerContainer.style.display = gameState.mode === 'pro' ? 'flex' : 'none';

                const interfaceBuilder = { 
                    'qcm': createQCMInterface, 
                    'scenario': createQCMInterface, 
                    'multiple-choice': createMultipleChoiceInterface, 
                    'calculation': createCalculationInterface, 
                    'text-input': createTextInputInterface, 
                    'chronological-order': createDragDropOrderInterface, 
                    'pipe-connect': createPipeConnectInterface,
                    'categorize': createCategorizeInterface
                }[question.type];

                if (interfaceBuilder) interfaceBuilder(question);
                
                startTimer(question.time);
                switchScreen('question');
            }

            function endGame() {
                clearInterval(gameState.timerInterval);
                clearInterval(gameState.totalTimeInterval);
                playSound(sounds.finish, "C5", "1n", Tone.now() + 0.1);
                launchConfetti();
                
                const correctCount = gameState.answeredQuestions.filter(a => a && a.isCorrect).length;
                const totalQuestions = gameState.questions.length;
                
                dom.displays.finalScore.textContent = gameState.score;
                dom.displays.correctAnswers.textContent = `${correctCount} / ${totalQuestions}`;
                dom.displays.totalTime.textContent = formatTime(gameState.totalTime);
                
                let message;
                if (gameState.mode === 'discovery') {
                    message = "Bravo ! Vous avez exploré les bases du métier de projeteur VRD.";
                } else {
                    if (correctCount / totalQuestions < 0.5) message = "C'est un bon début, continuez à vous entraîner !";
                    else if (correctCount / totalQuestions < 0.8) message = "Très bon score, vous progressez bien !";
                    else message = "Excellent travail ! Vous avez l'étoffe d'un expert !";
                }
                dom.displays.finalMessage.textContent = message;
                
                switchScreen('final');
            }

            function createQCMInterface(question) {
                const answerGrid = document.createElement('div');
                answerGrid.className = 'answer-grid';
                question.answers.forEach((answer, index) => {
                    const btn = document.createElement('button');
                    btn.className = 'answer-btn';
                    btn.innerHTML = answer.text;
                    btn.onclick = () => handleAnswer(index, index);
                    answerGrid.appendChild(btn);
                });
                dom.displays.answerContainer.appendChild(answerGrid);
            }

            function createMultipleChoiceInterface(question) {
                const materialGrid = document.createElement('div');
                materialGrid.className = 'material-grid';
                question.answers.forEach((answer, index) => {
                    const card = document.createElement('div');
                    card.className = 'material-card';
                    card.dataset.index = index;
                    card.innerHTML = `<div class="material-icon">${answer.icon || '❔'}</div><p>${answer.text}</p>`;
                    card.onclick = () => { if (!gameState.isQuestionAnswered) card.classList.toggle('selected'); };
                    materialGrid.appendChild(card);
                });
                dom.displays.answerContainer.appendChild(materialGrid);
                addSubmitButton(() => {
                    const selectedCards = dom.displays.answerContainer.querySelectorAll('.material-card.selected');
                    const selectedIndices = Array.from(selectedCards).map(c => parseInt(c.dataset.index));
                    handleAnswer(selectedIndices, selectedIndices);
                });
            }

            function createCalculationInterface(question) {
                const input = document.createElement('input');
                input.type = 'number';
                input.step = 'any';
                input.className = 'elevation-input';
                input.placeholder = 'Votre réponse...';
                dom.displays.answerContainer.appendChild(input);
                addSubmitButton(() => { const value = parseFloat(input.value); if (!isNaN(value)) handleAnswer(value, value); });
            }

            function createTextInputInterface(question) {
                const input = document.createElement('input');
                input.type = 'text';
                input.className = 'text-input';
                input.placeholder = 'Votre réponse...';
                dom.displays.answerContainer.appendChild(input);
                addSubmitButton(() => { const value = input.value.trim(); if (value) handleAnswer(value, value); });
            }
            
            function createDragDropOrderInterface(question) {
                const container = document.createElement('div');
                container.className = 'drop-zone-container';
                const dropZone = document.createElement('div');
                dropZone.className = 'category-zone';
                dropZone.style.minHeight = 'auto';
                dropZone.innerHTML = '<h4>Ordonnez les étapes ici</h4>';
                const draggableContainer = document.createElement('div');
                draggableContainer.className = 'draggable-container';
                shuffleArray([...question.items]).forEach((item) => {
                    const el = createDraggableElement(item, item);
                    draggableContainer.appendChild(el);
                });
                container.appendChild(dropZone);
                container.appendChild(draggableContainer);
                dom.displays.answerContainer.appendChild(container);
                setupDragDrop([dropZone, draggableContainer]);
                addSubmitButton(() => { const droppedItems = Array.from(dropZone.querySelectorAll('.draggable')).map(child => child.dataset.id); handleAnswer(droppedItems, droppedItems); });
            }

            function createCategorizeInterface(question) {
                const container = document.createElement('div');
                container.className = 'drop-zone-container';
                const categoryContainer = document.createElement('div');
                categoryContainer.className = 'category-container';
                question.categories.forEach(cat => {
                    const zone = document.createElement('div');
                    zone.className = 'category-zone';
                    zone.dataset.category = cat.id;
                    zone.innerHTML = `<h4>${cat.title}</h4>`;
                    categoryContainer.appendChild(zone);
                });
                const draggableContainer = document.createElement('div');
                draggableContainer.className = 'draggable-container';
                shuffleArray([...question.items]).forEach((item) => {
                    const el = createDraggableElement(item.text, item.text, item.category);
                    draggableContainer.appendChild(el);
                });
                container.appendChild(categoryContainer);
                container.appendChild(draggableContainer);
                dom.displays.answerContainer.appendChild(container);
                setupDragDrop([...categoryContainer.children, draggableContainer]);
                addSubmitButton(() => {
                    const answer = {};
                    categoryContainer.querySelectorAll('.category-zone').forEach(zone => {
                        answer[zone.dataset.category] = Array.from(zone.querySelectorAll('.draggable')).map(el => el.dataset.id);
                    });
                    handleAnswer(answer, answer);
                });
            }

            function createDraggableElement(id, text, category = '') {
                const el = document.createElement('div');
                el.className = 'draggable';
                el.textContent = text;
                el.draggable = true;
                el.dataset.id = id;
                if (category) el.dataset.category = category;
                el.addEventListener('dragstart', e => { playSound(sounds.drag, "8n"); e.dataTransfer.setData('text/plain', id); setTimeout(() => el.style.opacity = '0.5', 0); });
                el.addEventListener('dragend', () => el.style.opacity = '1');
                return el;
            }

            function setupDragDrop(zones) {
                zones.forEach(zone => {
                    zone.addEventListener('dragover', e => { e.preventDefault(); zone.classList.add('hover'); });
                    zone.addEventListener('dragleave', () => zone.classList.remove('hover'));
                    zone.addEventListener('drop', e => {
                        e.preventDefault();
                        playSound(sounds.drop, "C3", "8n");
                        zone.classList.remove('hover');
                        const id = e.dataTransfer.getData('text/plain');
                        const draggable = document.querySelector(`.draggable[data-id="${id}"]`);
                        if (draggable) zone.appendChild(draggable);
                    });
                });
            }
            
            function createPipeConnectInterface(question) {
                const container = document.createElement('div');
                container.className = 'pipe-game-container';
                const pipeTray = document.createElement('div');
                pipeTray.className = 'pipe-tray';
                const createDraggablePipe = (type, count) => {
                    const piece = document.createElement('div');
                    piece.className = 'pipe-piece-draggable';
                    piece.draggable = true;
                    piece.dataset.pipeType = type;
                    piece.innerHTML = getPipeSVG(type, 0, question.pipeColor) + `<span class="pipe-count" id="pipe-count-${type}">${count}</span>`;
                    piece.addEventListener('dragstart', e => { 
                        if (parseInt(piece.querySelector(`#pipe-count-${type}`).textContent) > 0) { 
                            playSound(sounds.drag, "8n"); 
                            e.dataTransfer.setData('text/plain', type); 
                            piece.classList.add('dragging'); 
                        } else { 
                            e.preventDefault(); 
                        } 
                    });
                    piece.addEventListener('dragend', () => piece.classList.remove('dragging'));
                    return piece;
                };
                Object.keys(question.pieces).forEach(type => pipeTray.appendChild(createDraggablePipe(type, question.pieces[type])));
                const gridContainer = document.createElement('div');
                gridContainer.className = 'pipe-grid-container';
                gridContainer.style.setProperty('--grid-cols', question.gridSize.cols);
                gridContainer.id = 'pipe-grid';
                for (let r = 0; r < question.gridSize.rows; r++) {
                    for (let c = 0; c < question.gridSize.cols; c++) {
                        const cell = document.createElement('div');
                        cell.className = 'grid-cell';
                        cell.dataset.row = r;
                        cell.dataset.col = c;
                        if (r === question.start.row && c === question.start.col) cell.classList.add('start-node');
                        else if (r === question.end.row && c === question.end.col) cell.classList.add('end-node');
                        else if (question.obstacles?.some(o => o.row === r && o.col === c)) {
                            cell.classList.add('obstacle-node');
                            cell.innerHTML = `<div style="width: 66%; height: 66%; color: var(--text-muted);"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M18.364 18.364a9 9 0 1 1-12.728-12.728A9 9 0 0 1 18.364 18.364zM12 16a4 4 0 1 0 0-8 4 4 0 0 0 0 8z"/><path d="m4 4 16 16"/></svg></div>`;
                            cell.dataset.obstacle = true;
                        }
                        cell.addEventListener('dragover', e => { if (!cell.hasChildNodes()) e.preventDefault(); });
                        cell.addEventListener('drop', e => {
                            e.preventDefault();
                            if (cell.innerHTML !== '' || cell.classList.contains('start-node') || cell.classList.contains('end-node') || cell.dataset.obstacle) return;
                            const type = e.dataTransfer.getData('text/plain');
                            const countEl = document.getElementById(`pipe-count-${type}`);
                            let count = parseInt(countEl.textContent);
                            if (count > 0) {
                                playSound(sounds.drop, "C3", "8n");
                                count--;
                                countEl.textContent = count;
                                const placedPiece = document.createElement('div');
                                placedPiece.className = 'pipe-piece-placed';
                                placedPiece.dataset.pipeType = type;
                                placedPiece.dataset.rotation = 0;
                                placedPiece.innerHTML = getPipeSVG(type, 0, question.pipeColor);
                                placedPiece.addEventListener('click', () => {
                                    if (gameState.isQuestionAnswered) return;
                                    let currentRotation = parseInt(placedPiece.dataset.rotation);
                                    currentRotation = (currentRotation + 90) % 360;
                                    placedPiece.dataset.rotation = currentRotation;
                                    placedPiece.style.transform = `rotate(${currentRotation}deg)`;
                                });
                                placedPiece.addEventListener('contextmenu', (ev) => {
                                    ev.preventDefault();
                                    if (gameState.isQuestionAnswered) return;
                                    cell.innerHTML = '';
                                    const typeToRemove = placedPiece.dataset.pipeType;
                                    const countElToRemove = document.getElementById(`pipe-count-${typeToRemove}`);
                                    countElToRemove.textContent = parseInt(countElToRemove.textContent) + 1;
                                });
                                cell.appendChild(placedPiece);
                            }
                        });
                        gridContainer.appendChild(cell);
                    }
                }
                container.appendChild(pipeTray);
                container.appendChild(gridContainer);
                dom.displays.answerContainer.appendChild(container);
                addSubmitButton(() => {
                    const placedPipes = [];
                    gridContainer.querySelectorAll('.pipe-piece-placed').forEach(p => {
                        const cell = p.parentElement;
                        placedPipes.push({ row: parseInt(cell.dataset.row), col: parseInt(cell.dataset.col), type: p.dataset.pipeType, rotation: parseInt(p.dataset.rotation) });
                    });
                    handleAnswer(placedPipes, placedPipes);
                }, 'Vérifier');
            }

            function addSubmitButton(callback, text = 'Valider') {
                const submitBtn = document.createElement('button');
                submitBtn.textContent = text;
                submitBtn.className = 'btn';
                submitBtn.style.marginTop = '2rem';
                submitBtn.onclick = callback;
                dom.displays.answerContainer.appendChild(submitBtn);
            }

            function handleAnswer(userAnswer, answerForStorage) {
                if (gameState.isQuestionAnswered) return;

                const question = gameState.questions[gameState.currentQuestionIndex];
                if (!question) {
                    clearInterval(gameState.timerInterval);
                    return;
                }

                clearInterval(gameState.timerInterval);
                gameState.isQuestionAnswered = true;
                
                let isCorrect = false;
                switch (question.type) {
                    case 'qcm': case 'scenario': isCorrect = userAnswer !== null && question.answers[userAnswer].correct; break;
                    case 'multiple-choice':
                        const correctIndices = question.answers.map((a, i) => a.correct ? i : -1).filter(i => i !== -1);
                        isCorrect = userAnswer && userAnswer.length === correctIndices.length && userAnswer.every(index => correctIndices.includes(index));
                        break;
                    case 'calculation': isCorrect = userAnswer !== null && Math.abs(userAnswer - question.correctAnswer) <= (question.tolerance || 0.01); break;
                    case 'text-input': isCorrect = userAnswer && userAnswer.toLowerCase().trim() === question.correctAnswer.toLowerCase().trim(); break;
                    case 'chronological-order': isCorrect = userAnswer && userAnswer.length === question.items.length && userAnswer.every((item, index) => item === question.items[index]); break;
                    case 'pipe-connect': isCorrect = checkPipeConnection(userAnswer, question); break;
                    case 'categorize':
                        isCorrect = true;
                        for(const item of question.items) {
                            const correctCategory = item.category;
                            const placedCategory = Object.keys(userAnswer).find(cat => userAnswer[cat].includes(item.text));
                            if(correctCategory !== placedCategory) {
                                isCorrect = false;
                                break;
                            }
                        }
                        const allPlacedItems = Object.values(userAnswer).flat();
                        if (allPlacedItems.length !== question.items.length) isCorrect = false;
                        break;
                }
                gameState.answeredQuestions[gameState.currentQuestionIndex] = { answer: answerForStorage, isCorrect: isCorrect };
                if (isCorrect) {
                    playSound(sounds.correct, "C5", "8n", Tone.now() + 0.1);
                    dom.displays.feedback.innerHTML = "Bonne réponse !";
                    dom.displays.feedback.style.color = 'var(--correct)';
                    let pointsGained = question.points;
                    if (question.bonus && gameState.mode === 'pro') pointsGained *= 2;
                    updateScore(gameState.score + pointsGained);
                } else {
                    playSound(sounds.incorrect, "C3", "8n", Tone.now() + 0.1);
                    dom.displays.feedback.innerHTML = `Réponse incorrecte. <br><span class="feedback-solution">${question.solution}</span>`;
                    dom.displays.feedback.style.color = 'var(--incorrect)';
                }
                showSolutionVisuals(question, isCorrect);
                dom.buttons.next.style.display = 'inline-flex';
            }

            function showSolutionVisuals(question, isCorrect) {
                const answerElements = dom.displays.answerContainer.querySelectorAll('.answer-btn, .material-card, .draggable, .pipe-piece-placed, input, button, .pipe-piece-draggable');
                answerElements.forEach(el => { el.style.pointerEvents = 'none'; el.disabled = true; if(el.classList.contains('material-card')) el.classList.add('disabled'); });
                switch (question.type) {
                    case 'qcm': case 'scenario': dom.displays.answerContainer.querySelectorAll('.answer-btn').forEach((btn, index) => { if (question.answers[index].correct) btn.classList.add('correct'); }); break;
                    case 'multiple-choice':
                        dom.displays.answerContainer.querySelectorAll('.material-card').forEach((card, index) => {
                            const isSelected = card.classList.contains('selected');
                            const isCorrectAnswer = question.answers[index].correct;
                            if (isCorrectAnswer) card.classList.add('correct');
                            else if (isSelected && !isCorrectAnswer) card.classList.add('incorrect');
                        });
                        break;
                    case 'categorize':
                        dom.displays.answerContainer.querySelectorAll('.draggable').forEach(el => {
                            const correctCategory = el.dataset.category;
                            const placedCategory = el.parentElement.dataset.category;
                            if (correctCategory === placedCategory) {
                                el.classList.add('correct');
                            } else {
                                el.classList.add('incorrect');
                            }
                        });
                        break;
                    case 'chronological-order':
                         dom.displays.answerContainer.querySelectorAll('.draggable').forEach(el => {
                            const userOrder = Array.from(el.parentElement.children).map(child => child.dataset.id);
                            const correctIndex = question.items.indexOf(el.dataset.id);
                            const userIndex = userOrder.indexOf(el.dataset.id);
                            if (el.parentElement.classList.contains('category-zone')) {
                                if (correctIndex === userIndex) {
                                    el.classList.add('correct');
                                } else {
                                    el.classList.add('incorrect');
                                }
                            }
                         });
                         break;
                }
            }
            
            function getPipeSVG(type, rotation, color) {
                let path = '';
                if (type === 'straight') path = `<path d="M0 50 L100 50" stroke="${color}" stroke-width="15" stroke-linecap="round" />`;
                else if (type === 'corner') path = `<path d="M0 50 L50 50 L50 100" stroke="${color}" stroke-width="15" stroke-linecap="round" fill="none" />`;
                return `<svg class="w-full h-full" viewBox="0 0 100 100" style="transform: rotate(${rotation}deg);">${path}</svg>`;
            }

            function getPipeExits(pipe) {
                if (!pipe) return [];
                const { type, rotation } = pipe;
                const r = (parseInt(rotation, 10) + 360) % 360;
                if (type === 'straight') return (r === 90 || r === 270) ? ['up', 'down'] : ['left', 'right'];
                if (type === 'corner') { if (r === 0) return ['left', 'down']; if (r === 90) return ['down', 'right']; if (r === 180) return ['right', 'up']; if (r === 270) return ['up', 'left']; }
                return [];
            }
            
            function checkPipeConnection(placedPipes, question) {
                if (!Array.isArray(placedPipes)) return false;
                const { gridSize, start, end, obstacles } = question;
                const grid = Array(gridSize.rows).fill(null).map(() => Array(gridSize.cols).fill(null));
                placedPipes.forEach(p => { grid[p.row][p.col] = p; });
                let queue = [];
                let visited = new Set();
                const directions = { up: { r: -1, c: 0, opp: 'down' }, down: { r: 1, c: 0, opp: 'up' }, left: { r: 0, c: -1, opp: 'right' }, right: { r: 0, c: 1, opp: 'left' } };
                for (const dirName in directions) {
                    const { r, c, opp } = directions[dirName];
                    const nextR = start.row + r;
                    const nextC = start.col + c;
                    const key = `${nextR},${nextC}`;
                    if (nextR >= 0 && nextR < gridSize.rows && nextC >= 0 && nextC < gridSize.cols) {
                        const nextPipe = grid[nextR]?.[nextC];
                        if (nextPipe && getPipeExits(nextPipe).includes(opp)) { visited.add(key); queue.push({ row: nextR, col: nextC, path: [`${start.row},${start.col}`, key] }); }
                    }
                }
                while (queue.length > 0) {
                    const current = queue.shift();
                    const currentPipe = grid[current.row][current.col];
                    const currentExits = getPipeExits(currentPipe);
                    for (const dirName in directions) {
                        const { r, c } = directions[dirName];
                        if (currentExits.includes(dirName)) {
                            const neighborR = current.row + r;
                            const neighborC = current.col + c;
                            if (neighborR === end.row && neighborC === end.col) {
                                const finalPath = [...current.path, `${end.row},${end.col}`];
                                const pathSet = new Set(finalPath);
                                const allObstaclesOnPath = obstacles?.every(o => pathSet.has(`${o.row},${o.col}`)) ?? true;
                                if (allObstaclesOnPath) return true;
                            }
                        }
                    }
                    for (const dirName in directions) {
                        const { r, c, opp } = directions[dirName];
                        if (currentExits.includes(dirName)) {
                            const nextR = current.row + r;
                            const nextC = current.col + c;
                            const key = `${nextR},${nextC}`;
                            if (nextR >= 0 && nextR < gridSize.rows && nextC >= 0 && nextC < gridSize.cols && !visited.has(key)) {
                                const nextPipe = grid[nextR]?.[nextC];
                                if (nextPipe && getPipeExits(nextPipe).includes(opp)) { visited.add(key); queue.push({ row: nextR, col: nextC, path: [...current.path, key] }); }
                            }
                        }
                    }
                }
                return false;
            }

            function switchScreen(screenName) { Object.values(dom.screens).forEach(s => s.classList.remove('active')); dom.screens[screenName].classList.add('active'); }
            function updateScore(newScore) { gameState.score = newScore; dom.displays.score.textContent = newScore; }
            function startTimer(duration) {
                gameState.timeLeft = duration;
                dom.displays.timerContainer.classList.remove('warning');
                function update() {
                    if(gameState.mode === 'pro') {
                        dom.displays.timer.textContent = formatTime(gameState.timeLeft);
                        if (gameState.timeLeft <= 10 && gameState.timeLeft > 0) {
                            dom.displays.timerContainer.classList.add('warning');
                            playSound(sounds.timer_tick, 'C6', '16n');
                        }
                    }
                    if (gameState.timeLeft <= 0) { 
                        clearInterval(gameState.timerInterval); 
                        handleAnswer(null, 'timeout'); 
                    }
                    gameState.timeLeft--;
                }
                update();
                gameState.timerInterval = setInterval(update, 1000);
            }
            function startTotalTimer() { gameState.totalTime = 0; if(gameState.totalTimeInterval) clearInterval(gameState.totalTimeInterval); gameState.totalTimeInterval = setInterval(() => { gameState.totalTime++; }, 1000); }
            function formatTime(seconds) { const mins = Math.floor(seconds / 60); const secs = seconds % 60; return `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`; }
            function shuffleArray(array) { for (let i = array.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [array[i], array[j]] = [array[j], array[i]]; } return array; }
            function launchConfetti() {
                playSound(sounds.confetti, "C4", "8n", Tone.now());
                playSound(sounds.confetti, "G4", "8n", Tone.now() + 0.1);
                playSound(sounds.confetti, "E5", "8n", Tone.now() + 0.2);
                for (let i = 0; i < 100; i++) { const c = document.createElement('div'); c.className = 'confetti'; c.style.left = `${Math.random()*100}vw`; c.style.animationDelay = `${Math.random()*2}s`; c.style.backgroundColor=`hsl(${Math.random()*360},100%,50%)`; c.style.transform=`scale(${Math.random()*.5+.5})`; document.body.appendChild(c); setTimeout(()=>c.remove(),3000);}
            }

            // --- EVENT LISTENERS ---
            dom.buttons.startDiscovery.addEventListener('click', () => { startGame('discovery'); playSound(sounds.click, "C2", "8n"); });
            dom.buttons.startPro.addEventListener('click', () => { startGame('pro'); playSound(sounds.click, "C2", "8n"); });
            dom.buttons.next.addEventListener('click', () => { nextQuestion(); playSound(sounds.click, "C2", "8n"); });
            dom.buttons.restartFinal.addEventListener('click', () => { startGame(gameState.mode); playSound(sounds.click, "C2", "8n"); });
            dom.buttons.homeFinal.addEventListener('click', () => { initGame(); playSound(sounds.click, "C2", "8n"); });
            dom.buttons.changeMode.addEventListener('click', () => { initGame(); playSound(sounds.click, "C2", "8n"); });

            // --- INITIALISATION ---
            initGame();
        });
    </script>
</body>
</html>
