<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Simulateur pour d√©couvrir le m√©tier de projeteur VRD.">
    <title>LTD Simulator - Projeteur VRD</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500&family=Poppins:wght@700;800&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <style>
        /* --- TH√àME GLOBAL (issu du site principal) --- */
        :root {
            /* Colors */
            --primary: #6366f1;
            --primary-dark: #4f46e5;
            --primary-light: #a5b4fc;
            --secondary: #10b981;
            --secondary-dark: #059669;
            --accent: #f59e0b;
            --accent-dark: #d97706;
            --correct: #22c55e;
            --incorrect: #ef4444;
            
            /* Surfaces */
            --background: #0f172a;
            --surface: #1e293b;
            --surface-elevated: #334155;
            --surface-hover: #475569;
            --glass: rgba(255, 255, 255, 0.05);
            --glass-border: rgba(255, 255, 255, 0.15);
            
            /* Text */
            --text-primary: #f8fafc;
            --text-secondary: #cbd5e1;
            --text-muted: #94a3b8;
            
            /* Shadows */
            --shadow-glow: 0 0 15px 0px rgba(99, 102, 241, 0.3);
            --shadow-lg: 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);
            --shadow-xl: 0 25px 50px -12px rgb(0 0 0 / 0.25);

            /* Animation */
            --transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            --transition-slow: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            
            /* Spacing */
            --spacing-xs: 0.5rem;
            --spacing-sm: 1rem;
            --spacing-md: 1.5rem;
            --spacing-lg: 2rem;
            --spacing-xl: 3rem;
            
            /* Borders */
            --radius-sm: 0.375rem;
            --radius: 0.5rem;
            --radius-md: 0.75rem;
            --radius-lg: 1rem;
            --radius-xl: 1.5rem;
            --radius-full: 9999px;
        }

        body.light-mode {
            --background: #f1f5f9;
            --surface: #ffffff;
            --surface-elevated: #e2e8f0;
            --surface-hover: #cbd5e1;
            --glass: rgba(0, 0, 0, 0.05);
            --glass-border: rgba(0, 0, 0, 0.1);
            --text-primary: #1e293b;
            --text-secondary: #475569;
            --text-muted: #64748b;
            --shadow-glow: 0 0 15px 0px rgba(99, 102, 241, 0.2);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }
        html { scroll-behavior: smooth; }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--background);
            color: var(--text-primary);
            line-height: 1.6;
            overflow-x: hidden;
            transition: var(--transition-slow);
        }

        body::before {
            content: ''; position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: radial-gradient(circle at 15% 50%, rgba(99, 102, 241, 0.15) 0%, transparent 40%), radial-gradient(circle at 85% 30%, rgba(16, 185, 129, 0.15) 0%, transparent 40%), radial-gradient(circle at 50% 85%, rgba(245, 158, 11, 0.1) 0%, transparent 40%);
            pointer-events: none; z-index: -1; animation: background-pan 30s linear infinite;
        }
        
        @keyframes background-pan { 0% { background-position: 0% 50%; } 50% { background-position: 100% 50%; } 100% { background-position: 0% 50%; } }
        
        [onclick], .nav-link, .mobile-nav-item, .theme-toggle, .mobile-toggle { cursor: pointer; }

        .header { position: fixed; top: 0; left: 0; right: 0; z-index: 1000; backdrop-filter: blur(20px) saturate(180%); background: rgba(15, 23, 42, 0.8); border-bottom: 1px solid var(--glass-border); transition: var(--transition); }
        body.light-mode .header { background: rgba(255, 255, 255, 0.8); }
        .nav-container { max-width: 1400px; margin: 0 auto; padding: 0 var(--spacing-sm); display: flex; align-items: center; justify-content: space-between; height: 4.5rem; gap: var(--spacing-md); }
        .logo { display: flex; align-items: center; gap: var(--spacing-sm); text-decoration: none; color: var(--text-primary); font-weight: 800; font-size: 1.2rem; transition: var(--transition); }
        .logo:hover { transform: scale(1.05); text-shadow: 0 0 10px var(--primary-light); }
        .logo-icon { height: 1.8rem; width: auto; vertical-align: -0.4rem; }
        .logo-text-extended { display: none; }
        .nav-desktop { display: none; }
        .nav-menu { display: flex; align-items: center; gap: var(--spacing-xs); list-style: none; }
        .nav-item { position: relative; }
        .nav-link { display: flex; align-items: center; gap: var(--spacing-xs); padding: var(--spacing-xs) var(--spacing-sm); color: var(--text-secondary); text-decoration: none; font-weight: 500; border-radius: var(--radius); transition: var(--transition); }
        .nav-link:hover { color: var(--text-primary); background: var(--glass); }
        .nav-link.active { color: var(--text-primary); background: linear-gradient(45deg, rgba(99, 102, 241, 0.1), rgba(99, 102, 241, 0.2)); font-weight: 600; }
        .header-search { position: relative; }
        .header-search input { width: 100%; background-color: var(--surface); border: 1px solid var(--glass-border); color: var(--text-secondary); border-radius: var(--radius); padding: 0.5rem 1rem 0.5rem 2.5rem; font-size: 0.9rem; transition: var(--transition); }
        .header-search input::placeholder { color: var(--text-muted); }
        .header-search input:focus { background-color: var(--surface-elevated); border-color: var(--primary); color: var(--text-primary); box-shadow: 0 0 0 2px var(--primary-dark); outline: none; }
        .header-search .fa-search { position: absolute; left: 1rem; top: 50%; transform: translateY(-50%); color: var(--text-muted); }
        .nav-actions { display: flex; align-items: center; gap: var(--spacing-sm); }
        .theme-toggle { display: flex; align-items: center; justify-content: center; width: 2.5rem; height: 2.5rem; background: var(--glass); border: 1px solid var(--glass-border); border-radius: var(--radius); color: var(--text-secondary); transition: var(--transition); }
        .theme-toggle:hover { background: var(--surface-elevated); color: var(--text-primary); transform: rotate(15deg); }
        .mobile-toggle { display: flex; flex-direction: column; justify-content: center; align-items: center; width: 2.5rem; height: 2.5rem; background: var(--glass); border: 1px solid var(--glass-border); border-radius: var(--radius); transition: var(--transition); }
        .hamburger { position: relative; width: 1.25rem; height: 1rem; }
        .hamburger span { position: absolute; left: 0; width: 100%; height: 2px; background: var(--text-primary); border-radius: 1px; transition: var(--transition); }
        .hamburger span:nth-child(1) { top: 0; }
        .hamburger span:nth-child(2) { top: 50%; transform: translateY(-50%); }
        .hamburger span:nth-child(3) { bottom: 0; }
        .mobile-toggle.active .hamburger span:nth-child(1) { top: 50%; transform: translateY(-50%) rotate(45deg); }
        .mobile-toggle.active .hamburger span:nth-child(2) { opacity: 0; }
        .mobile-toggle.active .hamburger span:nth-child(3) { bottom: 50%; transform: translateY(50%) rotate(-45deg); }
        .mobile-menu { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: var(--background); z-index: 999; display: flex; flex-direction: column; opacity: 0; visibility: hidden; transition: var(--transition-slow); }
        .mobile-menu.active { opacity: 1; visibility: visible; }
        .mobile-menu-header { display: flex; align-items: center; justify-content: space-between; padding: 0 var(--spacing-sm); height: 4.5rem; border-bottom: 1px solid var(--glass-border); }
        .mobile-menu-close { width: 2.5rem; height: 2.5rem; display: flex; align-items: center; justify-content: center; background: var(--glass); border: 1px solid var(--glass-border); border-radius: var(--radius); color: var(--text-primary); }
        .mobile-menu-content { flex: 1; padding: var(--spacing-lg) var(--spacing-sm); overflow-y: auto; }
        .mobile-search-wrapper { padding-bottom: var(--spacing-lg); margin-bottom: var(--spacing-lg); border-bottom: 1px solid var(--glass-border); }
        .mobile-search-wrapper .header-search { width: 100%; }
        .mobile-nav-section h3 { color: var(--text-muted); font-size: 0.75rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.1em; margin-bottom: var(--spacing-md); }
        .mobile-nav-items { display: flex; flex-direction: column; gap: var(--spacing-xs); }
        .mobile-nav-item { display: flex; align-items: center; gap: var(--spacing-sm); padding: var(--spacing-md); color: var(--text-secondary); text-decoration: none; border-radius: var(--radius-md); }
        .mobile-nav-item-icon { font-size: 1.25rem; width: 2.5rem; height: 2.5rem; display: flex; align-items: center; justify-content: center; background: var(--glass); border-radius: var(--radius); }
        .mobile-nav-item:hover { background: var(--glass); color: var(--text-primary); }
        .main-content { margin-top: 4.5rem; padding: var(--spacing-lg) var(--spacing-sm); max-width: 1400px; margin-left: auto; margin-right: auto; }
        @media (min-width: 768px) { .nav-container { padding: 0 var(--spacing-md); } .main-content { padding: var(--spacing-xl) var(--spacing-md); } }
        @media (min-width: 1024px) { .mobile-toggle { display: none; } .nav-desktop { display: flex; align-items: center; flex-grow: 1; justify-content: flex-end; gap: var(--spacing-sm); } .header-search { width: 280px; } .nav-menu { gap: var(--spacing-xs); } }
        @media (min-width: 1280px) { .logo-text-extended { display: inline; } }

        /* --- STYLES SP√âCIFIQUES AU JEU VRD (adapt√©s au th√®me) --- */
        .game-card {
            background: var(--surface); border: 1px solid var(--glass-border); border-radius: var(--radius-lg);
            padding: var(--spacing-lg); width: 100%; box-shadow: var(--shadow-xl);
            backdrop-filter: blur(10px); text-align: center; animation: fadeIn 0.5s ease-out;
            max-width: 1000px; margin: 0 auto;
        }
        @keyframes fadeIn { from { opacity: 0; transform: scale(0.98); } to { opacity: 1; transform: scale(1); } }
        
        .screen { display: none; flex: 1; }
        .screen.active { display: flex; flex-direction: column; align-items: center; justify-content: center; }

        .game-card h1 {
            font-family: 'Poppins', sans-serif; font-size: clamp(2rem, 5vw, 3rem);
            font-weight: 800; color: var(--primary-light); margin-bottom: var(--spacing-sm);
        }
        .game-card h2 {
            font-family: 'Poppins', sans-serif; font-size: clamp(1.2rem, 4vw, 1.8rem);
            font-weight: 700; color: var(--text-primary); margin-bottom: var(--spacing-md);
            line-height: 1.4; max-width: 800px;
        }
        .game-card p { font-size: 1.1rem; color: var(--text-secondary); margin-bottom: var(--spacing-md); max-width: 600px; }
        
        .btn {
            display: inline-flex; align-items: center; justify-content: center; gap: 0.5rem;
            background: var(--primary); color: white; border: none; padding: 0.8rem 1.8rem;
            border-radius: var(--radius-full); font-size: 1rem; font-weight: 600;
            cursor: pointer; transition: var(--transition); box-shadow: 0 4px 10px rgba(99, 102, 241, 0.2);
        }
        .btn:hover { background: var(--primary-dark); transform: translateY(-2px); box-shadow: var(--shadow-glow); }
        .btn:active { transform: translateY(0); }
        .btn:disabled { opacity: 0.7; cursor: not-allowed; background: var(--surface-hover); box-shadow: none; }

        .game-header-stats { display: flex; gap: var(--spacing-md); align-items: center; justify-content: center; margin-bottom: var(--spacing-md); }
        .game-header-item { display: flex; align-items: center; gap: var(--spacing-xs); font-size: 1.25rem; font-weight: 700; font-family: 'JetBrains Mono', monospace; background: var(--surface-elevated); padding: 0.5rem 1.25rem; border-radius: var(--radius-full); }
        .timer-display.warning { animation: pulse 1s infinite; color: var(--incorrect); }
        @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.05); } }
        
        .answer-grid { display: grid; grid-template-columns: 1fr; gap: var(--spacing-sm); width: 100%; max-width: 1000px; margin-top: var(--spacing-md); }
        @media (min-width: 640px) { .answer-grid { grid-template-columns: 1fr 1fr; } }

        .answer-btn {
            width: 100%; background: var(--surface-elevated); color: var(--text-secondary);
            padding: 1rem; border: 1px solid var(--glass-border); border-radius: var(--radius-md);
            text-align: center; font-size: 1rem; cursor: pointer; transition: var(--transition);
        }
        .answer-btn:not(:disabled):hover { background: var(--surface-hover); border-color: var(--primary); color: var(--text-primary); }
        .answer-btn.correct { background: var(--correct) !important; color: var(--text-primary) !important; border-color: var(--correct) !important; animation: bounce 0.5s ease; }
        .answer-btn.incorrect { background: var(--incorrect) !important; color: var(--text-primary) !important; border-color: var(--incorrect) !important; animation: shake 0.5s ease; }
        .answer-btn:disabled { cursor: not-allowed; }

        @keyframes bounce { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-6px); } }
        @keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-5px); } 75% { transform: translateX(5px); } }

        .feedback-text { margin-top: var(--spacing-md); font-size: 1.2rem; font-weight: bold; }
        .feedback-solution { font-size: 1rem; font-weight: normal; color: var(--text-secondary); margin-top: var(--spacing-xs); }

        .material-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 1rem; width: 100%; max-width: 1000px; margin-top: 2rem; }
        .material-card { background: var(--surface-elevated); border: 2px solid var(--glass-border); color: var(--text-secondary); border-radius: 1rem; padding: 1.5rem; text-align: center; cursor: pointer; transition: all 0.3s ease; display: flex; flex-direction: column; align-items: center; gap: 1rem; }
        .material-icon { font-size: 3rem; line-height: 1; }
        .material-card:not(.disabled):hover { transform: translateY(-4px); border-color: var(--primary); color: var(--text-primary); }
        .material-card.selected { border-color: var(--secondary); box-shadow: 0 0 0 2px var(--secondary); }
        .material-card.correct { background: var(--correct) !important; color: white !important; border-color: var(--correct) !important; }
        .material-card.incorrect { background: var(--incorrect) !important; color: white !important; border-color: var(--incorrect) !important; }
        .material-card.disabled { cursor: not-allowed; opacity: 0.7; }

        .elevation-input, .text-input { font-size: 1.5rem; padding: 1rem 2rem; border: 1px solid var(--glass-border); border-radius: var(--radius-md); text-align: center; width: 100%; max-width: 400px; transition: all 0.3s ease; margin: 1rem 0; background-color: var(--surface-elevated); color: var(--text-primary); }
        .elevation-input:focus, .text-input:focus { outline: none; border-color: var(--primary); box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.3); }
        
        .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1.5rem; width: 100%; max-width: 800px; margin: 2rem 0; }
        .stat-card { background: var(--surface-elevated); padding: 1.5rem; border-radius: 1rem; text-align: center; border: 1px solid var(--glass-border); }
        .stat-label { font-weight: 500; color: var(--text-secondary); margin-bottom: 0.5rem; }
        .stat-number { font-weight: 800; font-size: 2.5rem; color: var(--primary); }

        .pipe-game-container { display: flex; flex-direction: column; align-items: center; gap: 1rem; width: 100%; }
        .pipe-tray { display: flex; gap: 1rem; background: var(--surface-elevated); padding: 1rem; border-radius: 1rem; flex-wrap: wrap; justify-content: center; }
        .pipe-piece-draggable { width: 50px; height: 50px; cursor: grab; position: relative; }
        .pipe-piece-draggable.dragging { opacity: 0.5; }
        .pipe-count { position: absolute; bottom: -5px; right: -5px; background: var(--primary); color: white; border-radius: 50%; width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 0.8rem; }
        .pipe-grid-container { display: grid; grid-template-columns: repeat(var(--grid-cols, 5), 1fr); border: 2px solid var(--glass-border); border-radius: 1rem; overflow: hidden; background: var(--background); width: 100%; max-width: 90vw; }
        .grid-cell { border: 1px solid var(--glass-border); display: flex; align-items: center; justify-content: center; position: relative; background-color: var(--surface); aspect-ratio: 1 / 1; }
        .grid-cell.start-node { background-color: var(--correct); color: white; font-weight: bold; font-size: 1.5rem; }
        .grid-cell.end-node { background-color: var(--incorrect); color: white; font-weight: bold; font-size: 1.5rem; }
        .pipe-piece-placed { width: 100%; height: 100%; transition: transform 0.2s ease; cursor: pointer; }
        .grid-cell.obstacle-node { background-color: var(--surface-hover); }

        .draggable { padding: 0.75rem; background: var(--surface-elevated); border: 1px solid var(--glass-border); border-radius: 0.5rem; cursor: grab; transition: all 0.2s ease; user-select: none; }
        .draggable:active { cursor: grabbing; background: var(--surface-hover); }
        .drop-zone { border: 2px dashed var(--glass-border); border-radius: 0.75rem; background: var(--surface); transition: all 0.2s ease; min-height: 100px; padding: 1rem; display: flex; flex-wrap: gap: 0.5rem; justify-content: center; align-items: center; }
        .drop-zone.hover { border-color: var(--primary); background: var(--surface-hover); }
        .drop-zone.filled { border-style: solid; }

        .confetti { position: fixed; width: 10px; height: 10px; top: -20px; animation: fall 3s linear forwards; }
        @keyframes fall { to { transform: translateY(100vh) rotate(360deg); } }
    </style>
</head>
<body>

    <!-- Header -->
    <header class="header" id="header">
        <nav class="nav-container">
            <a href="index.html" class="logo" onclick="event.preventDefault(); navigateTo('index.html');">
                <svg class="logo-icon" viewBox="20 10 60 75" xmlns="http://www.w3.org/2000/svg" fill="none">
                    <path d="M20 85V40C20 34.4772 24.4772 30 30 30H40C45.5228 30 50 34.4772 50 40V85H20Z" fill="var(--primary-light)" fill-opacity="0.7"></path>
                    <path d="M50 85V20C50 14.4772 54.4772 10 60 10H70C75.5228 10 80 14.4772 80 20V85H50Z" fill="var(--primary)"></path>
                </svg>
                <span class="logo-text">LTD<span class="logo-text-extended">&nbsp;Simulator</span></span>
            </a>
            <div class="nav-desktop">
                 <form action="recherche.html" method="GET" class="header-search">
                     <i class="fas fa-search"></i>
                     <input type="search" name="query" placeholder="Rechercher..." aria-label="Rechercher">
                 </form>
                 <ul class="nav-menu">
                     <li class="nav-item"><a href="index.html" class="nav-link" onclick="event.preventDefault(); navigateTo('index.html')"><i class="fas fa-home"></i>&nbsp;Accueil</a></li>
                     <li class="nav-item"><a href="simulateur.html" class="nav-link active" onclick="event.preventDefault(); navigateTo('simulateur.html')"><i class="fas fa-gamepad"></i>&nbsp;Simulateurs</a></li>
                     <li class="nav-item"><a href="test.html" class="nav-link" onclick="event.preventDefault(); navigateTo('test.html')"><i class="fas fa-brain"></i>&nbsp;Tests</a></li>
                     <li class="nav-item"><a href="challenges.html" class="nav-link" onclick="event.preventDefault(); navigateTo('challenges.html')"><i class="fas fa-trophy"></i>&nbsp;Challenges</a></li>
                     <li class="nav-item"><a href="emploi.html" class="nav-link" onclick="event.preventDefault(); navigateTo('emploi.html')"><i class="fas fa-briefcase"></i>&nbsp;Nos offres d'emploi</a></li>
                     <li class="nav-item"><a href="histoire.html" class="nav-link" onclick="event.preventDefault(); navigateTo('histoire.html')"><i class="fas fa-scroll"></i>&nbsp;Histoire du BTP</a></li>
                     <li class="nav-item"><a href="#" class="nav-link" onclick="event.preventDefault(); navigateTo('quiz.html')"><i class="fas fa-question-circle"></i>&nbsp;Quiz</a></li>
                 </ul>
                 <div class="nav-actions">
                     <button class="theme-toggle" id="themeToggle" onclick="toggleTheme()" title="Changer de th√®me">
                         <i class="fas fa-moon" id="themeIcon"></i>
                     </button>
                 </div>
            </div>
            <button class="mobile-toggle" id="mobileToggle" onclick="toggleMobileMenu()">
                <span class="hamburger"><span></span><span></span><span></span></span>
            </button>
        </nav>
    </header>

    <!-- Mobile Menu -->
    <div class="mobile-menu" id="mobileMenu">
        <div class="mobile-menu-header">
            <a href="index.html" class="logo" onclick="event.preventDefault(); toggleMobileMenu(); navigateTo('index.html');">
                <svg class="logo-icon" viewBox="20 10 60 75" xmlns="http://www.w3.org/2000/svg" fill="none">
                    <path d="M20 85V40C20 34.4772 24.4772 30 30 30H40C45.5228 30 50 34.4772 50 40V85H20Z" fill="var(--primary-light)" fill-opacity="0.7"></path>
                    <path d="M50 85V20C50 14.4772 54.4772 10 60 10H70C75.5228 10 80 14.4772 80 20V85H50Z" fill="var(--primary)"></path>
                </svg>
                <span class="logo-text">LTD<span class="logo-text-extended">&nbsp;Simulator</span></span>
            </a>
            <button class="mobile-menu-close" onclick="toggleMobileMenu()"><i class="fas fa-times"></i></button>
        </div>
        <div class="mobile-menu-content">
            <div class="mobile-search-wrapper">
                <form action="recherche.html" method="GET" class="header-search">
                    <i class="fas fa-search"></i>
                    <input type="search" name="query" placeholder="Rechercher..." aria-label="Rechercher">
                </form>
            </div>
            <div class="mobile-nav-section">
                <h3>Navigation</h3>
                <div class="mobile-nav-items">
                    <!-- Mobile nav items will be populated by JS -->
                </div>
            </div>
        </div>
    </div>

    <!-- Main Content -->
    <main class="main-content">
        <div id="game-container">
            <!-- √âcran d'accueil -->
            <div id="homeScreen" class="screen active game-card">
                <h1>Simulateur Projeteur VRD</h1>
                <p>Testez vos connaissances et devenez un expert en Voirie et R√©seaux Divers. Pr√™t √† relever le d√©fi ?</p>
                <button id="startBtn" class="btn">D√©marrer la simulation</button>
            </div>

            <!-- √âcran de question -->
            <div id="questionScreen" class="screen game-card">
                <div class="game-header-stats">
                    <div id="scoreDisplay" class="game-header-item">
                        <span>‚≠ê</span>
                        <span id="score">0</span>
                    </div>
                    <div id="timerDisplay" class="game-header-item timer-display">
                        <span>‚è∞</span>
                        <span id="timer">--:--</span>
                    </div>
                </div>
                <h2 id="questionText"></h2>
                <div id="answerContainer"></div>
                <div id="feedbackText" class="feedback-text"></div>
                <div style="text-align: center; margin-top: 1.5rem;">
                    <button id="nextBtn" class="btn" style="display: none;">Question Suivante</button>
                </div>
            </div>

            <!-- √âcran final -->
            <div id="finalScreen" class="screen game-card">
                <h1>Simulation Termin√©e !</h1>
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-label">Score Final</div>
                        <div id="finalScore" class="stat-number">0</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Bonnes R√©ponses</div>
                        <div id="correctAnswers" class="stat-number">0 / 0</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Temps Total</div>
                        <div id="totalTime" class="stat-number">00:00</div>
                    </div>
                </div>
                <p id="finalMessage" style="font-size: 1.5rem; margin-top: 1rem; margin-bottom: 2rem;"></p>
                <button id="restartBtnFinal" class="btn">Recommencer</button>
            </div>
        </div>
    </main>

    <script>
        // --- HEADER & NAVIGATION SCRIPT ---
        let currentTheme = localStorage.getItem('theme') || 'dark';
        function navigateTo(pageFile) { window.location.href = pageFile; }
        function updateThemeUI() {
            const themeIcon = document.getElementById('themeIcon');
            if (!themeIcon) return;
            document.body.classList.toggle('light-mode', currentTheme === 'light');
            themeIcon.className = currentTheme === 'light' ? 'fas fa-moon' : 'fas fa-sun';
        }
        function toggleTheme() {
            currentTheme = currentTheme === 'light' ? 'dark' : 'light';
            localStorage.setItem('theme', currentTheme);
            updateThemeUI();
        }
        function toggleMobileMenu() {
            const mobileToggle = document.getElementById('mobileToggle');
            const mobileMenu = document.getElementById('mobileMenu');
            mobileToggle.classList.toggle('active');
            mobileMenu.classList.toggle('active');
            document.body.style.overflow = mobileMenu.classList.contains('active') ? 'hidden' : '';
        }

        // --- VRD SIMULATOR SCRIPT ---
        document.addEventListener('DOMContentLoaded', () => {
            // --- Initialisation du Header ---
            updateThemeUI();
            const desktopNav = document.querySelector('.nav-desktop .nav-menu');
            const mobileNavContainer = document.querySelector('.mobile-menu .mobile-nav-items');
            if(desktopNav && mobileNavContainer) {
                mobileNavContainer.innerHTML = '';
                desktopNav.querySelectorAll('.nav-item').forEach(item => {
                    const link = item.querySelector('a');
                    const newNavItem = document.createElement('a');
                    newNavItem.href = link.href;
                    newNavItem.className = 'mobile-nav-item';
                    newNavItem.onclick = (e) => {
                        e.preventDefault();
                        toggleMobileMenu();
                        if (link.href && !link.href.endsWith('#')) {
                           navigateTo(link.getAttribute('href'));
                        }
                    };
                    const iconDiv = document.createElement('div');
                    iconDiv.className = 'mobile-nav-item-icon';
                    iconDiv.innerHTML = link.querySelector('i').outerHTML;
                    const textNode = document.createElement('h4');
                    textNode.textContent = link.textContent.trim();
                    newNavItem.appendChild(iconDiv);
                    newNavItem.appendChild(textNode);
                    mobileNavContainer.appendChild(newNavItem);
                });
            }

            // --- S√âLECTION DES √âL√âMENTS DU DOM ---
            const dom = {
                screens: { home: document.getElementById('homeScreen'), question: document.getElementById('questionScreen'), final: document.getElementById('finalScreen'), },
                buttons: { start: document.getElementById('startBtn'), next: document.getElementById('nextBtn'), restartFinal: document.getElementById('restartBtnFinal'), },
                displays: { score: document.getElementById('score'), timer: document.getElementById('timer'), timerContainer: document.getElementById('timerDisplay'), questionText: document.getElementById('questionText'), answerContainer: document.getElementById('answerContainer'), feedback: document.getElementById('feedbackText'), finalScore: document.getElementById('finalScore'), correctAnswers: document.getElementById('correctAnswers'), totalTime: document.getElementById('totalTime'), finalMessage: document.getElementById('finalMessage'), },
            };

            // --- DONN√âES DU JEU ---
            const questions = [ { type: 'qcm', text: "Quel est le r√¥le principal d'un Projeteur VRD ?", answers: [{ text: "Concevoir les b√¢timents", correct: false }, { text: "Am√©nager les espaces ext√©rieurs et r√©seaux", correct: true }, { text: "G√©rer la comptabilit√© du chantier", correct: false }, { text: "Peindre les murs", correct: false }], solution: "Le Projeteur VRD (Voirie et R√©seaux Divers) con√ßoit les routes, les syst√®mes d'assainissement, les r√©seaux d'eau, de gaz, d'√©lectricit√© et de t√©l√©communications.", points: 100, time: 30, }, { type: 'multiple-choice', text: "Identifiez les mat√©riaux adapt√©s pour une couche de fondation de chauss√©e. (Plusieurs r√©ponses possibles)", answers: [{ text: "Terre v√©g√©tale", correct: false, icon: "üå±" }, { text: "Grave non trait√©e (GNT)", correct: true, icon: "ü™®" }, { text: "Sable", correct: false, icon: "üèñÔ∏è" }, { text: "Grave-ciment", correct: true, icon: "üß±" }], solution: "La couche de fondation assure la portance de la chauss√©e. Les graves non trait√©es (GNT) et les graves trait√©es (comme le grave-ciment) sont des mat√©riaux couramment utilis√©s.", points: 150, time: 45, }, { type: 'calculation', text: "Un regard A est √† une altitude de 125.50m. Un regard B, distant de 50m, est √† 124.75m. Quelle est la pente du r√©seau en % ?", solution: "Calcul : ((125.50 - 124.75) / 50) * 100 = 1.5%.", correctAnswer: 1.5, tolerance: 0.01, points: 200, time: 60, }, { type: 'pipe-connect', text: "Connectez le r√©seau d'eaux us√©es du point A au point B.", gridSize: { rows: 5, cols: 7 }, start: { row: 2, col: 0 }, end: { row: 2, col: 6 }, pieces: { straight: 5, corner: 4 }, solution: "Il faut cr√©er un chemin continu de A √† B en utilisant les pi√®ces disponibles.", points: 350, time: 180, pipeColor: '#8B5CF6' }, { type: 'chronological-order', text: "Mettez dans l'ordre les √©tapes de la construction d'une voirie simple.", items: ["Terrassement", "Mise en place de la couche de fondation", "Pose des bordures et caniveaux", "Application du rev√™tement (enrob√©)", "Signalisation et finitions"], solution: "L'ordre logique est : Terrassement > Couche de fondation > Bordures/Caniveaux > Rev√™tement > Signalisation.", points: 250, time: 90, }, { type: 'scenario', text: "Sc√©nario : Erreur de conception", scenario: "Vous recevez un plan o√π un r√©seau d'eaux pluviales (EP) est connect√© directement en amont d'une station d'√©puration con√ßue uniquement pour les eaux us√©es (EU). Quelle est l'erreur majeure et que proposez-vous ?", answers: [{ text: "Aucune erreur, c'est une pratique standard.", correct: false }, { text: "L'erreur est le m√©lange des r√©seaux. Il faut cr√©er un exutoire s√©par√© pour les EP.", correct: true }, { text: "Il faut juste une plus grosse canalisation.", correct: false }, { text: "Il faut inverser le sens de la pente.", correct: false }], solution: "Les r√©seaux d'eaux pluviales et d'eaux us√©es doivent √™tre s√©paratifs. Les EP n'ont pas besoin d'√™tre trait√©es en station d'√©puration et risqueraient de la saturer.", points: 300, time: 75, }, { type: 'qcm', text: "De quelle couleur est le grillage avertisseur pour un r√©seau √©lectrique enterr√© ?", answers: [{ text: "Bleu", correct: false }, { text: "Jaune", correct: false }, { text: "Rouge", correct: true }, { text: "Vert", correct: false }], solution: "Le grillage avertisseur rouge signale la pr√©sence d'un c√¢ble ou d'une canalisation √©lectrique.", points: 100, time: 25 }, { type: 'text-input', text: "Quel logiciel de CAO/DAO est le plus utilis√© par les projeteurs VRD ?", correctAnswer: "AutoCAD", solution: "AutoCAD est le standard de l'industrie pour le dessin technique en 2D et 3D.", points: 120, time: 30 }, { type: 'calculation', text: "Une route de 6m de large a une pente en travers de 2.5% depuis l'axe. Quelle est la diff√©rence de niveau (en cm) entre l'axe et le bord ?", correctAnswer: 7.5, tolerance: 0.1, solution: "Calcul : (6m / 2) * 0.025 = 0.075m, soit 7.5 cm.", points: 200, time: 60 }, { type: 'multiple-choice', text: "Quels √©l√©ments font partie des 'r√©seaux secs' ?", answers: [{ text: "Adduction d'Eau Potable", correct: false, icon: "üíß" }, { text: "√âlectricit√© (Basse Tension)", correct: true, icon: "‚ö°" }, { text: "T√©l√©communications (Fibre)", correct: true, icon: "üì°" }, { text: "Assainissement EU", correct: false, icon: "üöΩ" }], solution: "Les r√©seaux secs transportent de l'√©nergie ou de l'information (√©lectricit√©, t√©l√©com), par opposition aux r√©seaux humides (eau, assainissement).", points: 150, time: 40 }, { type: 'chronological-order', text: "Ordonnez les couches d'une structure de chauss√©e, de la plus profonde √† la surface.", items: ["Couche de forme", "Couche de fondation", "Couche de base", "Couche de roulement"], solution: "La structure est b√¢tie depuis le terrain naturel (couche de forme) jusqu'√† la surface (couche de roulement).", points: 250, time: 70 }, { type: 'qcm', text: "Que signifie 'DT-DICT' ?", answers: [{ text: "Document Technique - Dessin Industriel et Commercial", correct: false }, { text: "D√©claration de Travaux - Demande d'Intervention sur la Chauss√©e", correct: false }, { text: "D√©claration de projet de Travaux - D√©claration d'Intention de Commencement de Travaux", correct: true }, { text: "Dossier Technique - Directive Interne de Chantier", correct: false }], solution: "La DT-DICT est une proc√©dure obligatoire pour s'informer sur la pr√©sence de r√©seaux enterr√©s avant de commencer des travaux.", points: 180, time: 45 }, { type: 'calculation', text: "Un bassin de r√©tention a une surface de 200m¬≤. Il pleut 30 litres/m¬≤. Quel volume d'eau (en m¬≥) le bassin doit-il stocker ?", correctAnswer: 6, tolerance: 0.1, solution: "Calcul : 200 m¬≤ * 30 L/m¬≤ = 6000 Litres. Comme 1000L = 1m¬≥, le volume est de 6 m¬≥.", points: 220, time: 75 }, { type: 'text-input', text: "Comment nomme-t-on le plan repr√©sentant les altitudes du terrain le long d'un axe ?", correctAnswer: "Profil en long", solution: "Le profil en long est une coupe verticale qui montre le relief du terrain et le projet le long d'un axe.", points: 150, time: 40 }, { type: 'scenario', text: "Sc√©nario : R√©seau inconnu", scenario: "En creusant une tranch√©e, vous d√©couvrez une canalisation non r√©pertori√©e. Quelle est la premi√®re action √† entreprendre ?", answers: [{ text: "Continuer en faisant attention.", correct: false }, { text: "Arr√™ter les travaux dans la zone et alerter le conducteur de travaux.", correct: true }, { text: "Essayer d'identifier le r√©seau en le per√ßant l√©g√®rement.", correct: false }, { text: "Recouvrir et ne rien dire.", correct: false }], solution: "La s√©curit√© prime. Il faut imm√©diatement arr√™ter les travaux, s√©curiser la zone et informer la hi√©rarchie.", points: 300, time: 60 }, { type: 'pipe-connect', text: "Connectez le r√©seau de gaz. Le chemin doit passer par la vanne de coupure.", gridSize: { rows: 6, cols: 8 }, start: { row: 5, col: 3 }, end: { row: 0, col: 7 }, obstacles: [{row: 2, col: 4, type: 'valve'}], pieces: { straight: 8, corner: 6 }, solution: "Le chemin doit √™tre continu de A √† B et obligatoirement passer par la case 'valve'.", points: 400, time: 200, bonus: true, pipeColor: '#FBBF24' } ];
            
            let gameState = {};
            
            // --- GESTION AUDIO ---
            let isSoundOn = false; // Le son est d√©sactiv√© par d√©faut
            const sounds = {
                start: new Tone.Synth({ oscillator: { type: "fatsawtooth" }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.3 } }).toDestination(),
                correct: new Tone.Synth({ oscillator: { type: "triangle" }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.2 } }).toDestination(),
                incorrect: new Tone.Synth({ oscillator: { type: "square" }, envelope: { attack: 0.01, decay: 0.3, sustain: 0, release: 0.2 } }).toDestination(),
                finish: new Tone.Synth({ oscillator: { type: "sine" }, envelope: { attack: 0.1, decay: 0.5, sustain: 0.3, release: 1 } }).toDestination(),
                click: new Tone.MembraneSynth({ pitchDecay: 0.01, octaves: 2, envelope: { attack: 0.001, decay: 0.2, sustain: 0 } }).toDestination(),
                timer_tick: new Tone.Synth({ oscillator: { type: 'sine' }, volume: -10, envelope: { attack: 0.001, decay: 0.1, sustain: 0, release: 0.1 } }).toDestination(),
                drag: new Tone.NoiseSynth({ noise: { type: 'pink' }, envelope: { attack: 0.005, decay: 0.1, sustain: 0 } }).toDestination(),
                drop: new Tone.MembraneSynth({ pitchDecay: 0.008, octaves: 4, envelope: { attack: 0.001, decay: 0.3, sustain: 0 } }).toDestination(),
                confetti: new Tone.PluckSynth({ attackNoise: 1, dampening: 4000, resonance: 0.7 }).toDestination()
            };
            
            function playSound(sound, ...args) {
                if (isSoundOn && sound && typeof sound.triggerAttackRelease === 'function') {
                    sound.triggerAttackRelease(...args);
                }
            }

            // --- FONCTIONS PRINCIPALES DU JEU ---
            function initGame() {
                gameState = { score: 0, currentQuestionIndex: -1, timeLeft: 0, timerInterval: null, totalTime: 0, totalTimeInterval: null, questions: shuffleArray([...questions]), answeredQuestions: [], isQuestionAnswered: false, };
                updateScore(0);
                switchScreen('home');
                dom.displays.timer.textContent = '--:--';
                dom.displays.timerContainer.classList.remove('warning');
            }

            function startGame() {
                // Demande √† l'utilisateur d'interagir pour activer l'audio
                Tone.start();
                isSoundOn = true; // Activer le son au d√©marrage du jeu
                playSound(sounds.start, "C4", "8n");
                gameState.answeredQuestions = new Array(gameState.questions.length).fill(null);
                startTotalTimer();
                nextQuestion();
            }

            function nextQuestion() {
                if (gameState.currentQuestionIndex >= gameState.questions.length - 1) { endGame(); return; }
                gameState.currentQuestionIndex++;
                displayQuestion();
            }

            function displayQuestion() {
                clearTimeout(gameState.timerInterval);
                dom.displays.feedback.innerHTML = '';
                dom.buttons.next.style.display = 'none';
                const question = gameState.questions[gameState.currentQuestionIndex];
                gameState.isQuestionAnswered = false;
                dom.displays.questionText.innerHTML = `Question ${gameState.currentQuestionIndex + 1}/${gameState.questions.length}: ${question.text}`;
                dom.displays.answerContainer.innerHTML = '';
                const interfaceBuilder = { 'qcm': createQCMInterface, 'scenario': createQCMInterface, 'multiple-choice': createMultipleChoiceInterface, 'calculation': createCalculationInterface, 'text-input': createTextInputInterface, 'chronological-order': createChronologicalOrderInterface, 'pipe-connect': createPipeConnectInterface, }[question.type];
                if (interfaceBuilder) interfaceBuilder(question);
                startTimer(question.time);
                switchScreen('question');
            }

            function endGame() {
                clearInterval(gameState.timerInterval);
                clearInterval(gameState.totalTimeInterval);
                playSound(sounds.finish, "C5", "1n", Tone.now() + 0.1);
                launchConfetti();
                const correctCount = gameState.answeredQuestions.filter(a => a && a.isCorrect).length;
                const totalQuestions = gameState.questions.length;
                dom.displays.finalScore.textContent = gameState.score;
                dom.displays.correctAnswers.textContent = `${correctCount} / ${totalQuestions}`;
                dom.displays.totalTime.textContent = formatTime(gameState.totalTime);
                let message = "Excellent travail ! Vous avez l'√©toffe d'un expert !";
                if (correctCount / totalQuestions < 0.5) message = "C'est un bon d√©but, continuez √† vous entra√Æner !";
                else if (correctCount / totalQuestions < 0.8) message = "Tr√®s bon score, vous progressez bien !";
                dom.displays.finalMessage.textContent = message;
                switchScreen('final');
            }

            function createQCMInterface(question) {
                const answerGrid = document.createElement('div');
                answerGrid.className = 'answer-grid';
                question.answers.forEach((answer, index) => {
                    const btn = document.createElement('button');
                    btn.className = 'answer-btn';
                    btn.innerHTML = answer.text;
                    btn.onclick = () => handleAnswer(index, index);
                    answerGrid.appendChild(btn);
                });
                dom.displays.answerContainer.appendChild(answerGrid);
            }

            function createMultipleChoiceInterface(question) {
                const materialGrid = document.createElement('div');
                materialGrid.className = 'material-grid';
                question.answers.forEach((answer, index) => {
                    const card = document.createElement('div');
                    card.className = 'material-card';
                    card.dataset.index = index;
                    card.innerHTML = `<div class="material-icon">${answer.icon || '‚ùî'}</div><p>${answer.text}</p>`;
                    card.onclick = () => { if (!gameState.isQuestionAnswered) card.classList.toggle('selected'); };
                    materialGrid.appendChild(card);
                });
                dom.displays.answerContainer.appendChild(materialGrid);
                addSubmitButton(() => {
                    const selectedCards = dom.displays.answerContainer.querySelectorAll('.material-card.selected');
                    const selectedIndices = Array.from(selectedCards).map(c => parseInt(c.dataset.index));
                    handleAnswer(selectedIndices, selectedIndices);
                });
            }

            function createCalculationInterface(question) {
                const input = document.createElement('input');
                input.type = 'number';
                input.step = 'any';
                input.className = 'elevation-input';
                input.placeholder = 'Votre r√©ponse...';
                dom.displays.answerContainer.appendChild(input);
                addSubmitButton(() => { const value = parseFloat(input.value); if (!isNaN(value)) handleAnswer(value, value); });
            }

            function createTextInputInterface(question) {
                const input = document.createElement('input');
                input.type = 'text';
                input.className = 'text-input';
                input.placeholder = 'Votre r√©ponse...';
                dom.displays.answerContainer.appendChild(input);
                addSubmitButton(() => { const value = input.value.trim(); if (value) handleAnswer(value, value); });
            }

            function createChronologicalOrderInterface(question) {
                const container = document.createElement('div');
                container.style.width = '100%';
                container.style.maxWidth = '800px';
                const dropZone = document.createElement('div');
                dropZone.className = 'drop-zone';
                dropZone.textContent = 'D√©posez les √©tapes ici';
                const draggableContainer = document.createElement('div');
                draggableContainer.className = 'mt-6 p-4 flex flex-wrap gap-2 justify-center';
                shuffleArray([...question.items]).forEach((item) => {
                    const el = document.createElement('div');
                    el.className = 'draggable';
                    el.textContent = item;
                    el.draggable = true;
                    el.dataset.id = item;
                    el.addEventListener('dragstart', e => { playSound(sounds.drag, "8n"); e.dataTransfer.setData('text/plain', item); setTimeout(() => el.style.opacity = '0.5', 0); });
                    el.addEventListener('dragend', () => el.style.opacity = '1');
                    draggableContainer.appendChild(el);
                });
                container.appendChild(dropZone);
                container.appendChild(draggableContainer);
                dom.displays.answerContainer.appendChild(container);
                [dropZone, draggableContainer].forEach(zone => {
                    zone.addEventListener('dragover', e => { e.preventDefault(); zone.classList.add('hover'); });
                    zone.addEventListener('dragleave', () => zone.classList.remove('hover'));
                    zone.addEventListener('drop', e => {
                        e.preventDefault();
                        playSound(sounds.drop, "C3", "8n");
                        zone.classList.remove('hover');
                        if (dropZone.textContent === 'D√©posez les √©tapes ici') { dropZone.textContent = ''; dropZone.classList.add('filled'); }
                        const data = e.dataTransfer.getData('text/plain');
                        const draggable = document.querySelector(`.draggable[data-id="${data}"]`);
                        if (draggable) zone.appendChild(draggable);
                        if (dropZone.children.length === 0) { dropZone.textContent = 'D√©posez les √©tapes ici'; dropZone.classList.remove('filled'); }
                    });
                });
                addSubmitButton(() => { const droppedItems = Array.from(dropZone.children).map(child => child.dataset.id); handleAnswer(droppedItems, droppedItems); });
            }
            
            function createPipeConnectInterface(question) {
                const container = document.createElement('div');
                container.className = 'pipe-game-container';
                const pipeTray = document.createElement('div');
                pipeTray.className = 'pipe-tray';
                const createDraggablePipe = (type, count) => {
                    const piece = document.createElement('div');
                    piece.className = 'pipe-piece-draggable';
                    piece.draggable = true;
                    piece.dataset.pipeType = type;
                    piece.innerHTML = getPipeSVG(type, 0, question.pipeColor) + `<span class="pipe-count" id="pipe-count-${type}">${count}</span>`;
                    piece.addEventListener('dragstart', e => { if (parseInt(document.getElementById(`pipe-count-${type}`).textContent) > 0) { playSound(sounds.drag, "8n"); e.dataTransfer.setData('text/plain', type); piece.classList.add('dragging'); } else { e.preventDefault(); } });
                    piece.addEventListener('dragend', () => piece.classList.remove('dragging'));
                    return piece;
                };
                Object.keys(question.pieces).forEach(type => pipeTray.appendChild(createDraggablePipe(type, question.pieces[type])));
                const gridContainer = document.createElement('div');
                gridContainer.className = 'pipe-grid-container';
                gridContainer.style.setProperty('--grid-cols', question.gridSize.cols);
                gridContainer.id = 'pipe-grid';
                for (let r = 0; r < question.gridSize.rows; r++) {
                    for (let c = 0; c < question.gridSize.cols; c++) {
                        const cell = document.createElement('div');
                        cell.className = 'grid-cell';
                        cell.dataset.row = r;
                        cell.dataset.col = c;
                        if (r === question.start.row && c === question.start.col) cell.classList.add('start-node');
                        else if (r === question.end.row && c === question.end.col) cell.classList.add('end-node');
                        else if (question.obstacles?.some(o => o.row === r && o.col === c)) {
                            cell.classList.add('obstacle-node');
                            cell.innerHTML = `<div style="width: 66%; height: 66%; color: var(--text-primary);"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 3v18M3 12h18M12 12a4 4 0 1 0 0-0.001 4 4 0 0 0 0 0.001z"/><path d="m16 8-4-4-4 4"/></svg></div>`;
                            cell.dataset.obstacle = true;
                        }
                        cell.addEventListener('dragover', e => e.preventDefault());
                        cell.addEventListener('drop', e => {
                            e.preventDefault();
                            if (cell.innerHTML !== '' || cell.classList.contains('start-node') || cell.classList.contains('end-node')) return;
                            const type = e.dataTransfer.getData('text/plain');
                            const countEl = document.getElementById(`pipe-count-${type}`);
                            let count = parseInt(countEl.textContent);
                            if (count > 0) {
                                playSound(sounds.drop, "C3", "8n");
                                count--;
                                countEl.textContent = count;
                                const placedPiece = document.createElement('div');
                                placedPiece.className = 'pipe-piece-placed';
                                placedPiece.dataset.pipeType = type;
                                placedPiece.dataset.rotation = 0;
                                placedPiece.innerHTML = getPipeSVG(type, 0, question.pipeColor);
                                placedPiece.addEventListener('click', () => {
                                    if (gameState.isQuestionAnswered) return;
                                    let currentRotation = parseInt(placedPiece.dataset.rotation);
                                    currentRotation = (currentRotation + 90) % 360;
                                    placedPiece.dataset.rotation = currentRotation;
                                    placedPiece.style.transform = `rotate(${currentRotation}deg)`;
                                });
                                placedPiece.addEventListener('contextmenu', (ev) => {
                                    ev.preventDefault();
                                    if (gameState.isQuestionAnswered) return;
                                    cell.innerHTML = '';
                                    const typeToRemove = placedPiece.dataset.pipeType;
                                    const countElToRemove = document.getElementById(`pipe-count-${typeToRemove}`);
                                    countElToRemove.textContent = parseInt(countElToRemove.textContent) + 1;
                                });
                                cell.appendChild(placedPiece);
                            }
                        });
                        gridContainer.appendChild(cell);
                    }
                }
                container.appendChild(pipeTray);
                container.appendChild(gridContainer);
                dom.displays.answerContainer.appendChild(container);
                addSubmitButton(() => {
                    const placedPipes = [];
                    gridContainer.querySelectorAll('.pipe-piece-placed').forEach(p => {
                        const cell = p.parentElement;
                        placedPipes.push({ row: parseInt(cell.dataset.row), col: parseInt(cell.dataset.col), type: p.dataset.pipeType, rotation: parseInt(p.dataset.rotation) });
                    });
                    handleAnswer(placedPipes, placedPipes);
                }, 'V√©rifier');
            }

            function addSubmitButton(callback, text = 'Valider') {
                const submitBtn = document.createElement('button');
                submitBtn.textContent = text;
                submitBtn.className = 'btn';
                submitBtn.style.marginTop = '2rem';
                submitBtn.onclick = callback;
                dom.displays.answerContainer.appendChild(submitBtn);
            }

            function handleAnswer(userAnswer, answerForStorage) {
                if (gameState.isQuestionAnswered) return;
                clearInterval(gameState.timerInterval);
                gameState.isQuestionAnswered = true;
                const question = gameState.questions[gameState.currentQuestionIndex];
                let isCorrect = false;
                switch (question.type) {
                    case 'qcm': case 'scenario': isCorrect = userAnswer !== null && question.answers[userAnswer].correct; break;
                    case 'multiple-choice':
                        const correctIndices = question.answers.map((a, i) => a.correct ? i : -1).filter(i => i !== -1);
                        isCorrect = userAnswer && userAnswer.length === correctIndices.length && userAnswer.every(index => correctIndices.includes(index));
                        break;
                    case 'calculation': isCorrect = userAnswer !== null && Math.abs(userAnswer - question.correctAnswer) <= (question.tolerance || 0.01); break;
                    case 'text-input': isCorrect = userAnswer && userAnswer.toLowerCase().trim() === question.correctAnswer.toLowerCase().trim(); break;
                    case 'chronological-order': isCorrect = userAnswer && userAnswer.length === question.items.length && userAnswer.every((item, index) => item === question.items[index]); break;
                    case 'pipe-connect': isCorrect = checkPipeConnection(userAnswer, question); break;
                }
                gameState.answeredQuestions[gameState.currentQuestionIndex] = { answer: answerForStorage, isCorrect: isCorrect };
                if (isCorrect) {
                    playSound(sounds.correct, "C5", "8n", Tone.now() + 0.1);
                    dom.displays.feedback.innerHTML = "Bonne r√©ponse !";
                    dom.displays.feedback.style.color = 'var(--correct)';
                    let pointsGained = question.points;
                    if (question.bonus) pointsGained *= 2;
                    updateScore(gameState.score + pointsGained);
                } else {
                    playSound(sounds.incorrect, "C3", "8n", Tone.now() + 0.1);
                    dom.displays.feedback.innerHTML = `R√©ponse incorrecte. <br><span class="feedback-solution">${question.solution}</span>`;
                    dom.displays.feedback.style.color = 'var(--incorrect)';
                }
                showSolutionVisuals(question, isCorrect);
                dom.buttons.next.style.display = 'inline-flex';
            }

            function showSolutionVisuals(question, isCorrect) {
                 const answerElements = dom.displays.answerContainer.querySelectorAll('.answer-btn, .material-card, .draggable, .pipe-piece-placed, input, button');
                 answerElements.forEach(el => { el.style.pointerEvents = 'none'; el.disabled = true; if(el.classList.contains('material-card')) el.classList.add('disabled'); });
                 switch (question.type) {
                    case 'qcm': case 'scenario': dom.displays.answerContainer.querySelectorAll('.answer-btn').forEach((btn, index) => { if (question.answers[index].correct) btn.classList.add('correct'); }); break;
                    case 'multiple-choice':
                        dom.displays.answerContainer.querySelectorAll('.material-card').forEach((card, index) => {
                            const isSelected = card.classList.contains('selected');
                            const isCorrectAnswer = question.answers[index].correct;
                            if (isCorrectAnswer) card.classList.add('correct');
                            else if (isSelected && !isCorrectAnswer) card.classList.add('incorrect');
                        });
                        break;
                 }
            }
            
            function getPipeSVG(type, rotation, color) {
                let path = '';
                if (type === 'straight') path = `<path d="M0 50 L100 50" stroke="${color}" stroke-width="12" stroke-linecap="round" />`;
                else if (type === 'corner') path = `<path d="M0 50 L50 50 L50 100" stroke="${color}" stroke-width="12" stroke-linecap="round" fill="none" />`;
                return `<svg class="w-full h-full" viewBox="0 0 100 100" style="transform: rotate(${rotation}deg);">${path}</svg>`;
            }

            function getPipeExits(pipe) {
                if (!pipe) return [];
                const { type, rotation } = pipe;
                const r = (parseInt(rotation, 10) + 360) % 360;
                if (type === 'straight') return (r === 90 || r === 270) ? ['up', 'down'] : ['left', 'right'];
                if (type === 'corner') { if (r === 0) return ['left', 'down']; if (r === 90) return ['down', 'right']; if (r === 180) return ['right', 'up']; if (r === 270) return ['up', 'left']; }
                return [];
            }
            
            function checkPipeConnection(placedPipes, question) {
                if (!Array.isArray(placedPipes)) return false;
                const { gridSize, start, end, obstacles } = question;
                const grid = Array(gridSize.rows).fill(null).map(() => Array(gridSize.cols).fill(null));
                placedPipes.forEach(p => { grid[p.row][p.col] = p; });
                let queue = [];
                let visited = new Set();
                const directions = { up: { r: -1, c: 0, opp: 'down' }, down: { r: 1, c: 0, opp: 'up' }, left: { r: 0, c: -1, opp: 'right' }, right: { r: 0, c: 1, opp: 'left' } };
                for (const dirName in directions) {
                    const { r, c, opp } = directions[dirName];
                    const nextR = start.row + r;
                    const nextC = start.col + c;
                    const key = `${nextR},${nextC}`;
                    if (nextR >= 0 && nextR < gridSize.rows && nextC >= 0 && nextC < gridSize.cols) {
                        const nextPipe = grid[nextR]?.[nextC];
                        if (nextPipe && getPipeExits(nextPipe).includes(opp)) { visited.add(key); queue.push({ row: nextR, col: nextC, path: [`${start.row},${start.col}`, key] }); }
                    }
                }
                while (queue.length > 0) {
                    const current = queue.shift();
                    const currentPipe = grid[current.row][current.col];
                    const currentExits = getPipeExits(currentPipe);
                    for (const dirName in directions) {
                        const { r, c } = directions[dirName];
                        if (currentExits.includes(dirName)) {
                            const neighborR = current.row + r;
                            const neighborC = current.col + c;
                            if (neighborR === end.row && neighborC === end.col) {
                                const finalPath = [...current.path, `${end.row},${end.col}`];
                                const pathSet = new Set(finalPath);
                                const allObstaclesOnPath = obstacles?.every(o => pathSet.has(`${o.row},${o.col}`)) ?? true;
                                if (allObstaclesOnPath) return true;
                            }
                        }
                    }
                    for (const dirName in directions) {
                        const { r, c, opp } = directions[dirName];
                        if (currentExits.includes(dirName)) {
                            const nextR = current.row + r;
                            const nextC = current.col + c;
                            const key = `${nextR},${nextC}`;
                            if (nextR >= 0 && nextR < gridSize.rows && nextC >= 0 && nextC < gridSize.cols && !visited.has(key)) {
                                const nextPipe = grid[nextR]?.[nextC];
                                if (nextPipe && getPipeExits(nextPipe).includes(opp)) { visited.add(key); queue.push({ row: nextR, col: nextC, path: [...current.path, key] }); }
                            }
                        }
                    }
                }
                return false;
            }

            function switchScreen(screenName) { Object.values(dom.screens).forEach(s => s.classList.remove('active')); dom.screens[screenName].classList.add('active'); }
            function updateScore(newScore) { gameState.score = newScore; dom.displays.score.textContent = newScore; }
            function startTimer(duration) {
                gameState.timeLeft = duration;
                dom.displays.timerContainer.classList.remove('warning');
                function update() {
                    dom.displays.timer.textContent = formatTime(gameState.timeLeft);
                    if (gameState.timeLeft <= 10 && gameState.timeLeft > 0) {
                        dom.displays.timerContainer.classList.add('warning');
                        playSound(sounds.timer_tick, 'C6', '16n');
                    }
                    if (gameState.timeLeft <= 0) { clearInterval(gameState.timerInterval); handleAnswer(null, 'timeout'); }
                    gameState.timeLeft--;
                }
                update();
                gameState.timerInterval = setInterval(update, 1000);
            }
            function startTotalTimer() { gameState.totalTime = 0; if(gameState.totalTimeInterval) clearInterval(gameState.totalTimeInterval); gameState.totalTimeInterval = setInterval(() => { gameState.totalTime++; }, 1000); }
            function formatTime(seconds) { const mins = Math.floor(seconds / 60); const secs = seconds % 60; return `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`; }
            function shuffleArray(array) { for (let i = array.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [array[i], array[j]] = [array[j], array[i]]; } return array; }
            function launchConfetti() {
                playSound(sounds.confetti, "C4", "8n", Tone.now());
                playSound(sounds.confetti, "G4", "8n", Tone.now() + 0.1);
                playSound(sounds.confetti, "E5", "8n", Tone.now() + 0.2);
                for (let i = 0; i < 100; i++) { const c = document.createElement('div'); c.className = 'confetti'; c.style.left = `${Math.random()*100}vw`; c.style.animationDelay = `${Math.random()*2}s`; c.style.backgroundColor=`hsl(${Math.random()*360},100%,50%)`; c.style.transform=`scale(${Math.random()*.5+.5})`; document.body.appendChild(c); setTimeout(()=>c.remove(),3000);}
            }

            dom.buttons.start.addEventListener('click', () => { startGame(); playSound(sounds.click, "C2", "8n"); });
            dom.buttons.next.addEventListener('click', () => { nextQuestion(); playSound(sounds.click, "C2", "8n"); });
            dom.buttons.restartFinal.addEventListener('click', () => { initGame(); playSound(sounds.click, "C2", "8n"); });

            initGame();
        });
    </script>
</body>
</html>
