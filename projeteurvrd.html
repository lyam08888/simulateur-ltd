<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LTD Simulateur - Projeteur VRD</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700;800&family=Poppins:wght@700;800&display=swap" rel="stylesheet">
    <style>
        /* D√©finition des variables de couleur pour une maintenance facile */
        :root {
            --bg-color: #f8fafc; /* Gris clair */
            --container-bg: #ffffff;
            --primary-color: #0ea5e9; /* Bleu ciel */
            --secondary-color: #10b981; /* Vert √©meraude */
            --text-dark: #1e293b; /* Ardoise fonc√© */
            --text-light: #64748b; /* Ardoise clair */
            --border-color: #e2e8f0; /* Ardoise 200 */
            --correct-color: #22c55e; /* Vert */
            --incorrect-color: #ef4444; /* Rouge */
        }

        /* Reset et Box-sizing global */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html {
            font-size: 16px;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-color);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 1rem;
            color: var(--text-dark);
        }
        
        .game-container {
            width: 100%;
            max-width: 1400px;
            height: 95vh;
            background: var(--container-bg);
            border-radius: 2rem;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            transition: all 0.5s ease-in-out;
            border: 1px solid var(--border-color);
        }
        
        .game-header {
            background: white;
            color: var(--text-dark);
            padding: 1rem 2.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border-color);
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            z-index: 10;
        }
        
        .logo {
            display: flex;
            align-items: center;
            gap: 1rem;
            font-size: 1.25rem;
            font-weight: 700;
        }
        
        .logo-icon {
            width: 3rem;
            height: 3rem;
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            border-radius: 0.75rem;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            box-shadow: 0 4px 15px rgba(14, 165, 233, 0.3);
        }
        .logo-icon svg { width: 60%; height: 60%; }
        
        .header-stats { display: flex; gap: 1rem; align-items: center; }
        
        .header-item {
            display: flex; align-items: center; gap: 0.5rem;
            font-size: 1.25rem; font-weight: 700;
            background: var(--bg-color);
            padding: 0.5rem 1.25rem; border-radius: 50px;
        }
        
        .timer-display.warning { animation: pulse 1s infinite; color: var(--incorrect-color); }
        @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.05); } }
        
        .screen {
            display: none; flex: 1;
            padding: 7rem 2rem 5rem 2rem;
            overflow-y: auto;
            animation: fadeIn 0.5s ease-out;
        }
        
        .screen.active { display: flex; flex-direction: column; align-items: center; justify-content: center; }
        
        @keyframes fadeIn { from { opacity: 0; transform: scale(0.98); } to { opacity: 1; transform: scale(1); } }
        
        h1 {
            font-family: 'Poppins', sans-serif;
            font-size: clamp(2.5rem, 5vw, 3.5rem);
            font-weight: 800;
            color: var(--text-dark);
            margin-bottom: 1.5rem; text-align: center;
        }
        
        h2 {
            font-family: 'Poppins', sans-serif;
            font-size: clamp(1.5rem, 4vw, 2rem);
            font-weight: 700; color: var(--text-dark);
            margin-bottom: 2rem; text-align: center; line-height: 1.4;
            max-width: 800px;
        }

        p { font-size: 1.1rem; color: var(--text-light); }
        
        .btn {
            background: var(--primary-color);
            color: white; border: none; padding: 1rem 3rem;
            border-radius: 0.75rem; font-size: 1.1rem; font-weight: 700;
            cursor: pointer; transition: all 0.2s ease-out;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
        }
        
        .btn:hover { transform: translateY(-2px); box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -4px rgba(0, 0, 0, 0.1); }
        .btn:active { transform: translateY(0); }
        .btn:disabled { opacity: 0.7; cursor: not-allowed; background: #94a3b8; box-shadow: none; }
        
        .answer-grid {
            display: grid; grid-template-columns: 1fr;
            gap: 1rem; width: 100%; max-width: 1000px; margin-top: 2rem;
        }
        
        .answer-btn {
            background: white;
            border: 1px solid var(--border-color);
            color: var(--text-dark);
            padding: 1.25rem; border-radius: 0.75rem;
            font-size: 1rem; font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease-out; text-align: center;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px -1px rgba(0, 0, 0, 0.1);
        }
        
        .answer-btn:not(:disabled):hover { transform: translateY(-2px); border-color: var(--primary-color); box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1); }
        .answer-btn.correct { background: var(--correct-color) !important; color: white !important; border-color: var(--correct-color) !important; animation: bounce 0.5s ease; }
        .answer-btn.incorrect { background: var(--incorrect-color) !important; color: white !important; border-color: var(--incorrect-color) !important; animation: shake 0.5s ease; }
        .answer-btn:disabled { cursor: not-allowed; }

        @keyframes bounce { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-6px); } }
        @keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-5px); } 75% { transform: translateX(5px); } }
        
        .controls {
            position: fixed; right: 1.5rem; top: 50%;
            transform: translateY(-50%); display: flex;
            flex-direction: column; gap: 1rem;
            z-index: 20;
        }
        
        .control-btn {
            width: 3.5rem; height: 3.5rem; border-radius: 50%;
            border: 1px solid var(--border-color);
            background: white;
            color: var(--text-dark);
            cursor: pointer;
            transition: all 0.2s ease-out; display: flex;
            align-items: center; justify-content: center;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
            font-size: 1.5rem; /* Ajustement pour la taille des √©mojis */
        }
        .control-btn:hover:not(:disabled) { transform: translateY(-2px) scale(1.05); color: var(--primary-color); }
        .control-btn:disabled { opacity: 0.5; cursor: not-allowed; }
        
        .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.5); z-index: 1000; justify-content: center; align-items: center; backdrop-filter: blur(5px); }
        .modal.active { display: flex; }
        .modal-content { background: #fff; color: var(--text-dark); padding: 2rem; border-radius: 1.5rem; max-width: 90vw; width: 700px; max-height: 85vh; overflow-y: auto; position: relative; animation: modalIn 0.3s ease; box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25); }
        @keyframes modalIn { from { transform: scale(0.95); opacity: 0; } to { transform: scale(1); opacity: 1; } }
        .modal-close { position: absolute; top: 1rem; right: 1rem; width: 2.5rem; height: 2.5rem; border: none; background: #f1f5f9; color: var(--text-light); border-radius: 50%; font-size: 1.5rem; cursor: pointer; transition: all 0.3s ease; display: flex; align-items: center; justify-content: center; }
        .modal-close:hover { background: var(--border-color); color: var(--text-dark); transform: rotate(90deg); }
        
        .material-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 1rem; width: 100%; max-width: 1000px; margin-top: 2rem; }
        .material-card { background: white; border: 2px solid var(--border-color); color: var(--text-dark); border-radius: 1rem; padding: 1.5rem; text-align: center; cursor: pointer; transition: all 0.3s ease; display: flex; flex-direction: column; align-items: center; gap: 1rem; }
        .material-icon { font-size: 3rem; line-height: 1; }
        .material-card:not(.disabled):hover { transform: translateY(-4px); border-color: var(--primary-color); }
        .material-card.selected { border-color: var(--secondary-color); box-shadow: 0 0 0 2px var(--secondary-color); }
        .material-card.correct { background: var(--correct-color) !important; color: white !important; border-color: var(--correct-color) !important; }
        .material-card.incorrect { background: var(--incorrect-color) !important; color: white !important; border-color: var(--incorrect-color) !important; }
        .material-card.disabled { cursor: not-allowed; opacity: 0.7; }

        .elevation-input, .text-input { font-size: 1.5rem; padding: 1rem 2rem; border: 1px solid var(--border-color); border-radius: 0.75rem; text-align: center; width: 100%; max-width: 400px; transition: all 0.3s ease; margin: 1rem 0; }
        .elevation-input:focus, .text-input:focus { outline: none; border-color: var(--primary-color); box-shadow: 0 0 0 3px rgba(14, 165, 233, 0.2); }
        
        .tips-bar { display: block; position: absolute; bottom: 0; left: 0; width: 100%; background: var(--bg-color); color: var(--text-light); padding: 0.5rem 0; font-size: 0.9rem; font-weight: 500; overflow: hidden; white-space: nowrap; z-index: 10; height: 2.5rem; border-top: 1px solid var(--border-color); }
        .tips-bar-content { display: inline-block; padding-left: 100%; animation: marquee 30s linear infinite; }
        @keyframes marquee { 0% { transform: translateX(0%); } 100% { transform: translateX(-100%); } }

        #homeScreen { justify-content: center; align-items: center; background: transparent; }
        #homeScreen h1 { color: var(--text-dark); }
        #homeScreen p { color: var(--text-light); max-width: 600px; text-align: center; font-size: 1.25rem; }
        #homeScreen .logo-icon { width: 10rem; height: 10rem; margin-bottom: 2rem; border-radius: 2rem;}
        #homeScreen .btn { padding: 1.25rem 4rem; font-size: 1.5rem; }
        
        .button-center-align { width: 100%; display: flex; justify-content: center; }

        /* Styles pour l'√©cran final */
        .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1.5rem; width: 100%; max-width: 800px; margin: 2rem 0; }
        .stat-card { background: var(--bg-color); padding: 1.5rem; border-radius: 1rem; text-align: center; border: 1px solid var(--border-color); }
        .stat-label { font-weight: 500; color: var(--text-light); margin-bottom: 0.5rem; }
        .stat-number { font-weight: 800; font-size: 2.5rem; color: var(--primary-color); }

        /* Styles pour le jeu de connexion de tuyaux */
        .pipe-game-container { display: flex; flex-direction: column; align-items: center; gap: 1rem; width: 100%; }
        .pipe-tray { display: flex; gap: 1rem; background: var(--bg-color); padding: 1rem; border-radius: 1rem; flex-wrap: wrap; justify-content: center; }
        .pipe-piece-draggable { width: 50px; height: 50px; cursor: grab; position: relative; }
        .pipe-piece-draggable.dragging { opacity: 0.5; }
        .pipe-count { position: absolute; bottom: -5px; right: -5px; background: var(--primary-color); color: white; border-radius: 50%; width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 0.8rem; }
        .pipe-grid-container { display: grid; grid-template-columns: repeat(var(--grid-cols, 5), 1fr); border: 2px solid var(--border-color); border-radius: 1rem; overflow: hidden; background: #f1f5f9; width: 100%; max-width: 90vw; }
        .grid-cell { border: 1px solid var(--border-color); display: flex; align-items: center; justify-content: center; position: relative; background-color: white; aspect-ratio: 1 / 1; }
        .grid-cell.start-node { background-color: var(--correct-color); color: white; font-weight: bold; font-size: 1.5rem; }
        .grid-cell.end-node { background-color: var(--incorrect-color); color: white; font-weight: bold; font-size: 1.5rem; }
        .pipe-piece-placed { width: 100%; height: 100%; transition: transform 0.2s ease; cursor: pointer; }
        .grid-cell.obstacle-node { background-color: #e2e8f0; }

        /* Styles pour le jeu d'ordre chronologique */
        .draggable { padding: 0.75rem; background: white; border: 1px solid var(--border-color); border-radius: 0.5rem; cursor: grab; transition: all 0.2s ease; user-select: none; }
        .draggable:active { cursor: grabbing; background: #f1f5f9; }
        .drop-zone { border: 2px dashed var(--border-color); border-radius: 0.75rem; background: #f8fafc; transition: all 0.2s ease; }
        .drop-zone.hover { border-color: var(--primary-color); background: #eff6ff; }
        .drop-zone.filled { border-style: solid; }

        /* Styles pour le s√©lecteur de vue */
        .view-mode-switcher { position: fixed; bottom: 1rem; left: 1rem; z-index: 1001; display: flex; gap: 0.5rem; background: white; padding: 0.5rem; border-radius: 0.75rem; border: 1px solid var(--border-color); box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1); }
        .view-mode-btn { background-color: transparent; border: 1px solid transparent; color: var(--text-light); padding: 0.5rem; border-radius: 0.5rem; cursor: pointer; font-weight: 500; transition: all 0.3s ease; font-size: 0.8rem; }
        .view-mode-btn:hover { background-color: var(--bg-color); color: var(--text-dark); }
        .view-mode-btn.active { background-color: var(--primary-color); color: white; pointer-events: none; }

        /* Styles pour les confettis */
        .confetti { position: fixed; width: 10px; height: 10px; top: -20px; animation: fall 3s linear forwards; }
        @keyframes fall { to { transform: translateY(100vh) rotate(360deg); } }

        @media (min-width: 768px) {
            .answer-grid { grid-template-columns: repeat(2, 1fr); gap: 1.5rem; }
            .screen { padding: 8rem 5rem 6rem 5rem; }
        }

        /* --- OPTIMISATIONS MOBILES --- */
        @media (max-width: 767px) {
            .game-header { padding: 0.5rem 1rem; height: auto; flex-wrap: wrap; justify-content: center; gap: 0.5rem;}
            .logo { font-size: 1rem; }
            .logo-icon { width: 2.5rem; height: 2.5rem; }
            .header-item { font-size: 1rem; padding: 0.4rem 0.8rem; gap: 0.4rem; }
            
            /* FIX: Augmentation du padding sup√©rieur pour √©viter que l'en-t√™te (qui peut s'√©tendre sur deux lignes) ne soit masqu√© par le contenu. */
            .screen { padding: 6rem 1rem 7rem 1rem; }
            
            h1 { font-size: clamp(2rem, 8vw, 2.5rem); }
            h2 { font-size: clamp(1.2rem, 5vw, 1.5rem); margin-bottom: 1.5rem; }
            
            .controls { flex-direction: row; bottom: 1rem; top: auto; left: 50%; transform: translateX(-50%); width: auto; padding: 0.5rem; border-radius: 50px; background: rgba(255,255,255,0.8); backdrop-filter: blur(5px); }
            .control-btn { width: 3rem; height: 3rem; font-size: 1.2rem; }
            
            .view-mode-switcher { bottom: 5rem; left: 50%; transform: translateX(-50%); }
            
            #homeScreen .logo-icon { width: 8rem; height: 8rem; }
            #homeScreen .btn { font-size: 1.2rem; }
            #homeScreen p { font-size: 1rem; }

            /* Optimisation des grilles de r√©ponse */
            .material-grid { grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 0.5rem; }
            .material-card { padding: 1rem; }
            .answer-btn { padding: 1rem; font-size: 0.9rem; }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <!-- En-t√™te du jeu avec logo, score et minuteur -->
        <div class="game-header">
            <div class="logo">
                <div id="logoIconContainer" class="logo-icon"></div>
                <span>LTD SIMULATEUR</span>
            </div>
            <div class="header-stats">
                <div id="scoreDisplay" class="header-item">
                    <span class="score-icon">‚≠ê</span>
                    <span id="score">0</span>
                </div>
                <div id="timerDisplay" class="header-item timer-display">
                    <span class="timer-icon">‚è∞</span>
                    <span id="timer">--:--</span>
                </div>
            </div>
        </div>
        
        <!-- √âcran d'accueil -->
        <div id="homeScreen" class="screen active">
            <div id="homeLogoIconContainer" class="logo-icon"></div>
            <h1>Simulateur Projeteur VRD</h1>
            <p>Testez vos connaissances et devenez un expert en Voirie et R√©seaux Divers.</p>
            <button id="startBtn" class="btn mt-8">D√©marrer la simulation</button>
        </div>

        <!-- √âcran de question -->
        <div id="questionScreen" class="screen">
            <h2 id="questionText"></h2>
            <div id="answerContainer" class="w-full flex flex-col items-center"></div>
            <div id="feedbackText" class="mt-4 text-xl text-center font-bold"></div>
            <div class="button-center-align">
                <button id="nextBtn" class="btn mt-8" style="display: none;">Question Suivante</button>
            </div>
        </div>

        <!-- √âcran final -->
        <div id="finalScreen" class="screen">
            <h1>Simulation Termin√©e !</h1>
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-label">Score Final</div>
                    <div id="finalScore" class="stat-number">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Bonnes R√©ponses</div>
                    <div id="correctAnswers" class="stat-number">0 / 0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Temps Total</div>
                    <div id="totalTime" class="stat-number">00:00</div>
                </div>
            </div>
            <p id="finalMessage" class="text-2xl mt-4 mb-8 text-center"></p>
            <button id="restartBtnFinal" class="btn">Recommencer</button>
        </div>

        <!-- Barre de conseils d√©filants -->
        <div class="tips-bar">
            <div id="tipsBarContent" class="tips-bar-content"></div>
        </div>
    </div>

    <!-- Contr√¥les de navigation du jeu -->
    <div class="controls">
        <button id="prevBtn" class="control-btn" aria-label="Question pr√©c√©dente"></button>
        <button id="restartBtn" class="control-btn" aria-label="Recommencer"></button>
        <button id="musicBtn" class="control-btn" aria-label="Activer/D√©sactiver la musique"></button>
        <button id="helpBtn" class="control-btn" aria-label="Aide"></button>
        <button id="solutionBtn" class="control-btn" aria-label="Voir la solution" style="display: none;"></button>
        <button id="skipBtn" class="control-btn" aria-label="Passer la question" style="display: none;"></button>
        <button id="finishBtn" class="control-btn" aria-label="Terminer la simulation" style="display: none;"></button>
    </div>

    <!-- S√©lecteur de mode de vue (Desktop/Mobile) -->
    <div class="view-mode-switcher">
        <button id="view-auto" class="view-mode-btn active" data-mode="auto">Auto</button>
        <button id="view-mobile" class="view-mode-btn" data-mode="mobile">Mobile</button>
        <button id="view-desktop" class="view-mode-btn" data-mode="desktop">Desktop</button>
    </div>
    
    <!-- Fen√™tre modale d'aide -->
    <div id="helpModal" class="modal">
        <div class="modal-content">
            <button class="modal-close">&times;</button>
            <h2>Aide & Instructions</h2>
            <p class="text-lg">Bienvenue dans le simulateur de Projeteur VRD !</p>
            <ul class="list-disc list-inside mt-4 space-y-2 text-lg">
                <li>R√©pondez aux questions pour gagner des points.</li>
                <li>Utilisez les boutons de contr√¥le pour naviguer, recommencer, ou couper la musique.</li>
                <li>Certaines questions sont des mini-jeux interactifs. Suivez les instructions √† l'√©cran.</li>
                <li>Votre temps est limit√© pour chaque question, alors soyez rapide !</li>
                <li>Le bouton "Solution" vous montrera la bonne r√©ponse mais vous co√ªtera des points.</li>
            </ul>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- S√âLECTION DES √âL√âMENTS DU DOM ---
            const dom = {
                screens: { home: document.getElementById('homeScreen'), question: document.getElementById('questionScreen'), final: document.getElementById('finalScreen'), },
                buttons: { start: document.getElementById('startBtn'), next: document.getElementById('nextBtn'), restartFinal: document.getElementById('restartBtnFinal'), prev: document.getElementById('prevBtn'), restart: document.getElementById('restartBtn'), music: document.getElementById('musicBtn'), help: document.getElementById('helpBtn'), solution: document.getElementById('solutionBtn'), skip: document.getElementById('skipBtn'), finish: document.getElementById('finishBtn'), },
                displays: { score: document.getElementById('score'), timer: document.getElementById('timer'), timerContainer: document.getElementById('timerDisplay'), questionText: document.getElementById('questionText'), answerContainer: document.getElementById('answerContainer'), feedback: document.getElementById('feedbackText'), finalScore: document.getElementById('finalScore'), correctAnswers: document.getElementById('correctAnswers'), totalTime: document.getElementById('totalTime'), finalMessage: document.getElementById('finalMessage'), tipsBarContent: document.getElementById('tipsBarContent'), },
                modals: { help: document.getElementById('helpModal'), },
                gameContainer: document.querySelector('.game-container'),
                viewModeButtons: document.querySelectorAll('.view-mode-btn'),
                logoIconContainer: document.getElementById('logoIconContainer'),
                homeLogoIconContainer: document.getElementById('homeLogoIconContainer'),
            };

            // --- IC√îNES ---
            const svgIcons = {
                crane: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M14 2L12 4H10V2H8V4H6L4 2L2 4V14H4V22H6V14H8V22H10V14H12V22H14V14H16V22H18V14H20V4L18 2L16 4H14V2ZM4 12V6H6V12H4ZM8 12V6H10V12H8ZM12 12V6H14V12H12ZM16 12V6H18V12H16Z"/></svg>`,
                valve: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 3v18M3 12h18M12 12a4 4 0 1 0 0-0.001 4 4 0 0 0 0 0.001z"/><path d="m16 8-4-4-4 4"/></svg>`,
            };
            const emojiIcons = {
                prev: '‚óÄÔ∏è', restart: 'üîÑ', music_on: 'üéµ', music_off: 'üîá', help: '‚ùì', solution: 'üí°', skip: '‚è≠Ô∏è', finish: 'üèÅ',
            };

            // --- DONN√âES DU JEU ---
            const questions = [ { type: 'qcm', text: "Quel est le r√¥le principal d'un Projeteur VRD ?", answers: [{ text: "Concevoir les b√¢timents", correct: false }, { text: "Am√©nager les espaces ext√©rieurs et r√©seaux", correct: true }, { text: "G√©rer la comptabilit√© du chantier", correct: false }, { text: "Peindre les murs", correct: false }], solution: "Le Projeteur VRD (Voirie et R√©seaux Divers) con√ßoit les routes, les syst√®mes d'assainissement, les r√©seaux d'eau, de gaz, d'√©lectricit√© et de t√©l√©communications.", points: 100, time: 30, }, { type: 'multiple-choice', text: "Identifiez les mat√©riaux adapt√©s pour une couche de fondation de chauss√©e. (Plusieurs r√©ponses possibles)", answers: [{ text: "Terre v√©g√©tale", correct: false, icon: "üå±" }, { text: "Grave non trait√©e (GNT)", correct: true, icon: "ü™®" }, { text: "Sable", correct: false, icon: "üèñÔ∏è" }, { text: "Grave-ciment", correct: true, icon: "üß±" }], solution: "La couche de fondation assure la portance de la chauss√©e. Les graves non trait√©es (GNT) et les graves trait√©es (comme le grave-ciment) sont des mat√©riaux couramment utilis√©s.", points: 150, time: 45, }, { type: 'calculation', text: "Un regard A est √† une altitude de 125.50m. Un regard B, distant de 50m, est √† 124.75m. Quelle est la pente du r√©seau en % ?", solution: "Calcul : ((125.50 - 124.75) / 50) * 100 = 1.5%.", correctAnswer: 1.5, tolerance: 0.01, points: 200, time: 60, }, { type: 'pipe-connect', text: "Connectez le r√©seau d'eaux us√©es du point A au point B.", gridSize: { rows: 5, cols: 7 }, start: { row: 2, col: 0 }, end: { row: 2, col: 6 }, pieces: { straight: 5, corner: 4 }, solution: "Il faut cr√©er un chemin continu de A √† B en utilisant les pi√®ces disponibles.", points: 350, time: 180, pipeColor: '#3b82f6' }, { type: 'chronological-order', text: "Mettez dans l'ordre les √©tapes de la construction d'une voirie simple.", items: ["Terrassement", "Mise en place de la couche de fondation", "Pose des bordures et caniveaux", "Application du rev√™tement (enrob√©)", "Signalisation et finitions"], solution: "L'ordre logique est : Terrassement > Couche de fondation > Bordures/Caniveaux > Rev√™tement > Signalisation.", points: 250, time: 90, }, { type: 'scenario', text: "Sc√©nario : Erreur de conception", scenario: "Vous recevez un plan o√π un r√©seau d'eaux pluviales (EP) est connect√© directement en amont d'une station d'√©puration con√ßue uniquement pour les eaux us√©es (EU). Quelle est l'erreur majeure et que proposez-vous ?", answers: [{ text: "Aucune erreur, c'est une pratique standard.", correct: false }, { text: "L'erreur est le m√©lange des r√©seaux. Il faut cr√©er un exutoire s√©par√© pour les EP.", correct: true }, { text: "Il faut juste une plus grosse canalisation.", correct: false }, { text: "Il faut inverser le sens de la pente.", correct: false }], solution: "Les r√©seaux d'eaux pluviales et d'eaux us√©es doivent √™tre s√©paratifs. Les EP n'ont pas besoin d'√™tre trait√©es en station d'√©puration et risqueraient de la saturer.", points: 300, time: 75, }, { type: 'qcm', text: "De quelle couleur est le grillage avertisseur pour un r√©seau √©lectrique enterr√© ?", answers: [{ text: "Bleu", correct: false }, { text: "Jaune", correct: false }, { text: "Rouge", correct: true }, { text: "Vert", correct: false }], solution: "Le grillage avertisseur rouge signale la pr√©sence d'un c√¢ble ou d'une canalisation √©lectrique.", points: 100, time: 25 }, { type: 'text-input', text: "Quel logiciel de CAO/DAO est le plus utilis√© par les projeteurs VRD ?", correctAnswer: "AutoCAD", solution: "AutoCAD est le standard de l'industrie pour le dessin technique en 2D et 3D.", points: 120, time: 30 }, { type: 'calculation', text: "Une route de 6m de large a une pente en travers de 2.5% depuis l'axe. Quelle est la diff√©rence de niveau (en cm) entre l'axe et le bord ?", correctAnswer: 7.5, tolerance: 0.1, solution: "Calcul : (6m / 2) * 0.025 = 0.075m, soit 7.5 cm.", points: 200, time: 60 }, { type: 'multiple-choice', text: "Quels √©l√©ments font partie des 'r√©seaux secs' ?", answers: [{ text: "Adduction d'Eau Potable", correct: false, icon: "üíß" }, { text: "√âlectricit√© (Basse Tension)", correct: true, icon: "‚ö°" }, { text: "T√©l√©communications (Fibre)", correct: true, icon: "üì°" }, { text: "Assainissement EU", correct: false, icon: "üöΩ" }], solution: "Les r√©seaux secs transportent de l'√©nergie ou de l'information (√©lectricit√©, t√©l√©com), par opposition aux r√©seaux humides (eau, assainissement).", points: 150, time: 40 }, { type: 'chronological-order', text: "Ordonnez les couches d'une structure de chauss√©e, de la plus profonde √† la surface.", items: ["Couche de forme", "Couche de fondation", "Couche de base", "Couche de roulement"], solution: "La structure est b√¢tie depuis le terrain naturel (couche de forme) jusqu'√† la surface (couche de roulement).", points: 250, time: 70 }, { type: 'qcm', text: "Que signifie 'DT-DICT' ?", answers: [{ text: "Document Technique - Dessin Industriel et Commercial", correct: false }, { text: "D√©claration de Travaux - Demande d'Intervention sur la Chauss√©e", correct: false }, { text: "D√©claration de projet de Travaux - D√©claration d'Intention de Commencement de Travaux", correct: true }, { text: "Dossier Technique - Directive Interne de Chantier", correct: false }], solution: "La DT-DICT est une proc√©dure obligatoire pour s'informer sur la pr√©sence de r√©seaux enterr√©s avant de commencer des travaux.", points: 180, time: 45 }, { type: 'calculation', text: "Un bassin de r√©tention a une surface de 200m¬≤. Il pleut 30 litres/m¬≤. Quel volume d'eau (en m¬≥) le bassin doit-il stocker ?", correctAnswer: 6, tolerance: 0.1, solution: "Calcul : 200 m¬≤ * 30 L/m¬≤ = 6000 Litres. Comme 1000L = 1m¬≥, le volume est de 6 m¬≥.", points: 220, time: 75 }, { type: 'text-input', text: "Comment nomme-t-on le plan repr√©sentant les altitudes du terrain le long d'un axe ?", correctAnswer: "Profil en long", solution: "Le profil en long est une coupe verticale qui montre le relief du terrain et le projet le long d'un axe.", points: 150, time: 40 }, { type: 'scenario', text: "Sc√©nario : R√©seau inconnu", scenario: "En creusant une tranch√©e, vous d√©couvrez une canalisation non r√©pertori√©e. Quelle est la premi√®re action √† entreprendre ?", answers: [{ text: "Continuer en faisant attention.", correct: false }, { text: "Arr√™ter les travaux dans la zone et alerter le conducteur de travaux.", correct: true }, { text: "Essayer d'identifier le r√©seau en le per√ßant l√©g√®rement.", correct: false }, { text: "Recouvrir et ne rien dire.", correct: false }], solution: "La s√©curit√© prime. Il faut imm√©diatement arr√™ter les travaux, s√©curiser la zone et informer la hi√©rarchie.", points: 300, time: 60 }, { type: 'pipe-connect', text: "Connectez le r√©seau de gaz. Le chemin doit passer par la vanne de coupure.", gridSize: { rows: 6, cols: 8 }, start: { row: 5, col: 3 }, end: { row: 0, col: 7 }, obstacles: [{row: 2, col: 4, type: 'valve'}], pieces: { straight: 8, corner: 6 }, solution: "Le chemin doit √™tre continu de A √† B et obligatoirement passer par la case 'valve'.", points: 400, time: 200, bonus: true, pipeColor: '#FBBF24' } ];
            const tips = [ "Astuce : La pente minimale pour un r√©seau EU est de 1%.", "Le saviez-vous ? Le logiciel AutoCAD est l'un des outils les plus utilis√©s par les projeteurs VRD.", "Conseil : V√©rifiez toujours les plans de concessionnaires avant de terrasser.", "Astuce : Un 'fil d'eau' (FE) d√©signe le point le plus bas √† l'int√©rieur d'une canalisation.", "Le saviez-vous ? La loi sur l'eau impose souvent de g√©rer les eaux pluviales √† la parcelle.", "Conseil : Utilisez des couleurs et des calques distincts pour chaque r√©seau sur vos plans.", "Astuce : La largeur d'un trottoir accessible PMR doit √™tre d'au moins 1.40m.", "Le saviez-vous ? Le module 'Covadis' est une surcouche √† AutoCAD sp√©cialis√©e pour les projets d'infrastructure.", "Conseil : Pensez au foisonnement des terres lors du calcul des cubatures de d√©blais/remblais." ];
            
            let gameState = {};
            
            // --- GESTION AUDIO ---
            dom.buttons.music.disabled = true;
            dom.buttons.music.style.opacity = 0.5;
            let isSoundOn = false;

            const sounds = {
                start: new Tone.Synth({ oscillator: { type: "fatsawtooth" }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.3 } }).toDestination(),
                correct: new Tone.Synth({ oscillator: { type: "triangle" }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.2 } }).toDestination(),
                incorrect: new Tone.Synth({ oscillator: { type: "square" }, envelope: { attack: 0.01, decay: 0.3, sustain: 0, release: 0.2 } }).toDestination(),
                finish: new Tone.Synth({ oscillator: { type: "sine" }, envelope: { attack: 0.1, decay: 0.5, sustain: 0.3, release: 1 } }).toDestination(),
                click: new Tone.MembraneSynth({ pitchDecay: 0.01, octaves: 2, envelope: { attack: 0.001, decay: 0.2, sustain: 0 } }).toDestination(),
                timer_tick: new Tone.Synth({ oscillator: { type: 'sine' }, volume: -10, envelope: { attack: 0.001, decay: 0.1, sustain: 0, release: 0.1 } }).toDestination(),
                drag: new Tone.NoiseSynth({ noise: { type: 'pink' }, envelope: { attack: 0.005, decay: 0.1, sustain: 0 } }).toDestination(),
                drop: new Tone.MembraneSynth({ pitchDecay: 0.008, octaves: 4, envelope: { attack: 0.001, decay: 0.3, sustain: 0 } }).toDestination(),
                swoosh: new Tone.NoiseSynth({ noise: { type: 'white', playbackRate: 4 }, envelope: { attack: 0.005, decay: 0.2, sustain: 0 } }).toDestination(),
                confetti: new Tone.PluckSynth({ attackNoise: 1, dampening: 4000, resonance: 0.7 }).toDestination()
            };
            const backgroundMusic = new Tone.Player({ 
                url: "https://cdn.jsdelivr.net/gh/Tonejs/Tone.js/examples/audio/loop.mp3", 
                loop: true, 
                volume: -12,
                onload: () => {
                    dom.buttons.music.disabled = false;
                    dom.buttons.music.style.opacity = 1;
                }
            }).toDestination();
            
            function playSound(sound, ...args) {
                if (isSoundOn && sound && typeof sound.triggerAttackRelease === 'function') {
                    sound.triggerAttackRelease(...args);
                }
            }

            // --- FONCTIONS PRINCIPALES DU JEU ---

            function initGame() {
                gameState = { score: 0, currentQuestionIndex: -1, timeLeft: 0, timerInterval: null, totalTime: 0, totalTimeInterval: null, questions: shuffleArray([...questions]), answeredQuestions: [], isQuestionAnswered: false, };
                updateScore(0);
                switchScreen('home');
                dom.buttons.prev.disabled = true;
                Object.values(dom.buttons).forEach(btn => {
                    if (btn.id !== 'musicBtn' || backgroundMusic.loaded) {
                        btn.disabled = false;
                    }
                });
                ['solution', 'skip', 'finish'].forEach(key => dom.buttons[key].style.display = 'none');
                dom.displays.timer.textContent = '--:--';
                dom.displays.timerContainer.classList.remove('warning');
                startTipsMarquee();
            }

            function startGame() {
                playSound(sounds.start, "C4", "8n");
                gameState.answeredQuestions = new Array(gameState.questions.length).fill(null);
                startTotalTimer();
                nextQuestion();
            }

            function nextQuestion() {
                if (gameState.currentQuestionIndex >= gameState.questions.length - 1) { endGame(); return; }
                gameState.currentQuestionIndex++;
                displayQuestion();
                updateNavigationButtons();
            }

            function prevQuestion() {
                if (gameState.currentQuestionIndex > 0) { gameState.currentQuestionIndex--; displayQuestion(true); updateNavigationButtons(); }
            }

            function displayQuestion(isNavigatingBack = false) {
                clearTimeout(gameState.timerInterval);
                dom.displays.feedback.textContent = '';
                dom.buttons.next.style.display = 'none';
                const question = gameState.questions[gameState.currentQuestionIndex];
                gameState.isQuestionAnswered = gameState.answeredQuestions[gameState.currentQuestionIndex] !== null;
                dom.displays.questionText.innerHTML = `Question ${gameState.currentQuestionIndex + 1}/${gameState.questions.length}: ${question.text}`;
                dom.displays.answerContainer.innerHTML = '';
                ['solution', 'skip', 'finish'].forEach(key => dom.buttons[key].style.display = 'block');
                const interfaceBuilder = { 'qcm': createQCMInterface, 'scenario': createQCMInterface, 'multiple-choice': createMultipleChoiceInterface, 'calculation': createCalculationInterface, 'text-input': createTextInputInterface, 'chronological-order': createChronologicalOrderInterface, 'pipe-connect': createPipeConnectInterface, }[question.type];
                if (interfaceBuilder) interfaceBuilder(question);
                if (gameState.isQuestionAnswered) restoreAnswerState(); else startTimer(question.time);
                switchScreen('question');
            }

            function endGame() {
                clearInterval(gameState.timerInterval);
                clearInterval(gameState.totalTimeInterval);
                playSound(sounds.finish, "C5", "1n", Tone.now() + 0.1);
                launchConfetti();
                const correctCount = gameState.answeredQuestions.filter(a => a && a.isCorrect).length;
                const totalQuestions = gameState.questions.length;
                dom.displays.finalScore.textContent = gameState.score;
                dom.displays.correctAnswers.textContent = `${correctCount} / ${totalQuestions}`;
                dom.displays.totalTime.textContent = formatTime(gameState.totalTime);
                let message = "Excellent travail ! Vous √™tes un expert !";
                if (correctCount / totalQuestions < 0.5) message = "Continuez √† vous entra√Æner !";
                else if (correctCount / totalQuestions < 0.8) message = "Bon score, vous progressez !";
                dom.displays.finalMessage.textContent = message;
                switchScreen('final');
                ['solution', 'skip', 'finish'].forEach(key => dom.buttons[key].style.display = 'none');
            }

            function createQCMInterface(question) {
                const answerGrid = document.createElement('div');
                answerGrid.className = 'answer-grid';
                question.answers.forEach((answer, index) => {
                    const btn = document.createElement('button');
                    btn.className = 'answer-btn';
                    btn.innerHTML = answer.text;
                    btn.onclick = () => handleAnswer(index, index);
                    answerGrid.appendChild(btn);
                });
                dom.displays.answerContainer.appendChild(answerGrid);
            }

            function createMultipleChoiceInterface(question) {
                const materialGrid = document.createElement('div');
                materialGrid.className = 'material-grid';
                question.answers.forEach((answer, index) => {
                    const card = document.createElement('div');
                    card.className = 'material-card';
                    card.dataset.index = index;
                    card.innerHTML = `<div class="material-icon">${answer.icon || '‚ùî'}</div><p class="font-semibold text-lg">${answer.text}</p>`;
                    card.onclick = () => { if (!gameState.isQuestionAnswered) card.classList.toggle('selected'); };
                    materialGrid.appendChild(card);
                });
                dom.displays.answerContainer.appendChild(materialGrid);
                addSubmitButton(() => {
                    const selectedCards = dom.displays.answerContainer.querySelectorAll('.material-card.selected');
                    const selectedIndices = Array.from(selectedCards).map(c => parseInt(c.dataset.index));
                    handleAnswer(selectedIndices, selectedIndices);
                });
            }

            function createCalculationInterface(question) {
                const input = document.createElement('input');
                input.type = 'number';
                input.step = 'any';
                input.className = 'elevation-input';
                input.placeholder = 'Votre r√©ponse...';
                dom.displays.answerContainer.appendChild(input);
                addSubmitButton(() => { const value = parseFloat(input.value); if (!isNaN(value)) handleAnswer(value, value); });
            }

            function createTextInputInterface(question) {
                const input = document.createElement('input');
                input.type = 'text';
                input.className = 'text-input';
                input.placeholder = 'Votre r√©ponse...';
                dom.displays.answerContainer.appendChild(input);
                addSubmitButton(() => { const value = input.value.trim(); if (value) handleAnswer(value, value); });
            }

            function createChronologicalOrderInterface(question) {
                const container = document.createElement('div');
                container.className = 'w-full max-w-2xl flex flex-col items-center';
                const dropZone = document.createElement('div');
                dropZone.className = 'drop-zone min-h-[100px] p-4 flex flex-wrap gap-2 justify-center w-full';
                dropZone.textContent = 'D√©posez les √©tapes ici';
                const draggableContainer = document.createElement('div');
                draggableContainer.className = 'mt-6 p-4 flex flex-wrap gap-2 justify-center bg-gray-100 rounded-xl w-full';
                shuffleArray([...question.items]).forEach((item) => {
                    const el = document.createElement('div');
                    el.className = 'draggable';
                    el.textContent = item;
                    el.draggable = true;
                    el.dataset.id = item;
                    el.addEventListener('dragstart', e => { playSound(sounds.drag, "8n"); e.dataTransfer.setData('text/plain', item); setTimeout(() => el.classList.add('opacity-50'), 0); });
                    el.addEventListener('dragend', () => el.classList.remove('opacity-50'));
                    draggableContainer.appendChild(el);
                });
                container.appendChild(dropZone);
                container.appendChild(draggableContainer);
                dom.displays.answerContainer.appendChild(container);
                [dropZone, draggableContainer].forEach(zone => {
                    zone.addEventListener('dragover', e => { e.preventDefault(); zone.classList.add('hover'); });
                    zone.addEventListener('dragleave', () => zone.classList.remove('hover'));
                    zone.addEventListener('drop', e => {
                        e.preventDefault();
                        playSound(sounds.drop, "C3", "8n");
                        zone.classList.remove('hover');
                        if (dropZone.textContent === 'D√©posez les √©tapes ici') { dropZone.textContent = ''; dropZone.classList.add('filled'); }
                        const data = e.dataTransfer.getData('text/plain');
                        const draggable = document.querySelector(`.draggable[data-id="${data}"]`);
                        if (draggable) zone.appendChild(draggable);
                        if (dropZone.children.length === 0) { dropZone.textContent = 'D√©posez les √©tapes ici'; dropZone.classList.remove('filled'); }
                    });
                });
                addSubmitButton(() => { const droppedItems = Array.from(dropZone.children).map(child => child.dataset.id); handleAnswer(droppedItems, droppedItems); });
            }
            
            function createPipeConnectInterface(question) {
                const container = document.createElement('div');
                container.className = 'pipe-game-container';
                const pipeTray = document.createElement('div');
                pipeTray.className = 'pipe-tray';
                const createDraggablePipe = (type, count) => {
                    const piece = document.createElement('div');
                    piece.className = 'pipe-piece-draggable';
                    piece.draggable = true;
                    piece.dataset.pipeType = type;
                    piece.innerHTML = getPipeSVG(type, 0, question.pipeColor) + `<span class="pipe-count" id="pipe-count-${type}">${count}</span>`;
                    piece.addEventListener('dragstart', e => { if (parseInt(document.getElementById(`pipe-count-${type}`).textContent) > 0) { playSound(sounds.drag, "8n"); e.dataTransfer.setData('text/plain', type); piece.classList.add('dragging'); } else { e.preventDefault(); } });
                    piece.addEventListener('dragend', () => piece.classList.remove('dragging'));
                    return piece;
                };
                Object.keys(question.pieces).forEach(type => pipeTray.appendChild(createDraggablePipe(type, question.pieces[type])));
                const gridContainer = document.createElement('div');
                gridContainer.className = 'pipe-grid-container';
                gridContainer.style.setProperty('--grid-cols', question.gridSize.cols);
                gridContainer.id = 'pipe-grid';
                for (let r = 0; r < question.gridSize.rows; r++) {
                    for (let c = 0; c < question.gridSize.cols; c++) {
                        const cell = document.createElement('div');
                        cell.className = 'grid-cell';
                        cell.dataset.row = r;
                        cell.dataset.col = c;
                        if (r === question.start.row && c === question.start.col) cell.classList.add('start-node');
                        else if (r === question.end.row && c === question.end.col) cell.classList.add('end-node');
                        else if (question.obstacles?.some(o => o.row === r && o.col === c)) {
                            cell.classList.add('obstacle-node');
                            cell.innerHTML = `<div class="w-2/3 h-2/3 text-slate-500">${svgIcons.valve}</div>`;
                            cell.dataset.obstacle = true;
                        }
                        cell.addEventListener('dragover', e => e.preventDefault());
                        cell.addEventListener('drop', e => {
                            e.preventDefault();
                            if (cell.innerHTML !== '' || cell.classList.contains('start-node') || cell.classList.contains('end-node')) return;
                            const type = e.dataTransfer.getData('text/plain');
                            const countEl = document.getElementById(`pipe-count-${type}`);
                            let count = parseInt(countEl.textContent);
                            if (count > 0) {
                                playSound(sounds.drop, "C3", "8n");
                                count--;
                                countEl.textContent = count;
                                const placedPiece = document.createElement('div');
                                placedPiece.className = 'pipe-piece-placed';
                                placedPiece.dataset.pipeType = type;
                                placedPiece.dataset.rotation = 0;
                                placedPiece.innerHTML = getPipeSVG(type, 0, question.pipeColor);
                                placedPiece.addEventListener('click', () => {
                                    if (gameState.isQuestionAnswered) return;
                                    let currentRotation = parseInt(placedPiece.dataset.rotation);
                                    currentRotation = (currentRotation + 90) % 360;
                                    placedPiece.dataset.rotation = currentRotation;
                                    placedPiece.style.transform = `rotate(${currentRotation}deg)`;
                                });
                                placedPiece.addEventListener('contextmenu', (ev) => {
                                    ev.preventDefault();
                                    if (gameState.isQuestionAnswered) return;
                                    cell.innerHTML = '';
                                    const typeToRemove = placedPiece.dataset.pipeType;
                                    const countElToRemove = document.getElementById(`pipe-count-${typeToRemove}`);
                                    countElToRemove.textContent = parseInt(countElToRemove.textContent) + 1;
                                });
                                cell.appendChild(placedPiece);
                            }
                        });
                        gridContainer.appendChild(cell);
                    }
                }
                container.appendChild(pipeTray);
                container.appendChild(gridContainer);
                dom.displays.answerContainer.appendChild(container);
                addSubmitButton(() => {
                    const placedPipes = [];
                    gridContainer.querySelectorAll('.pipe-piece-placed').forEach(p => {
                        const cell = p.parentElement;
                        placedPipes.push({ row: parseInt(cell.dataset.row), col: parseInt(cell.dataset.col), type: p.dataset.pipeType, rotation: parseInt(p.dataset.rotation) });
                    });
                    handleAnswer(placedPipes, placedPipes);
                }, 'V√©rifier');
            }

            function addSubmitButton(callback, text = 'Valider') {
                const submitBtn = document.createElement('button');
                submitBtn.textContent = text;
                submitBtn.className = 'btn mt-8';
                submitBtn.onclick = callback;
                const buttonContainer = document.createElement('div');
                buttonContainer.className = 'button-center-align';
                buttonContainer.appendChild(submitBtn);
                dom.displays.answerContainer.appendChild(buttonContainer);
            }

            function handleAnswer(userAnswer, answerForStorage) {
                if (gameState.isQuestionAnswered) return;
                clearInterval(gameState.timerInterval);
                gameState.isQuestionAnswered = true;
                const question = gameState.questions[gameState.currentQuestionIndex];
                let isCorrect = false;
                switch (question.type) {
                    case 'qcm': case 'scenario': isCorrect = userAnswer !== null && question.answers[userAnswer].correct; break;
                    case 'multiple-choice':
                        const correctIndices = question.answers.map((a, i) => a.correct ? i : -1).filter(i => i !== -1);
                        isCorrect = userAnswer && userAnswer.length === correctIndices.length && userAnswer.every(index => correctIndices.includes(index));
                        break;
                    case 'calculation': isCorrect = userAnswer !== null && Math.abs(userAnswer - question.correctAnswer) <= (question.tolerance || 0.01); break;
                    case 'text-input': isCorrect = userAnswer && userAnswer.toLowerCase().trim() === question.correctAnswer.toLowerCase().trim(); break;
                    case 'chronological-order': isCorrect = userAnswer && userAnswer.length === question.items.length && userAnswer.every((item, index) => item === question.items[index]); break;
                    case 'pipe-connect': isCorrect = checkPipeConnection(userAnswer, question); break;
                }
                gameState.answeredQuestions[gameState.currentQuestionIndex] = { answer: answerForStorage, isCorrect: isCorrect };
                if (isCorrect) {
                    playSound(sounds.correct, "C5", "8n", Tone.now() + 0.1);
                    dom.displays.feedback.textContent = "Bonne r√©ponse !";
                    dom.displays.feedback.className = 'mt-4 text-xl text-green-500 font-bold text-center';
                    let pointsGained = question.points;
                    if (question.bonus) pointsGained *= 2;
                    updateScore(gameState.score + pointsGained);
                } else {
                    playSound(sounds.incorrect, "C3", "8n", Tone.now() + 0.1);
                    dom.displays.feedback.textContent = "R√©ponse incorrecte.";
                    dom.displays.feedback.className = 'mt-4 text-xl text-red-500 font-bold text-center';
                }
                showSolution(isCorrect);
                dom.buttons.next.style.display = 'inline-block';
                dom.buttons.solution.disabled = true;
                dom.buttons.skip.disabled = true;
            }

            function showSolution(isCorrect) {
                const question = gameState.questions[gameState.currentQuestionIndex];
                if (!isCorrect) dom.displays.feedback.innerHTML += `<br><div class="mt-2 text-lg font-normal text-slate-600"><strong>Solution :</strong> ${question.solution}</div>`;
                const answerElements = dom.displays.answerContainer.querySelectorAll('.answer-btn, .material-card, .draggable, .pipe-piece-placed, input, button');
                answerElements.forEach(el => { el.style.pointerEvents = 'none'; el.disabled = true; if(el.classList.contains('material-card')) el.classList.add('disabled'); });
                switch (question.type) {
                    case 'qcm': case 'scenario': dom.displays.answerContainer.querySelectorAll('.answer-btn').forEach((btn, index) => { if (question.answers[index].correct) btn.classList.add('correct'); }); break;
                    case 'multiple-choice':
                        dom.displays.answerContainer.querySelectorAll('.material-card').forEach((card, index) => {
                            const isSelected = card.classList.contains('selected');
                            const isCorrectAnswer = question.answers[index].correct;
                            if (isCorrectAnswer) card.classList.add('correct');
                            else if (isSelected && !isCorrectAnswer) card.classList.add('incorrect');
                        });
                        break;
                }
            }

            function restoreAnswerState() {
                const { answer, isCorrect } = gameState.answeredQuestions[gameState.currentQuestionIndex];
                const question = gameState.questions[gameState.currentQuestionIndex];
                if(answer === null) { showSolution(isCorrect); return; }
                switch (question.type) {
                    case 'qcm': case 'scenario': dom.displays.answerContainer.querySelectorAll('.answer-btn')[answer].classList.add(isCorrect ? 'correct' : 'incorrect'); break;
                    case 'multiple-choice': answer.forEach(index => { dom.displays.answerContainer.querySelector(`[data-index="${index}"]`).classList.add('selected'); }); break;
                    case 'calculation': case 'text-input': dom.displays.answerContainer.querySelector('input').value = answer; break;
                    case 'chronological-order':
                        const dropZone = dom.displays.answerContainer.querySelector('.drop-zone');
                        const draggableContainer = dom.displays.answerContainer.querySelector('.mt-6');
                        if (answer.length > 0) { dropZone.textContent = ''; dropZone.classList.add('filled'); }
                        answer.forEach(itemText => { const el = draggableContainer.querySelector(`[data-id="${itemText}"]`) || dropZone.querySelector(`[data-id="${itemText}"]`); if (el) dropZone.appendChild(el); });
                        break;
                    case 'pipe-connect':
                        const grid = document.getElementById('pipe-grid');
                        let initialPieces = {...question.pieces};
                        answer.forEach(p => {
                            const cell = grid.querySelector(`[data-row="${p.row}"][data-col="${p.col}"]`);
                            const placedPiece = document.createElement('div');
                            placedPiece.className = 'pipe-piece-placed';
                            placedPiece.dataset.pipeType = p.type;
                            placedPiece.dataset.rotation = p.rotation;
                            placedPiece.style.transform = `rotate(${p.rotation}deg)`;
                            placedPiece.innerHTML = getPipeSVG(p.type, 0, question.pipeColor);
                            cell.appendChild(placedPiece);
                            initialPieces[p.type]--;
                        });
                        Object.keys(initialPieces).forEach(type => { document.getElementById(`pipe-count-${type}`).textContent = initialPieces[type]; });
                        break;
                }
                showSolution(isCorrect);
                dom.buttons.next.style.display = 'inline-block';
            }
            
            function getPipeSVG(type, rotation, color) {
                let path = '';
                if (type === 'straight') path = `<path d="M0 50 L100 50" stroke="${color}" stroke-width="12" stroke-linecap="round" />`;
                else if (type === 'corner') path = `<path d="M0 50 L50 50 L50 100" stroke="${color}" stroke-width="12" stroke-linecap="round" fill="none" />`;
                return `<svg class="w-full h-full" viewBox="0 0 100 100" style="transform: rotate(${rotation}deg);">${path}</svg>`;
            }

            function getPipeExits(pipe) {
                if (!pipe) return [];
                const { type, rotation } = pipe;
                const r = (parseInt(rotation, 10) + 360) % 360;
                if (type === 'straight') return (r === 90 || r === 270) ? ['up', 'down'] : ['left', 'right'];
                if (type === 'corner') { if (r === 0) return ['left', 'down']; if (r === 90) return ['down', 'right']; if (r === 180) return ['right', 'up']; if (r === 270) return ['up', 'left']; }
                return [];
            }
            
            function checkPipeConnection(placedPipes, question) {
                if (!Array.isArray(placedPipes)) return false;
                const { gridSize, start, end, obstacles } = question;
                const grid = Array(gridSize.rows).fill(null).map(() => Array(gridSize.cols).fill(null));
                placedPipes.forEach(p => { grid[p.row][p.col] = p; });
                let queue = [];
                let visited = new Set();
                const directions = { up: { r: -1, c: 0, opp: 'down' }, down: { r: 1, c: 0, opp: 'up' }, left: { r: 0, c: -1, opp: 'right' }, right: { r: 0, c: 1, opp: 'left' } };
                for (const dirName in directions) {
                    const { r, c, opp } = directions[dirName];
                    const nextR = start.row + r;
                    const nextC = start.col + c;
                    const key = `${nextR},${nextC}`;
                    if (nextR >= 0 && nextR < gridSize.rows && nextC >= 0 && nextC < gridSize.cols) {
                        const nextPipe = grid[nextR]?.[nextC];
                        if (nextPipe && getPipeExits(nextPipe).includes(opp)) { visited.add(key); queue.push({ row: nextR, col: nextC, path: [`${start.row},${start.col}`, key] }); }
                    }
                }
                while (queue.length > 0) {
                    const current = queue.shift();
                    const currentPipe = grid[current.row][current.col];
                    const currentExits = getPipeExits(currentPipe);
                    for (const dirName in directions) {
                         const { r, c } = directions[dirName];
                         if (currentExits.includes(dirName)) {
                             const neighborR = current.row + r;
                             const neighborC = current.col + c;
                             if (neighborR === end.row && neighborC === end.col) {
                                 const finalPath = [...current.path, `${end.row},${end.col}`];
                                 const pathSet = new Set(finalPath);
                                 const allObstaclesOnPath = obstacles?.every(o => pathSet.has(`${o.row},${o.col}`)) ?? true;
                                 if (allObstaclesOnPath) return true;
                             }
                         }
                    }
                    for (const dirName in directions) {
                        const { r, c, opp } = directions[dirName];
                        if (currentExits.includes(dirName)) {
                            const nextR = current.row + r;
                            const nextC = current.col + c;
                            const key = `${nextR},${nextC}`;
                            if (nextR >= 0 && nextR < gridSize.rows && nextC >= 0 && nextC < gridSize.cols && !visited.has(key)) {
                                const nextPipe = grid[nextR]?.[nextC];
                                if (nextPipe && getPipeExits(nextPipe).includes(opp)) { visited.add(key); queue.push({ row: nextR, col: nextC, path: [...current.path, key] }); }
                            }
                        }
                    }
                }
                return false;
            }

            function switchScreen(screenName) { Object.values(dom.screens).forEach(s => s.classList.remove('active')); dom.screens[screenName].classList.add('active'); }
            function updateScore(newScore) { gameState.score = newScore; dom.displays.score.textContent = newScore; }
            function startTimer(duration) {
                gameState.timeLeft = duration;
                dom.displays.timerContainer.classList.remove('warning');
                function update() {
                    dom.displays.timer.textContent = formatTime(gameState.timeLeft);
                    if (gameState.timeLeft <= 10 && gameState.timeLeft > 0) {
                        dom.displays.timerContainer.classList.add('warning');
                        playSound(sounds.timer_tick, 'C6', '16n');
                    }
                    if (gameState.timeLeft <= 0) { clearInterval(gameState.timerInterval); handleAnswer(null, 'timeout'); }
                    gameState.timeLeft--;
                }
                update();
                gameState.timerInterval = setInterval(update, 1000);
            }
            function startTotalTimer() { gameState.totalTime = 0; if(gameState.totalTimeInterval) clearInterval(gameState.totalTimeInterval); gameState.totalTimeInterval = setInterval(() => { gameState.totalTime++; }, 1000); }
            function formatTime(seconds) { const mins = Math.floor(seconds / 60); const secs = seconds % 60; return `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`; }
            function shuffleArray(array) { for (let i = array.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [array[i], array[j]] = [array[j], array[i]]; } return array; }
            function updateNavigationButtons() { dom.buttons.prev.disabled = gameState.currentQuestionIndex <= 0; }
            function startTipsMarquee() { if (dom.displays.tipsBarContent) { const shuffledTips = shuffleArray([...tips]); dom.displays.tipsBarContent.innerHTML = shuffledTips.join(' &nbsp;&nbsp;&nbsp; // &nbsp;&nbsp;&nbsp; '); } }
            function launchConfetti() {
                playSound(sounds.confetti, "C4", "8n", Tone.now());
                playSound(sounds.confetti, "G4", "8n", Tone.now() + 0.1);
                playSound(sounds.confetti, "E5", "8n", Tone.now() + 0.2);
                for (let i = 0; i < 100; i++) { const c = document.createElement('div'); c.className = 'confetti'; c.style.left = `${Math.random()*100}vw`; c.style.animationDelay = `${Math.random()*2}s`; c.style.backgroundColor=`hsl(${Math.random()*360},100%,50%)`; c.style.transform=`scale(${Math.random()*.5+.5})`; document.body.appendChild(c); setTimeout(()=>c.remove(),3000);}
            }
            function setViewMode(mode) {
                dom.gameContainer.style.transition = 'width 0.5s ease, height 0.5s ease';
                if (mode === 'mobile') { dom.gameContainer.style.width = '420px'; dom.gameContainer.style.height = '85vh'; } 
                else if (mode === 'desktop') { dom.gameContainer.style.width = '1400px'; dom.gameContainer.style.height = '95vh'; } 
                else { dom.gameContainer.style.width = '100%'; dom.gameContainer.style.height = '95vh'; }
                dom.viewModeButtons.forEach(btn => btn.classList.toggle('active', btn.dataset.mode === mode));
            }

            dom.logoIconContainer.innerHTML = svgIcons.crane;
            dom.homeLogoIconContainer.innerHTML = svgIcons.crane;
            dom.buttons.prev.innerHTML = emojiIcons.prev;
            dom.buttons.restart.innerHTML = emojiIcons.restart;
            dom.buttons.help.innerHTML = emojiIcons.help;
            dom.buttons.solution.innerHTML = emojiIcons.solution;
            dom.buttons.skip.innerHTML = emojiIcons.skip;
            dom.buttons.finish.innerHTML = emojiIcons.finish;
            dom.buttons.music.innerHTML = emojiIcons.music_off;

            dom.buttons.start.addEventListener('click', () => { startGame(); playSound(sounds.click, "C2", "8n"); });
            dom.buttons.next.addEventListener('click', () => { nextQuestion(); playSound(sounds.click, "C2", "8n"); });
            dom.buttons.prev.addEventListener('click', () => { prevQuestion(); playSound(sounds.click, "C2", "8n"); });
            [dom.buttons.restart, dom.buttons.restartFinal].forEach(btn => btn.addEventListener('click', () => { initGame(); playSound(sounds.click, "C2", "8n"); }));

            dom.buttons.music.addEventListener('click', () => {
                if (dom.buttons.music.disabled) return;
                isSoundOn = !isSoundOn;
                
                Tone.start().then(() => {
                    if (isSoundOn) {
                        Tone.Destination.mute = false;
                        if (backgroundMusic.loaded) {
                            backgroundMusic.start();
                        }
                        dom.buttons.music.innerHTML = emojiIcons.music_on;
                    } else {
                        Tone.Destination.mute = true;
                        backgroundMusic.stop();
                        dom.buttons.music.innerHTML = emojiIcons.music_off;
                    }
                });
            });
            dom.buttons.help.addEventListener('click', () => { playSound(sounds.swoosh, 0.2); dom.modals.help.classList.add('active'); });
            dom.buttons.solution.addEventListener('click', () => { if (gameState.isQuestionAnswered) return; const question = gameState.questions[gameState.currentQuestionIndex]; updateScore(gameState.score - Math.floor(question.points / 2)); handleAnswer(null, 'solution'); });
            dom.buttons.skip.addEventListener('click', () => { if (!gameState.isQuestionAnswered) handleAnswer(null, 'skipped'); });
            dom.buttons.finish.addEventListener('click', () => endGame());

            document.querySelectorAll('.modal-close').forEach(btn => btn.addEventListener('click', () => { playSound(sounds.swoosh, 0.2); btn.closest('.modal').classList.remove('active'); }));
            document.querySelectorAll('.modal').forEach(modal => modal.addEventListener('click', (e) => { if (e.target === modal) { playSound(sounds.swoosh, 0.2); modal.classList.remove('active'); } }));
            dom.viewModeButtons.forEach(button => button.addEventListener('click', () => setViewMode(button.dataset.mode)));

            initGame();
        });
    </script>
</body>
</html>
