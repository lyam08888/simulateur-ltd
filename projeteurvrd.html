<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LTD Simulateur - Projeteur VRD</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;800&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Poppins', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 10px;
            /* Default font size, will be updated by JS */
            font-size: 14px; /* Adjusted base font size */
        }
        
        .game-container {
            width: 100%;
            max-width: 1400px; /* Main container width */
            height: 95vh;
            background: rgba(255, 255, 255, 0.98);
            border-radius: 30px;
            box-shadow: 0 25px 80px rgba(0, 0, 0, 0.3);
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        .game-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 25px 50px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 5px 25px rgba(0, 0, 0, 0.15);
            position: absolute; /* Fixed position to stay at top */
            top: 0;
            left: 0;
            width: 100%;
            z-index: 10; /* Ensure it's above other content */
            height: 90px; /* Explicit height to help with screen padding */
        }
        
        .logo {
            display: flex;
            align-items: center;
            gap: 15px;
            font-size: 2rem; /* Adjusted from 28px */
            font-weight: 800;
        }
        
        .logo-icon {
            width: 50px;
            height: 50px;
            background: white;
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.2rem; /* Adjusted from 30px */
        }
        
        .header-stats {
            display: flex;
            gap: 30px;
            align-items: center; /* Align items vertically in the center */
        }
        
        .header-item {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 1.7rem; /* Adjusted from 24px */
            font-weight: 600;
            background: rgba(255, 255, 255, 0.2);
            padding: 10px 20px;
            border-radius: 50px;
            backdrop-filter: blur(10px);
        }
        
        .score-icon::before {
            content: "⭐";
            font-size: 2rem; /* Adjusted from 28px */
        }
        
        .timer-icon::before {
            content: "⏰";
            font-size: 2rem; /* Adjusted from 28px */
        }
        
        .timer-display.warning {
            animation: pulse 1s infinite;
            background: rgba(244, 67, 54, 0.3);
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        .screen {
            display: none;
            flex: 1;
            /* Adjusted padding to account for header (90px), controls (~100px from right), and bottom bars */
            padding: 100px 120px 80px 50px; /* top, right, bottom, left */
            overflow-y: auto;
            animation: fadeIn 0.5s ease-out;
            /* Removed redundant margins as padding now handles spacing */
            /* margin-top: 80px; */
            /* margin-right: 100px; */
            /* margin-bottom: 60px; */
        }
        
        .screen.active {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        /* Bonus round specific styling */
        .screen.bonus-active {
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%); /* Gold/Orange gradient */
            box-shadow: 0 25px 80px rgba(255, 165, 0, 0.5); /* Orange shadow */
            color: #333; /* Darker text for contrast */
        }
        .screen.bonus-active h2 {
            color: #333; /* Ensure heading is readable */
        }
        .screen.bonus-active .answer-btn {
            background: #fefce8; /* Light yellow background for buttons */
            border-color: #fbbf24; /* Yellow border */
            color: #333;
        }
        .screen.bonus-active .answer-btn:hover {
            border-color: #f59e0b; /* Darker yellow on hover */
            background: #fde68a;
        }
        .screen.bonus-active .material-card {
            background: #fefce8;
            border-color: #fbbf24;
            color: #333;
        }
        .screen.bonus-active .material-card:hover {
            border-color: #f59e0b;
            background: #fde68a;
        }
        .screen.bonus-active .elevation-input {
            border-color: #fbbf24;
        }
        .screen.bonus-active .elevation-input:focus {
            box-shadow: 0 0 0 3px rgba(251, 191, 36, 0.4);
        }
        .screen.bonus-active .btn {
            background: linear-gradient(135deg, #f59e0b 0%, #ef4444 100%); /* Orange to red gradient for bonus buttons */
            box-shadow: 0 5px 25px rgba(245, 158, 11, 0.4);
        }
        .screen.bonus-active .btn:hover {
            box-shadow: 0 8px 35px rgba(245, 158, 11, 0.6);
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        h1 {
            font-size: 3.5rem; /* Adjusted from 5rem */
            font-weight: 800;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 30px;
            text-align: center;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }
        
        h2 {
            font-size: 2.5rem; /* Adjusted from 3.8rem */
            font-weight: 600;
            color: #333;
            margin-bottom: 40px;
            text-align: center;
            line-height: 1.3;
        }

        p {
            font-size: 1.1rem; /* Adjusted from 1.4rem */
        }
        
        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 18px 50px;
            border-radius: 50px;
            font-size: 1.4rem; /* Adjusted from 20px */
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 25px rgba(102, 126, 234, 0.4);
            position: relative;
            overflow: hidden;
        }
        
        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.2);
            transition: left 0.5s ease;
        }
        
        .btn:hover::before {
            left: 100%;
        }
        
        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 35px rgba(102, 126, 234, 0.6);
        }
        
        .btn:active {
            transform: translateY(-1px);
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .btn-secondary {
            background: #e0e0e0;
            color: #333;
            box-shadow: 0 5px 25px rgba(0, 0, 0, 0.1);
        }
        
        .progress-bar-chronological { /* New class for chronological progress bar */
            width: calc(100% - 100px); /* Adjust width to fit within header padding */
            height: 15px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            margin: 0 50px; /* Match header padding */
            overflow: hidden;
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.1);
            position: absolute;
            bottom: 45px; /* Position above the tips bar */
            left: 0;
            right: 0;
            z-index: 10; /* Ensure it's above other content */
            height: 30px; /* Explicit height to help with screen padding */
        }
        
        .progress-fill-chronological {
            height: 100%;
            background: white; /* White fill for contrast */
            border-radius: 10px;
            transition: width 0.5s ease;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding-right: 5px;
            font-size: 0.8rem; /* Adjusted from 12px */
            color: #667eea;
            font-weight: 600;
        }
        
        .answer-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); /* Adjusted minmax for smaller font */
            gap: 25px;
            width: 100%;
            max-width: 1000px;
            margin-top: 40px;
        }
        
        .answer-btn {
            background: white;
            border: 3px solid #e0e0e0;
            padding: 25px;
            border-radius: 20px;
            font-size: 1.2rem; /* Adjusted from 20px */
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            position: relative;
            overflow: hidden;
        }
        
        .answer-btn:hover {
            border-color: #667eea;
            transform: translateY(-5px);
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.15);
        }
        
        .answer-btn.correct {
            background: #4caf50;
            color: white;
            border-color: #4caf50;
            animation: bounce 0.5s ease;
        }
        
        .answer-btn.incorrect {
            background: #f44336;
            color: white;
            border-color: #f44336;
            animation: shake 0.5s ease;
        }
        
        @keyframes bounce {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-10px); }
            75% { transform: translateX(10px); }
        }
        
        .game-area {
            width: 100%;
            max-width: 1000px;
            height: 500px;
            background: #f8f9fa;
            border-radius: 25px;
            border: 3px solid #e0e0e0;
            position: relative;
            overflow: hidden;
            margin: 30px 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .controls {
            position: fixed;
            right: 30px; /* Position on the right */
            top: 50%; /* Center vertically */
            transform: translateY(-50%); /* Adjust for vertical centering */
            display: flex;
            flex-direction: column; /* Arrange buttons vertically */
            gap: 20px; /* Spacing between control buttons */
            background: rgba(255, 255, 255, 0.98);
            padding: 20px;
            border-radius: 60px; /* Adjust border-radius for vertical layout */
            box-shadow: 0 15px 50px rgba(0, 0, 0, 0.25);
            z-index: 10; /* Ensure it's above other content */
        }
        
        .control-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: none;
            background: white;
            color: #667eea;
            font-size: 1.7rem; /* Adjusted from 24px */
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 3px 15px rgba(0, 0, 0, 0.1);
            position: relative;
        }
        
        .control-btn:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.2);
            background: #667eea;
            color: white;
        }
        
        .control-btn:active {
            transform: translateY(-1px);
        }
        
        .control-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        
        .control-btn:disabled:hover {
            transform: none;
            background: white;
            color: #667eea;
        }
        
        /* Tooltip pour les boutons */
        .control-btn::after {
            content: attr(data-tooltip);
            position: absolute;
            left: -10px; /* Adjust for vertical positioning */
            transform: translateX(-100%); /* Move tooltip to the left of the button */
            top: 50%;
            transform: translateY(-50%);
            background: #333;
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 1rem; /* Adjusted from 14px */
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }
        
        .control-btn:hover::after {
            opacity: 1;
        }
        
        /* Icons pour les boutons */
        .icon-previous::before { content: "⏮️"; }
        .icon-restart::before { content: "🔄"; }
        .icon-music::before { content: "🎵"; }
        .icon-music.muted::before { content: "🔇"; }
        .icon-help::before { content: "❓"; }
        .icon-solution::before { content: "💡"; }
        .icon-skip::before { content: "⏭️"; }
        .icon-finish::before { content: "🏁"; } /* New icon for finish button */
        
        /* Modals */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(5px);
        }
        
        .modal.active {
            display: flex;
        }
        
        .modal-content {
            background: white;
            padding: 50px;
            border-radius: 25px;
            max-width: 700px;
            width: 90%;
            max-height: 85vh;
            overflow-y: auto;
            position: relative;
            animation: modalIn 0.3s ease;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }
        
        @keyframes modalIn {
            from { transform: scale(0.8); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }
        
        .modal-close {
            position: absolute;
            top: 25px;
            right: 25px;
            width: 45px;
            height: 45px;
            border: none;
            background: #f0f0f0;
            border-radius: 50%;
            font-size: 2rem; /* Adjusted from 28px */
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .modal-close:hover {
            background: #e0e0e0;
            transform: rotate(90deg);
        }
        
        /* Spécifique aux mini-jeux */
        .draggable {
            padding: 15px 25px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 15px;
            cursor: grab;
            user-select: none;
            margin: 8px;
            transition: all 0.3s ease;
            font-size: 1.1rem; /* Adjusted from 18px */
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.3);
        }
        
        .draggable:active {
            cursor: grabbing;
            opacity: 0.7;
            transform: scale(0.95);
        }
        
        .drop-zone {
            min-height: 70px;
            border: 3px dashed #ccc;
            border-radius: 15px;
            margin: 12px 0;
            padding: 15px;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.1rem; /* Adjusted from 18px */
            background: white;
        }
        
        .drop-zone.hover {
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.1);
            transform: scale(1.02);
        }
        
        .drop-zone.filled {
            border-style: solid;
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.05);
        }
        
        .material-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); /* Adjusted minmax for smaller font */
            gap: 25px;
            max-width: 1000px;
            margin-top: 40px;
        }
        
        .material-card {
            background: white;
            border: 3px solid #e0e0e0;
            border-radius: 20px;
            padding: 30px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }
        
        .material-icon {
            font-size: 4rem; /* Adjusted from 60px */
            line-height: 1;
        }
        
        .material-card:hover {
            border-color: #667eea;
            transform: translateY(-8px);
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.15);
        }
        
        .material-card.selected {
            border-color: #764ba2;
            background: rgba(118, 75, 162, 0.1);
            transform: scale(1.05);
        }
        
        .material-card.correct {
            background: #4caf50;
            color: white;
            border-color: #4caf50;
        }
        
        .material-card.incorrect {
            background: #f44336;
            color: white;
            border-color: #f44336;
        }
        
        .elevation-input {
            font-size: 1.8rem; /* Adjusted from 28px */
            padding: 20px 40px;
            border: 3px solid #e0e0e0;
            border-radius: 20px;
            text-align: center;
            width: 300px;
            transition: all 0.3s ease;
            margin: 20px 0;
        }
        
        .elevation-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2);
        }
        
        /* Network game */
        .network-svg {
            width: 100%;
            height: 100%;
        }
        
        .network-node {
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .network-node:hover {
            r: 25;
        }
        
        .network-line {
            stroke-width: 4;
            fill: none;
            stroke-dasharray: 10, 5;
            animation: dash 20s linear infinite;
        }
        
        @keyframes dash {
            to { stroke-dashoffset: -100; }
        }
        
        /* Confetti */
        .confetti {
            position: absolute;
            width: 12px;
            height: 12px;
            background: #667eea;
            animation: fall 3s linear forwards;
        }
        
        @keyframes fall {
            to {
                transform: translateY(100vh) rotate(360deg);
                opacity: 0;
            }
        }
        
        /* Scenario alert */
        .scenario-alert {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%);
            color: white;
            padding: 40px;
            border-radius: 25px;
            margin: 30px 0;
            text-align: center;
            animation: alertPulse 2s ease-in-out infinite;
            box-shadow: 0 10px 40px rgba(238, 90, 36, 0.4);
        }
        
        @keyframes alertPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }
        
        .scenario-icon {
            font-size: 4rem; /* Adjusted from 60px */
            margin-bottom: 20px;
        }
        
        /* Final screen stats */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 25px;
            margin: 40px 0;
            max-width: 800px;
        }
        
        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.3);
        }
        
        .stat-number {
            font-size: 3.2rem; /* Adjusted from 48px */
            font-weight: 800;
            margin: 10px 0;
        }
        
        .stat-label {
            font-size: 1.1rem; /* Adjusted from 18px */
            opacity: 0.9;
        }
        /* Added for right alignment of buttons */
        .button-center-align { /* Changed class name to reflect centering */
            width: 100%;
            max-width: 600px; /* Match the max-width of drop-zones/input for consistency */
            display: flex;
            justify-content: center; /* Centered now */
            margin-top: 30px; /* Add some top top margin */
        }

        /* New styles for the tips bar */
        .tips-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background: linear-gradient(90deg, #764ba2 0%, #667eea 100%);
            color: white;
            padding: 8px 0;
            font-size: 1rem; /* Adjusted from 16px */
            overflow: hidden;
            white-space: nowrap;
            box-shadow: 0 -5px 15px rgba(0, 0, 0, 0.2);
            z-index: 10; /* Ensure it's above other content */
            height: 30px; /* Explicit height to help with screen padding */
        }

        .tips-bar-content {
            display: inline-block;
            padding-left: 100%; /* Start off-screen to the right */
            animation: marquee 20s linear infinite; /* Adjust duration as needed */
        }

        @keyframes marquee {
            0% { transform: translateX(0%); }
            100% { transform: translateX(-100%); }
        }

        /* Home Screen Specific Styles */
        #homeScreen {
            background: white; /* Changed to white */
            color: #333; /* Default text color for home screen */
            text-shadow: none; /* Removed text shadow for better readability on white */
            justify-content: center;
            align-items: center;
            padding: 50px;
            margin-top: 0;
            margin-right: 0;
            margin-bottom: 0;
            position: relative;
            overflow: hidden;
        }

        #homeScreen::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='none' fill-rule='evenodd'%3E%3Cg fill='%239C92AC' fill-opacity='0.05'%3E%3Cpath d='M36 34v-4h-2v4h-4v2h4v4h2v-4h4v-2h-4zm0-30V0h-2v4h-4v2h4v4h2V6h4V4h-4zm0 36v-4h-2v4h-4v2h4v4h2v-4h4v-2h-4zm0 36v-4h-2v4h-4v2h4v4h2v-4h4v-2h-4zM12 34v-4H10v4H6v2h4v4h2v-4h4v-2h-4zm0-30V0h-2v4H6v2h4v4h2V6h4V4h-4zm0 36v-4H10v4H6v2h4v4h2v-4h4v-2h-4zm0 36v-4H10v4H6v2h4v4h2v-4h4v-2h-4z'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E");
            opacity: 0.8; /* More visible on white */
            z-index: 0;
            animation: backgroundPan 90s linear infinite;
        }

        @keyframes backgroundPan {
            0% { background-position: 0% 0%; }
            100% { background-position: 100% 100%; }
        }

        #homeScreen h1 {
            font-size: 5.5rem;
            background: linear-gradient(135deg, #1a202c 0%, #2d3748 100%); /* Dark gradient for text */
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: none; /* Removed text shadow */
            margin-bottom: 20px;
            letter-spacing: 3px;
            position: relative;
            z-index: 1;
        }

        #homeScreen p {
            font-size: 1.8rem;
            color: #333; /* Dark text */
            margin-bottom: 35px;
            text-shadow: none; /* Removed text shadow */
            line-height: 1.3;
            position: relative;
            z-index: 1;
        }

        #homeScreen .logo-icon {
            width: 180px;
            height: 180px;
            font-size: 8rem;
            border-radius: 50%;
            background: white; /* Keep white background */
            box-shadow: 0 10px 30px rgba(0,0,0,0.2), inset 0 0 15px rgba(0,0,0,0.1); /* Adjusted shadow for white background */
            margin-bottom: 40px;
            position: relative;
            z-index: 1;
            transition: all 0.4s ease-out;
        }
        #homeScreen .logo-icon:hover {
            transform: scale(1.1) rotate(8deg);
            box-shadow: 0 15px 40px rgba(0,0,0,0.3), inset 0 0 20px rgba(0,0,0,0.15);
        }

        #homeScreen .btn {
            padding: 22px 70px;
            font-size: 2rem;
            background: linear-gradient(135deg, #4299e1 0%, #3182ce 100%); /* Blue gradient */
            box-shadow: 0 12px 45px rgba(66, 153, 225, 0.6); /* Blue shadow */
            border: 3px solid rgba(255,255,255,0.4);
            position: relative;
            z-index: 1;
            overflow: hidden;
        }
        #homeScreen .btn:hover {
            transform: translateY(-7px);
            box-shadow: 0 18px 60px rgba(66, 153, 225, 0.8);
        }
        #homeScreen .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.3);
            transition: left 0.6s ease-out;
        }
        #homeScreen .btn:hover::before {
            left: 100%;
        }

        .home-features {
            font-size: 1.2rem;
            color: #444; /* Darker text for features */
            margin-bottom: 50px;
            text-align: center;
            line-height: 1.8;
            text-shadow: none; /* Removed text shadow */
            position: relative;
            z-index: 1;
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-width: 500px;
            padding: 15px 0;
        }
        .home-features p {
            margin: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            font-size: 1.2rem;
            color: #444; /* Ensure feature text is dark */
        }

        /* Character and Speech Bubble */
        #gameCharacter {
            position: fixed;
            bottom: 80px; /* Above the tips bar and progress bar */
            left: 30px;
            font-size: 5rem; /* Adjust size, e.g., 80px */
            z-index: 50; /* Above game content, below modals */
            transition: transform 0.3s ease-out;
        }

        #speechBubble {
            position: fixed;
            bottom: 140px; /* Above the character */
            left: 100px; /* To the right of the character */
            background: white;
            padding: 15px 25px;
            border-radius: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            max-width: 250px; /* Limit width */
            text-align: center;
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.3s ease-out, transform 0.3s ease-out;
            z-index: 50;
        }

        #speechBubble.active {
            opacity: 1;
            transform: translateY(0);
        }

        /* Pipe Connect Game Specific Styles */
        .pipe-game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            width: 100%;
            max-width: 800px;
        }

        .pipe-tray {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
            background: #f0f0f0;
            padding: 20px;
            border-radius: 15px;
            border: 2px solid #ddd;
            width: 100%;
        }

        .pipe-piece-draggable {
            width: 80px;
            height: 80px;
            background: #e2e8f0;
            border: 2px solid #cbd5e0;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: grab;
            transition: all 0.2s ease;
            position: relative;
            flex-shrink: 0; /* Prevent shrinking */
        }

        .pipe-piece-draggable:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        .pipe-piece-draggable.dragging {
            opacity: 0.6;
            cursor: grabbing;
        }

        .pipe-piece-draggable svg {
            width: 80%;
            height: 80%;
        }

        .pipe-grid-container {
            display: grid;
            border: 3px solid #667eea;
            border-radius: 15px;
            overflow: hidden;
            background: #f8f9fa;
        }

        .grid-cell {
            width: 100px; /* Fixed size for grid cells */
            height: 100px;
            border: 1px solid #e0e0e0;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            background-color: #fff;
        }

        .grid-cell.start-node {
            background-color: #d1fae5; /* Light green */
            border: 2px solid #34d399; /* Green border */
        }
        .grid-cell.end-node {
            background-color: #fee2e2; /* Light red */
            border: 2px solid #ef4444; /* Red border */
        }

        .grid-cell .pipe-piece-placed {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer; /* To allow rotation */
            transition: transform 0.1s ease-out;
        }

        .grid-cell .pipe-piece-placed svg {
            width: 80%;
            height: 80%;
            fill: #3b82f6; /* Blue pipe color */
            stroke: #1e40af; /* Darker blue stroke */
            stroke-width: 5;
            border-radius: 5px; /* Rounded pipe ends */
        }

        .grid-cell.correct-path .pipe-piece-placed svg {
            fill: #10b981; /* Green for correct path */
            stroke: #065f46;
        }
        .grid-cell.incorrect-path .pipe-piece-placed svg {
            fill: #ef4444; /* Red for incorrect path */
            stroke: #b91c1c;
        }

        .pipe-count {
            position: absolute;
            top: 5px;
            right: 5px;
            background: #667eea;
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 0.7rem;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-header" style="display: none;">
            <div class="logo">
                <div class="logo-icon">🏗️</div>
                <span>LTD SIMULATEUR</span>
            </div>
            <div class="header-stats">
                <div class="font-size-controls">
                    <button class="font-size-btn" onclick="decreaseFontSize()">A-</button>
                    <button class="font-size-btn" onclick="increaseFontSize()">A+</button>
                </div>
                <div class="header-item">
                    <span class="score-icon"></span>
                    <span id="score">0</span>
                </div>
                <div class="header-item timer-display">
                    <span class="timer-icon"></span>
                    <span id="timer">0</span>s
                </div>
            </div>
        </div>
        
        <!-- Écran d'accueil -->
        <div id="homeScreen" class="screen active">
            <div class="logo-icon">🏗️</div>
            <h1>LTD SIMULATEUR</h1>
            <p>L'Expérience Complète du Projeteur VRD</p>
            <div class="home-features">
                <p>🔥 <span>60 Niveaux de défis techniques</span></p>
                <p>🚨 <span>Scénarios réalistes de chantier</span></p>
                <p>🚀 <span>Devenez expert en Voirie et Réseaux Divers</span></p>
            </div>
            <button class="btn" onclick="startGame()">Commencer l'aventure</button>
        </div>
        
        <!-- Écrans de jeu -->
        <div id="quizScreen" class="screen"></div>
        <div id="gameScreen" class="screen"></div>
        <div id="finalScreen" class="screen"></div>
        
        <!-- Contrôles -->
        <div class="controls" style="display: none;">
            <button class="control-btn icon-previous" data-tooltip="Niveau précédent" onclick="previousLevel()"></button>
            <button class="control-btn icon-restart" data-tooltip="Recommencer" onclick="confirmRestart()"></button>
            <button class="control-btn icon-music" data-tooltip="Musique" onclick="toggleMusic()"></button>
            <button class="control-btn icon-help" data-tooltip="Aide" onclick="showHelp()"></button>
            <button class="control-btn icon-solution" data-tooltip="Solution (-50 pts)" onclick="showSolution()"></button>
            <button class="control-btn icon-skip" data-tooltip="Passer (-10 pts)" onclick="skipLevel()"></button>
            <button class="control-btn icon-finish" data-tooltip="Finir le jeu (si score >= 1000)" id="finishGameBtn" disabled onclick="confirmFinishGame()"></button>
        </div>

        <!-- Character and Speech Bubble -->
        <div id="gameCharacter" style="display: none;"></div>
        <div id="speechBubble" style="display: none;"><span id="speechBubbleText"></span></div>

        <!-- Chronological Progress Bar (moved to bottom) -->
        <div class="progress-bar-chronological" style="display: none;">
            <div id="chronologicalProgressBarFill" class="progress-fill-chronological"></div>
        </div>

        <!-- Tips Bar (new) -->
        <div class="tips-bar" style="display: none;">
            <span id="tipsBarContent" class="tips-bar-content"></span>
        </div>
    </div>
    
    <!-- Modals -->
    <div id="helpModal" class="modal">
        <div class="modal-content">
            <button class="modal-close" onclick="closeModal('helpModal')">✕</button>
            <h2 style="color: #667eea; margin-bottom: 30px;">📚 Comment jouer ?</h2>
            <p style="font-size: 1.1rem; line-height: 1.6; margin-bottom: 25px;">
                Bienvenue dans LTD Simulateur ! Votre objectif est de devenir un expert en VRD 
                (Voirie et Réseaux Divers) en complétant 60 défis variés.
            </p>
            <h3 style="color: #764ba2; margin: 25px 0 15px;">🎮 Types de défis :</h3>
            <div style="background: #f8f9fa; padding: 20px; border-radius: 15px; margin-bottom: 25px;">
                <p style="margin: 10px 0;"><strong>📝 Quiz</strong> : Questions techniques sur la VRD</p>
                <p style="margin: 10px 0;"><strong>🔧 Matériaux</strong> : Sélection des bons matériaux</p>
                <p style="margin: 10px 0;"><strong>🔌 Réseaux</strong> : Connexion de canalisations</p>
                <p style="margin: 10px 0;"><strong>📐 Construction</strong> : Assemblage des couches</p>
                <p style="margin: 10px 0;"><strong>🧮 Calculs</strong> : Problèmes d'altitude et pente</p>
                <p style="margin: 10px 0;"><strong>⚠️ Scénarios</strong> : Situations d'urgence</p>
                <p style="margin: 10px 0;"><strong>🧩 Tuyaux</strong> : Connectez les sections de canalisation.</p>
                <p style="margin: 10px 0;"><strong>🌟 BONUS - Détection de Conflits</strong> : Identifiez les problèmes de réseaux.</p>
                <p style="margin: 10px 0;"><strong>🌟 BONUS - Calcul de Volume</strong> : Calculez les volumes de terrassement.</p>
            </div>
            <h3 style="color: #764ba2; margin: 25px 0 15px;">💯 Système de points :</h3>
            <div style="background: #e8f5e9; padding: 20px; border-radius: 15px; margin-bottom: 25px;">
                <p style="margin: 10px 0;">✅ Bonne réponse : <strong>+50 à +100 points</strong></p>
                <p style="margin: 10px 0;">❌ Mauvaise réponse : <strong>-10 à -30 points</strong></p>
                <p style="margin: 10px 0;">⏰ Temps écoulé : <strong>-20 points</strong></p>
                <p style="margin: 10px 0;">💡 Voir solution : <strong>-50 points</strong></p>
                <p style="margin: 10px 0;">⏭️ Passer : <strong>-10 points</strong></p>
                <p style="margin: 10px 0;">🔥 Bonus réussis : <strong>Doublent les points de la prochaine question !</strong></p>
            </div>
            <button class="btn" onclick="closeModal('helpModal')">Compris !</button>
        </div>
    </div>
    
    <div id="confirmModal" class="modal">
        <div class="modal-content" style="text-align: center;">
            <h2 id="confirmTitle" style="color: #667eea; margin-bottom: 30px;">Confirmer</h2>
            <p style="font-size: 1.2rem; margin: 30px 0;" id="confirmText">Êtes-vous sûr ?</p>
            <div style="display: flex; gap: 20px; justify-content: center; margin-top: 40px;">
                <button class="btn" onclick="confirmAction()">Oui</button>
                <button class="btn btn-secondary" onclick="closeModal('confirmModal')">Non</button>
            </div>
        </div>
    </div>

    <div id="correctionModal" class="modal">
        <div class="modal-content">
            <button class="modal-close" onclick="closeModal('correctionModal')">✕</button>
            <h2 style="color: #667eea; margin-bottom: 30px;">📊 Rapport de Correction</h2>
            <div id="correctionReportContent" style="font-size: 1.1rem; line-height: 1.6;">
                <!-- Correction content will be inserted here -->
            </div>
            <button class="btn mt-8" onclick="copyCorrectionToClipboard()">Copier la correction</button>
        </div>
    </div>

<script>
// Game state
let gameState = {
    currentLevel: 0,
    score: 0,
    timer: null,
    timeLeft: 0,
    musicEnabled: true,
    // Store detailed answers for correction report
    answers: [], // { levelIndex: N, type: 'quiz', question: '...', userAnswer: '...', correctAnswer: '...', isCorrect: true/false, pointsEarned: X }
    synth: null,
    pendingAction: null,
    skillScores: { // Track performance per skill type
        quiz: { correct: 0, total: 0 },
        material: { correct: 0, total: 0 },
        drag: { correct: 0, total: 0 },
        calc: { correct: 0, total: 0 },
        network: { correct: 0, total: 0 },
        scenario: { correct: 0, total: 0 },
        pipe_connect: { correct: 0, total: 0 }, // New skill type
        conflict_detection: { correct: 0, total: 0 }, // New skill type
        volume_calc: { correct: 0, total: 0 } // New skill type
    },
    baseFontSize: 14, // Default base font size in pixels, adjusted to 14px
    characterTipInterval: null, // Interval for character tips
    shuffledLevels: [], // New array to store shuffled levels
    isBonusRound: false, // Flag to indicate if current round is a bonus round
    bonusLevelData: null, // Stores the current bonus level data
    bonusMultiplier: 1 // Multiplier for points on the next question
};

// Level data
const originalLevels = [ // Renamed to originalLevels
    // Level 1-5: Introduction
    { type: 'quiz', question: "Que signifie VRD ?", answers: ["Voirie et Réseaux Divers", "Vraiment Rapide et Dangereux", "Vérification Routière Détaillée"], correct: 0, points: 50 },
    { type: 'drag', question: "Assemblez les couches d'une voirie (de bas en haut)", items: ["Sol support", "Géotextile", "Grave non traitée", "Enrobé"], points: 100 },
    { type: 'quiz', question: "Quelle est la couleur normalisée pour l'eau potable ?", answers: ["Rouge", "Bleu", "Vert", "Jaune"], correct: 1, points: 50 },
    { type: 'material', question: "Sélectionnez le matériau le plus adapté pour un trottoir", materials: ["Asphalte", "Béton désactivé", "Terre battue", "Gravier"], icons: ["🛣️", "🧱", "🌿", "🚧"], correct: 1, points: 75 },
    { type: 'network', question: "Tracez le réseau d'eaux usées du point A au point B", points: 100, correctPath: ['nodeA', 'nodeB'], nodes: [{ id: 'nodeA', cx: 100, cy: 100, color: 'blue' }, { id: 'nodeB', cx: 400, cy: 100, color: 'blue' }, { id: 'nodeC', cx: 100, cy: 400, color: 'red' }, { id: 'nodeD', cx: 400, cy: 400, color: 'red' }, { id: 'nodeE', cx: 250, cy: 250, color: 'green' }] },
    
    // Level 6-10: Technical basics
    { type: 'quiz', question: "Quelle est la pente minimale pour un réseau EU ?", answers: ["0.5%", "1%", "2%", "5%"], correct: 1, points: 75 },
    { type: 'quiz', question: "Qu'est-ce qu'un plan de récolement ?", answers: ["Le plan initial du projet", "Un plan des travaux réalisés", "Un planning de chantier"], correct: 1, points: 50 },
    { type: 'volume_calc', question: "Calculez le volume de terre (en m³) à évacuer pour une tranchée de 20m de long, 0.8m de large et 1.2m de profondeur.", answer: "19.20", points: 120 }, // Modified for diversity
    { type: 'quiz', question: "Qu'est-ce qu'un avaloir ?", answers: ["Une bouche d'incendie", "Un dispositif de collecte des eaux", "Un type de regard"], correct: 1, points: 50 },
    { type: 'calc', question: "Altitude départ: 100.00m, pente 2% sur 50m. Altitude finale ?", answer: "99.00", points: 100 },
    
    // Level 11-15: Networks
    { type: 'quiz', question: "Profondeur hors gel moyenne en France ?", answers: ["20-30cm", "50-80cm", "100-120cm"], correct: 1, points: 75 },
    { type: 'quiz', question: "Couleur du grillage avertisseur électrique ?", answers: ["Bleu", "Rouge", "Vert", "Jaune"], correct: 1, points: 50 },
    { type: 'material', question: "Quel regard pour un changement de direction EU ?", materials: ["Regard de visite", "Bouche à clé", "Avaloir", "Tabouret"], icons: ["🕳️", "🔧", "🌊", "🪑"], correct: 0, points: 75 },
    { type: 'network', question: "Connectez le réseau télécom en évitant les autres réseaux", points: 100, correctPath: ['nodeA', 'nodeD'], nodes: [{ id: 'nodeA', cx: 100, cy: 100, color: 'orange' }, { id: 'nodeB', cx: 250, cy: 250, color: 'red' }, { id: 'nodeC', cx: 400, cy: 100, color: 'green' }, { id: 'nodeD', cx: 400, cy: 400, color: 'orange' }] },
    { type: 'quiz', question: "Que signifie PMR ?", answers: ["Projet Majeur Régional", "Personnes à Mobilité Réduite", "Plan de Mise en Route"], correct: 1, points: 50 },
    
    // Level 16-20: VRD Deep Dive
    { type: 'calc', question: "Altitude finale: 85.50m, pente 1.5% sur 100m. Altitude départ ?", answer: "87.00", points: 100 },
    { type: 'quiz', question: "Quel est le rôle d'un géotextile ?", answers: ["Empêcher la pousse des mauvaises herbes", "Séparer des couches de matériaux", "Drainer l'eau", "Renforcer la structure"], correct: 1, points: 75 },
    { type: 'material', question: "Quel type de canalisation pour l'assainissement gravitaire ?", materials: ["PVC", "PEHD", "Fonte", "Acier"], icons: ["📏", "🔗", "⚙️", "🔩"], correct: 0, points: 75 },
    { type: 'quiz', question: "Qu'est-ce qu'un BPU en VRD ?", answers: ["Bordure Paveur Urbain", "Béton Prêt à l'Usage", "Bureau des Projets Urbains"], correct: 0, points: 50 }, // First occurrence (kept)
    { type: 'scenario', question: "Un réseau d'eau potable est endommagé. Quelle est la première action à mener ?", actions: ["Couper l'arrivée d'eau", "Réparer immédiatement", "Prévenir les usagers", "Analyser la cause"], correct: 0, points: 100 },

    // Level 21-25: Practical cases and standards
    { type: 'network', question: "Optimisez le tracé du réseau d'éclairage public pour minimiser les longueurs", points: 120, correctPath: ['nodeB', 'nodeC'], nodes: [{ id: 'nodeA', cx: 100, cy: 250, color: 'yellow' }, { id: 'nodeB', cx: 250, cy: 100, color: 'yellow' }, { id: 'nodeC', cx: 400, cy: 250, color: 'yellow' }, { id: 'nodeD', cx: 250, cy: 400, color: 'yellow' }] },
    { type: 'quiz', question: "Quelle norme régit l'accessibilité PMR en France ?", answers: ["NF P98-331", "Arrêté du 15 janvier 2007", "DTU 20.1"], correct: 1, points: 75 },
    { type: 'material', question: "Matériau pour une conduite d'eau potable sous pression ?", materials: ["PVC-O", "Grès", "Béton armé", "Fibrociment"], icons: ["💧", "🏺", "🏗️", "💨"], correct: 0, points: 80 },
    { type: 'calc', question: "Distance: 75m, dénivelé: 1.5m. Quelle est la pente en % ?", answer: "2.00", points: 100 },
    { type: 'scenario', question: "Vous découvrez un réseau non répertorié lors des terrassements. Que faites-vous ?", actions: ["Continuer les travaux avec prudence", "Arrêter les travaux et informer le chef de projet", "Essayer de l'identifier vous-même", "Le contourner sans le signaler"], correct: 1, points: 150 },

    // Level 26-30: Expertise and project management (Modified drag level)
    { type: 'drag', question: "Classez les étapes clés d'un projet VRD (de l'initialisation à la clôture)", items: ["Étude de faisabilité", "Conception détaillée", "Appel d'offres et sélection entreprises", "Exécution des travaux", "Réception et levée des réserves"], points: 130 }, // Modified for diversity
    { type: 'quiz', question: "Quelle est la fonction principale d'un caniveau ?", answers: ["Délimiter la chaussée", "Collecter les eaux de ruissellement", "Servir de support aux réseaux", "Améliorer l'esthétique"], correct: 1, points: 60 },
    { type: 'network', question: "Concevez un réseau de drainage pluvial pour un parking, avec points de collecte", points: 130, correctPath: ['nodeC', 'nodeD'], nodes: [{ id: 'nodeA', cx: 100, cy: 100, color: 'grey' }, { id: 'nodeB', cx: 400, cy: 100, color: 'grey' }, { id: 'nodeC', cx: 100, cy: 400, color: 'grey' }, { id: 'nodeD', cx: 400, cy: 400, color: 'grey' }] },
    { type: 'calc', question: "Longueur de réseau: 200m, pente 0.8%. Quel est le dénivelé total ?", answer: "1.60", points: 100 },
    { type: 'scenario', question: "Les prévisions météo annoncent de fortes pluies. Comment adaptez-vous le chantier ?", actions: ["Ne rien changer", "Protéger les fouilles, vérifier le drainage et sécuriser les matériaux", "Accélérer les travaux", "Arrêter le chantier complètement"], correct: 1, points: 140 },

    // Level 31: New Mini-Game - Pipe Connection
    {
        type: 'pipe_connect',
        question: "Connectez les sections de canalisation pour créer un réseau fonctionnel. Cliquez sur un tuyau pour le faire pivoter.",
        points: 150,
        gridSize: 4, // 4x4 grid
        start: { row: 0, col: 0 },
        end: { row: 3, col: 3 },
        availablePieces: [
            { type: 'straight', count: 3 }, // 3 straight pipes
            { type: 'bend', count: 4 },     // 4 bend pipes
            { type: 't_junction', count: 1 } // 1 T-junction
        ],
        correctSolutionDescription: "Utilisez les tuyaux fournis pour créer un chemin continu du point de départ au point d'arrivée."
    },
    // New levels for diversity
    { type: 'quiz', question: "Quel est le rôle du géomètre-expert en VRD ?", answers: ["Réaliser les travaux de terrassement", "Établir les plans topographiques et les implantations", "Gérer le budget du projet", "Vendre les équipements de chantier"], correct: 1, points: 80 },
    { type: 'material', question: "Quel matériau est couramment utilisé pour les conduites d'eaux pluviales de grand diamètre ?", materials: ["PVC", "PEHD annelé", "Grès", "Fonte"], icons: ["📏", "🌀", "🏺", "⚙️"], correct: 1, points: 90 },
    { type: 'drag', question: "Classez les éléments d'un regard de visite (du bas vers le haut).", items: ["Radier", "Cunette", "Rehausses", "Cadre et tampon"], points: 110 },
    { type: 'calc', question: "Un point haut est à 150.00m. La pente est de 0.5% sur 120m. Quelle est l'altitude du point bas ?", answer: "149.40", points: 100 },
    { type: 'network', question: "Tracez un réseau d'eau potable avec une dérivation vers un bâtiment.", points: 120, correctPath: ['nodeA', 'nodeC'], nodes: [{ id: 'nodeA', cx: 100, cy: 200, color: 'blue' }, { id: 'nodeB', cx: 400, cy: 200, color: 'blue' }, { id: 'nodeC', cx: 250, cy: 400, color: 'blue' }] },
    { type: 'scenario', question: "Un ouvrier signale une odeur de gaz sur le chantier. Que faites-vous ?", actions: ["Ignorer et continuer", "Arrêter les travaux, évacuer la zone et appeler les secours", "Chercher la fuite vous-même", "Ventiler la zone"], correct: 1, points: 160 },
    { type: 'quiz', question: "Quel document est utilisé pour localiser les réseaux existants avant les travaux ?", answers: ["Plan de masse", "Plan de récolement", "DICT", "Permis de construire"], correct: 2, points: 60 },
    { type: 'material', question: "Quel matériau est couramment utilisé pour les bordures de trottoir ?", materials: ["Bois", "Plastique recyclé", "Granit", "Métal"], icons: ["🌳", "♻️", "🪨", "⛓️"], correct: 2, points: 80 },
    { type: 'calc', question: "Une canalisation de 120m a un dénivelé de 2.4m. Quelle est sa pente en % ?", answer: "2.00", points: 100 },
    { type: 'quiz', question: "Quelle est la couleur du grillage avertisseur pour le gaz ?", answers: ["Bleu", "Rouge", "Jaune", "Vert"], correct: 2, points: 50 },
    { type: 'drag', question: "Classez les éléments d'un système de drainage (du plus haut au plus bas).", items: ["Grille de caniveau", "Caniveau", "Tuyau de collecte", "Regard de visite"], points: 120 },
    { type: 'network', question: "Tracez un réseau d'arrosage pour couvrir toutes les zones vertes.", points: 130, correctPath: ['nodeA', 'nodeE'], nodes: [{ id: 'nodeA', cx: 100, cy: 100, color: 'green' }, { id: 'nodeB', cx: 400, cy: 100, color: 'green' }, { id: 'nodeC', cx: 100, cy: 400, color: 'green' }, { id: 'nodeD', cx: 400, cy: 400, color: 'green' }, { id: 'nodeE', cx: 250, cy: 250, color: 'green' }] },
    { type: 'scenario', question: "Un riverain se plaint du bruit des travaux. Quelle est votre démarche ?", actions: ["Ignorer la plainte", "Lui demander de contacter la mairie", "L'écouter, expliquer les mesures prises et proposer des solutions si possible", "Arrêter immédiatement les travaux"], correct: 2, points: 120 },
    { type: 'quiz', question: "Qu'est-ce qu'un DTU ?", answers: ["Document Technique Unifié", "Déclaration de Travaux Urgents", "Dossier Technique Urbain"], correct: 0, points: 70 },
    { type: 'material', question: "Quel type de revêtement est souvent utilisé pour les pistes cyclables ?", materials: ["Béton", "Enrobé drainant", "Pavés", "Terre stabilisée"], icons: ["🧱", "�", "🪨", "🌿"], correct: 1, points: 85 },
    { type: 'calc', question: "Calculez la longueur horizontale pour une pente de 2% et un dénivelé de 0.5m.", answer: "25.00", points: 100 },
    { type: 'quiz', question: "Quel est le rôle d'un géomembranier ?", answers: ["Installer des géotextiles", "Poser des membranes d'étanchéité", "Réaliser des études géotechniques"], correct: 1, points: 75 },
    { type: 'scenario', question: "Vous découvrez un vestige archéologique sur le chantier. Que faites-vous ?", actions: ["Le déplacer discrètement pour continuer les travaux", "Arrêter les travaux, sécuriser la zone et contacter les autorités compétentes", "Le photographier et le signaler après la fin du chantier", "Le signaler à l'équipe sans arrêter les travaux"], correct: 1, points: 180 },
    { type: 'quiz', question: "Quelle est la signification de 'EP' dans le contexte VRD ?", answers: ["Eau Potable", "Eaux Pluviales", "Éclairage Public"], correct: 1, points: 60 },
    { type: 'material', question: "Matériau pour les regards de branchement d'eaux usées.", materials: ["Béton préfabriqué", "Plastique", "Brique", "Acier"], icons: ["🧱", "♻️", "🏠", "⛓️"], correct: 0, points: 70 },
    { type: 'quiz', question: "Quel est le principal risque lié à la présence d'amiante dans les anciennes canalisations ?", answers: ["Fuites fréquentes", "Contamination de l'eau", "Risque sanitaire lors de la manipulation", "Faible résistance aux chocs"], correct: 2, points: 90 },
    { type: 'quiz', question: "Quelle est la fonction d'une chambre de tirage en réseau télécom ?", answers: ["Connecter les câbles à la fibre optique", "Permettre le tirage et la maintenance des câbles", "Mesurer le débit de données"], correct: 1, points: 80 },
    { type: 'quiz', question: "Qu'est-ce qu'un PSS ?", answers: ["Plan de Sécurité et de Santé", "Projet de Stabilité des Sols", "Programme de Suivi des Sédiments"], correct: 0, points: 75 },
    { type: 'quiz', question: "Quel est le rôle du maître d'œuvre en VRD ?", answers: ["Financer le projet", "Réaliser les travaux", "Concevoir et suivre la réalisation du projet", "Vendre les matériaux"], correct: 2, points: 100 },
    { type: 'pipe_connect',
        question: "Connectez les sections de canalisation pour créer un réseau d'eau pluviale. Cliquez sur un tuyau pour le faire pivoter.",
        points: 160,
        gridSize: 5, // 5x5 grid
        start: { row: 0, col: 2 },
        end: { row: 4, col: 2 },
        availablePieces: [
            { type: 'straight', count: 5 },
            { type: 'bend', count: 6 },
            { type: 't_junction', count: 2 }
        ],
        correctSolutionDescription: "Créez un chemin continu du point de départ au point d'arrivée avec les tuyaux."
    },
    { type: 'quiz', question: "Qu'est-ce qu'un fil d'eau en assainissement ?", answers: ["Le niveau le plus bas de l'écoulement dans une canalisation", "La ligne de flottaison des eaux usées", "Le tracé d'un cours d'eau souterrain"], correct: 0, points: 70 },
    { type: 'material', question: "Quel matériau est privilégié pour les chambres de tirage de fibre optique ?", materials: ["Béton armé", "Brique", "Polyester renforcé de fibres de verre (PRV)", "Acier"], icons: ["🏗️", "🏠", "📡", "⛓️"], correct: 2, points: 95 },
    { type: 'drag', question: "Classez les étapes de raccordement d'un branchement d'eaux usées (du début à la fin).", items: ["Repérage et marquage", "Ouverture de la tranchée", "Pose du tabouret de branchement", "Raccordement au collecteur", "Remblayage et compactage"], points: 140 },
    { type: 'calc', question: "Calculez le volume de remblai (en m³) nécessaire pour une fouille de 15m de long, 3m de large et 2m de profondeur, sachant que le foisonnement est de 20%.", answer: "72.00", points: 150 }, // 15*3*2 = 90. 90 * 0.8 = 72
    { type: 'network', question: "Concevez un réseau de fibre optique pour desservir 3 points de raccordement.", points: 140, correctPath: ['nodeA', 'nodeD'], nodes: [{ id: 'nodeA', cx: 100, cy: 100, color: 'purple' }, { id: 'nodeB', cx: 400, cy: 100, color: 'purple' }, { id: 'nodeC', cx: 100, cy: 400, color: 'purple' }, { id: 'nodeD', cx: 400, cy: 400, color: 'purple' }] },
    { type: 'scenario', question: "Une machine critique tombe en panne au milieu du chantier. Que faites-vous ?", actions: ["Tenter de la réparer soi-même", "Attendre le technicien sans rien faire", "Contacter le fournisseur pour une intervention rapide et organiser un plan B", "Continuer les travaux manuellement"], correct: 2, points: 130 },
    { type: 'quiz', question: "Quelle est l'importance de la signalisation de chantier ?", answers: ["Décorer le chantier", "Informer le public et assurer la sécurité des travailleurs et usagers", "Cacher les travaux en cours"], correct: 1, points: 65 },
    { type: 'material', question: "Quel type de béton est utilisé pour les fondations profondes ?", materials: ["Béton désactivé", "Béton autoplaçant (BAP)", "Béton fibré", "Béton armé"], icons: ["🧱", "🌊", "🔗", "💪"], correct: 3, points: 85 },
    { type: 'calc', question: "Un réseau doit avoir une pente de 1.2% sur 80m. Si l'altitude de départ est 50.00m, quelle est l'altitude d'arrivée ?", answer: "49.04", points: 100 },
    { type: 'quiz', question: "Quelle est la fonction d'une bouche à clé ?", answers: ["Permettre l'accès à un regard", "Ouvrir ou fermer une vanne sur un réseau", "Mesurer la pression de l'eau"], correct: 1, points: 70 },
    { type: 'pipe_connect',
        question: "Connectez les sections de canalisation pour un réseau d'assainissement complexe.",
        points: 170,
        gridSize: 5,
        start: { row: 1, col: 0 },
        end: { row: 3, col: 4 },
        availablePieces: [
            { type: 'straight', count: 4 },
            { type: 'bend', count: 5 },
            { type: 't_junction', count: 3 },
            { type: 'cross', count: 1 }
        ],
        correctSolutionDescription: "Créez un chemin continu du point de départ au point d'arrivée avec les tuyaux."
    },
    { type: 'quiz', question: "Qu'est-ce qu'un puits perdu ?", answers: ["Un puits sans fond", "Un ouvrage de collecte et d'infiltration des eaux pluviales", "Un puits d'accès aux réseaux souterrains"], correct: 1, points: 75 },
    { type: 'material', question: "Quel matériau est le plus résistant à la corrosion pour les réseaux d'eaux usées industrielles ?", materials: ["PVC", "Grès", "Polypropylène (PP)", "Béton"], icons: ["📏", "🏺", "🧪", "🏗️"], correct: 2, points: 100 },
    { type: 'calc', question: "Un point A est à 120.50m et un point B à 119.80m, distants de 50m. Quelle est la pente moyenne en % ?", answer: "1.40", points: 110 },
    { type: 'network', question: "Tracez un réseau d'irrigation pour un parc avec plusieurs zones à desservir.", points: 150, correctPath: ['nodeA', 'nodeE'], nodes: [{ id: 'nodeA', cx: 100, cy: 100, color: 'cyan' }, { id: 'nodeB', cx: 400, cy: 100, color: 'cyan' }, { id: 'nodeC', cx: 100, cy: 400, color: 'cyan' }, { id: 'nodeD', cx: 400, cy: 400, color: 'cyan' }, { id: 'nodeE', cx: 250, cy: 250, color: 'cyan' }] },
    { type: 'scenario', question: "Un camion de livraison bloque l'accès au chantier. Que faites-vous ?", actions: ["Klaxonner jusqu'à ce qu'il bouge", "Attendre patiemment", "Contacter le chauffeur ou l'entreprise de livraison pour qu'il dégage le passage", "Essayer de le déplacer avec un engin de chantier"], correct: 2, points: 110 },
    { type: 'quiz', question: "Quelle est la différence entre un regard de visite et un tabouret de branchement ?", answers: ["Le regard est plus grand et permet l'accès pour l'entretien, le tabouret est pour les branchements individuels.", "Le regard est pour l'eau potable, le tabouret pour les eaux usées.", "Le regard est en surface, le tabouret est enterré."], correct: 0, points: 85 },
    { type: 'material', question: "Quel matériau est le plus adapté pour les pavés carrossables ?", materials: ["Béton", "Granit", "Grès", "Bois"], icons: ["🧱", "🪨", "🏺", "🌳"], correct: 1, points: 90 },
    { type: 'calc', question: "Une conduite de 300m a un dénivelé de 6m. Quelle est sa pente en pour mille (‰) ?", answer: "20.00", points: 120 }, // 6/300 * 1000 = 20
    { type: 'quiz', question: 'Qu\'est-ce qu\'une "zone d\'emprise" en VRD ?', answers: ["La zone où les engins de chantier sont stockés", "La surface de terrain nécessaire à la réalisation des travaux et à l'implantation des ouvrages", "La zone de circulation des piétons"], correct: 1, points: 75 },
    { type: 'pipe_connect',
        question: "Rétablissez la connexion du réseau d'assainissement après une rupture.",
        points: 180,
        gridSize: 6,
        start: { row: 0, col: 0 },
        end: { row: 5, col: 5 },
        availablePieces: [
            { type: 'straight', count: 6 },
            { type: 'bend', count: 7 },
            { type: 't_junction', count: 2 },
            { type: 'cross', count: 1 }
        ],
        correctSolutionDescription: "Créez un chemin continu du point de départ au point d'arrivée avec les tuyaux."
    },
    { type: 'quiz', question: "À quoi sert un fil d'eau dans le calcul de pente d'une canalisation ?", answers: ["À mesurer le débit d'eau", "À définir la ligne de référence pour la pente", "À indiquer la présence d'eau"], correct: 1, points: 80 },
    { type: 'material', question: "Quel type de géomembrane est utilisé pour l'étanchéité des bassins de rétention ?", materials: ["PVC", "PEHD", "EPDM", "Bitume"], icons: ["📏", "🔗", "💧", "🛣️"], correct: 1, points: 95 },
    { type: 'calc', question: "Une parcelle a une superficie de 500m². Un bassin de rétention doit collecter 100m³ d'eau. Quelle hauteur d'eau (en m) cela représente-t-il sur la parcelle ?", answer: "0.20", points: 130 }, // 100/500 = 0.2
    { type: 'network', question: "Connectez les bornes incendie au réseau d'eau existant, en respectant les distances de sécurité.", points: 160, correctPath: ['nodeA', 'nodeB'], nodes: [{ id: 'nodeA', cx: 100, cy: 100, color: 'red' }, { id: 'nodeB', cx: 400, cy: 100, color: 'red' }, { id: 'nodeC', cx: 100, cy: 400, color: 'red' }, { id: 'nodeD', cx: 400, cy: 400, color: 'red' }] },
    { type: 'scenario', question: "Un engin de chantier endommage accidentellement une clôture de propriété privée. Que faites-vous ?", actions: ["Ignorer et partir", "Réparer la clôture vous-même sans prévenir", "Sécuriser la zone, informer le propriétaire et le chef de projet, et organiser la réparation professionnelle", "Laisser un mot avec vos coordonnées"], correct: 2, points: 170 },
    { type: 'quiz', question: "Quel est le rôle d'un contrôleur technique en VRD ?", answers: ["Réaliser les études de sol", "Vérifier la conformité des ouvrages aux normes et réglementations", "Gérer les équipes sur le chantier"], correct: 1, points: 90 },
    { type: 'material', question: "Quel type de sable est utilisé pour le lit de pose des canalisations ?", materials: ["Sable de carrière", "Sable de mer", "Sable concassé", "Sable de rivière lavé"], icons: ["⛰️", "🌊", "🔨", "💧"], correct: 3, points: 80 },
    { type: 'calc', question: "Un regard a une altitude de fond de 98.75m. La canalisation en sortie a une pente de 1.5% sur 30m. Quelle est l'altitude du fil d'eau à 30m ?", answer: "98.30", points: 120 }, // 98.75 - (30 * 0.015) = 98.30
    { type: 'quiz', question: "Que signifie 'DICT' en VRD ?", answers: ["Déclaration d'Intention de Commencement de Travaux", "Document d'Information sur les Canalisations et les Terrains", "Dossier d'Intervention et de Consultation Technique"], correct: 0, points: 60 }, // Replaced duplicate 2
    { type: 'scenario', question: "Le budget du projet est dépassé. Quelle est votre première action ?", actions: ["Arrêter tous les travaux", "Demander plus d'argent sans justification", "Analyser les causes du dépassement et proposer des mesures correctives au chef de projet", "Réduire la qualité des matériaux pour économiser"], correct: 2, points: 140 },
    { type: 'quiz', question: "Quelle est la fonction d'un réseau séparatif ?", answers: ["Collecter toutes les eaux (usées et pluviales) ensemble", "Séparer la collecte des eaux usées de celle des eaux pluviales", "Séparer les réseaux d'eau potable et d'incendie"], correct: 1, points: 80 },
    { type: 'material', question: "Quel type de grave est utilisé pour la couche de fondation d'une chaussée ?", materials: ["Grave non traitée (GNT)", "Sable", "Terre végétale", "Enrobé"], icons: ["🚧", "🏖️", "🌿", "🛣️"], correct: 0, points: 85 },
    { type: 'calc', question: "Un réseau de 80m de long a un dénivelé de 1.6m. Quelle est sa pente en degrés ?", answer: "1.15", points: 140 }, // atan(1.6/80) * 180/PI = 1.1459
    { type: 'quiz', question: "Quel est le rôle du 'DTU' dans la construction ?", answers: ["Définir les règles de l'art pour les travaux", "Document de Travaux Urgents", "Déclaration Technique d'Urbanisme"], correct: 0, points: 70 }, // Replaced duplicate 3
];

const bonusLevels = [
    { type: 'conflict_detection', question: "Une canalisation de gaz (PEHD) est posée à 20 cm d'un arbre existant. Y a-t-il un conflit ?", options: ["Oui, risque d'endommagement par les racines", "Non, la distance est suffisante", "Oui, conflit de matériau"], correct: 0, points: 150 }, // Modified for diversity
    { type: 'volume_calc', question: "Calculez le volume de terre (en m³) à évacuer pour une fouille de 10m de long, 2m de large et 1.5m de profondeur.", answer: "30.00", points: 150 },
    { type: 'volume_calc', question: "Quel volume de grave non traitée (en m³) est nécessaire pour une couche de forme de 100m de long, 6m de large et 0.30m d'épaisseur ?", answer: "180.00", points: 140 }, // New diverse volume calc
    { type: 'conflict_detection', question: "Un collecteur d'eaux usées (diamètre 500mm) est prévu avec une pente de 0.2%. Y a-t-il un conflit ?", options: ["Non, c'est une pente standard", "Oui, la pente est insuffisante pour l'auto-curage", "Oui, la pente est trop forte"], correct: 1, points: 160 }, // New diverse conflict detection
    { type: 'volume_calc', question: "Un réservoir cylindrique d'eau pluviale a un diamètre de 3m et une hauteur de 4m. Quel est son volume (en m³) ?", answer: "28.27", points: 130 }, // New diverse volume calc (requires PI)
    { type: 'conflict_detection', question: "Un réseau d'eau potable doit croiser un réseau électrique existant. La norme impose une distance minimale de 40 cm. Ils sont prévus à 30 cm. Y a-t-il un conflit ?", options: ["Non, la distance est acceptable", "Oui, la distance minimale n'est pas respectée", "Oui, mais uniquement si l'eau est sous pression"], correct: 1, points: 170 } // Another diverse conflict detection
];

// Tips for the scrolling bar
const gameTips = [
    "Astuce: Vérifiez toujours les plans de réseaux avant de terrasser.",
    "Astuce: Une bonne gestion des eaux pluviales est cruciale pour la durabilité des ouvrages.",
    "Astuce: La profondeur hors gel varie selon les régions, adaptez vos calculs!",
    "Astuce: Les normes PMR garantissent l'accessibilité pour tous, ne les négligez jamais.",
    "Astuce: Un plan de récolement précis est essentiel pour les futures interventions.",
    "Astuce: La couleur bleue indique généralement les réseaux d'eau potable.",
    "Astuce: La pente minimale pour un réseau d'eaux usées est de 1% pour assurer l'écoulement.",
    "Astuce: Le géotextile sépare les couches de matériaux et prévient le mélange.",
    "Astuce: Les regards de visite permettent l'inspection et l'entretien des réseaux.",
    "Astuce: En cas de réseau non répertorié, stoppez les travaux et signalez-le immédiatement.",
    "Astuce: Pour le mini-jeu de tuyaux, chaque pièce compte ! Planifiez votre chemin avant de placer.",
    "Astuce: La DICT est obligatoire avant tout travail à proximité des réseaux existants.",
    "Astuce: Le PEHD est un excellent choix pour les canalisations de gaz grâce à sa flexibilité.",
    "Astuce: Un PSS (Plan de Sécurité et de Santé) est vital pour la prévention des accidents sur chantier.",
    "Astuce: Le rôle du géomètre-expert est fondamental pour l'implantation précise des ouvrages VRD.",
    "Astuce: Le fil d'eau est la référence altimétrique pour la pose des canalisations gravitaires.",
    "Astuce: La signalisation de chantier protège les travailleurs et les usagers de la voie publique."
];
let currentTipIndex = 0;
let tipInterval = null;

// Utility functions
function showScreen(screenId) {
    document.querySelectorAll('.screen').forEach(screen => {
        screen.classList.remove('active');
        screen.classList.remove('bonus-active'); // Remove bonus class when switching screens
    });
    document.getElementById(screenId).classList.add('active');
}

function updateHeader() {
    document.getElementById('score').textContent = gameState.score;
    document.getElementById('timer').textContent = gameState.timeLeft;
    updateChronologicalProgressBar(); // Update progress bar on header update
    checkFinishGameButton(); // Check and update finish game button state
}

function updateChronologicalProgressBar() {
    const progressBarFill = document.getElementById('chronologicalProgressBarFill');
    // Use gameState.shuffledLevels.length for total levels
    const progressPercentage = (gameState.currentLevel / gameState.shuffledLevels.length) * 100;
    if (progressBarFill) { // Added null check
        progressBarFill.style.width = `${progressPercentage}%`;
        progressBarFill.textContent = `${gameState.currentLevel}/${gameState.shuffledLevels.length}`;
    }
}

function startTimer(duration) {
    clearInterval(gameState.timer);
    gameState.timeLeft = duration;
    updateHeader();
    const timerElement = document.querySelector('.timer-display');
    if (timerElement) { // Added null check
        timerElement.classList.remove('warning');
    }


    gameState.timer = setInterval(() => {
        gameState.timeLeft--;
        updateHeader();
        if (gameState.timeLeft <= 10 && gameState.timeLeft > 0) {
            if (timerElement) { // Added null check
                timerElement.classList.add('warning');
            }
            playSound('shortBeep');
        } else if (gameState.timeLeft <= 0) {
            clearInterval(gameState.timer);
            if (timerElement) { // Added null check
                timerElement.classList.remove('warning');
            }
            handleTimeout();
        }
    }, 1000);
}

function stopTimer() {
    clearInterval(gameState.timer);
    const timerElement = document.querySelector('.timer-display');
    if (timerElement) { // Added null check
        timerElement.classList.remove('warning');
    }
}

function playSound(type) {
    if (!gameState.musicEnabled) return;

    // Ensure synth is initialized
    if (!gameState.synth) {
        console.warn("Tone.PolySynth not initialized when playSound was called.");
        return;
    }

    switch (type) {
        case 'correct':
            gameState.synth.triggerAttackRelease("C5", "8n");
            break;
        case 'incorrect':
            gameState.synth.triggerAttackRelease("C3", "8n");
            break;
        case 'levelUp':
            const levelUpNotes = ["C4", "E4", "G4"];
            const levelUpDuration = "0.5s";
            levelUpNotes.forEach((note, index) => {
                // Play each note with a tiny offset to ensure they are distinct events
                // and avoid the "Invalid argument(s) to setValueAtTime" error with arrays.
                gameState.synth.triggerAttackRelease(note, Tone.context.currentTime + (index * 0.01), levelUpDuration);
            });
            break;
        case 'gameOver':
            const gameOverNotes = ["C3", "G2", "C2"];
            const gameOverDuration = "1s";
            gameOverNotes.forEach((note, index) => {
                gameState.synth.triggerAttackRelease(note, Tone.context.currentTime + (index * 0.01), gameOverDuration);
            });
            break;
        case 'shortBeep':
            gameState.synth.triggerAttackRelease("C4", "32n");
            break;
        case 'buttonClick':
            gameState.synth.triggerAttackRelease("C6", "64n");
            break;
        case 'bonusStart':
            gameState.synth.triggerAttackRelease(["C5", "E5", "G5"], "0.5"); // Upbeat chord
            break;
    }
}

function toggleMusic() {
    gameState.musicEnabled = !gameState.musicEnabled;
    const musicBtn = document.querySelector('.icon-music');
    if (musicBtn) { // Added null check
        if (gameState.musicEnabled) {
            musicBtn.classList.remove('muted');
            // Potentially start background music here if desired
        } else {
            musicBtn.classList.add('muted');
            // Stop background music here if playing
        }
    }
    playSound('buttonClick');
}

function showModal(modalId) {
    const modal = document.getElementById(modalId);
    if (modal) { // Added null check
        modal.classList.add('active');
    }
}

function closeModal(modalId) {
    const modal = document.getElementById(modalId);
    if (modal) { // Added null check
        modal.classList.remove('active');
    }
    gameState.pendingAction = null; // Clear any pending action when modal closes
}

function confirmAction() {
    if (gameState.pendingAction) {
        gameState.pendingAction();
        gameState.pendingAction = null;
    }
    closeModal('confirmModal');
}

function showConfirmModal(title, text, action) {
    const confirmTitle = document.getElementById('confirmTitle');
    const confirmText = document.getElementById('confirmText');
    if (confirmTitle) { // Added null check
        confirmTitle.textContent = title;
    }
    if (confirmText) { // Added null check
        confirmText.textContent = text;
    }
    gameState.pendingAction = action;
    showModal('confirmModal');
}

/**
 * Shuffles an array in place using the Fisher-Yates (Knuth) algorithm.
 * @param {Array} array The array to shuffle.
 */
function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]]; // Swap elements
    }
}

// Navigation and game functions
async function startGame() { // Make it async
    // Ensure audio context is started on user gesture
    if (Tone.context.state !== 'running') {
        await Tone.start(); // Await Tone.start()
    }
    // Initialize PolySynth for playing chords
    if (!gameState.synth) {
        gameState.synth = new Tone.PolySynth(Tone.Synth).toDestination();
    }

    gameState.currentLevel = 0;
    gameState.score = 0;
    gameState.answers = []; // Reset answers for new game
    // Reset skill scores for new game
    for (const skill in gameState.skillScores) {
        gameState.skillScores[skill] = { correct: 0, total: 0 };
    }

    // Shuffle levels for a new game
    gameState.shuffledLevels = [...originalLevels]; // Create a copy to shuffle
    shuffleArray(gameState.shuffledLevels);
    
    // Reset bonus state
    gameState.isBonusRound = false;
    gameState.bonusLevelData = null;
    gameState.bonusMultiplier = 1;

    const gameHeader = document.querySelector('.game-header');
    const controls = document.querySelector('.controls');
    const progressBar = document.querySelector('.progress-bar-chronological');
    const tipsBar = document.querySelector('.tips-bar');
    const gameCharacter = document.getElementById('gameCharacter');

    if (gameHeader) gameHeader.style.display = 'flex';
    if (controls) controls.style.display = 'flex';
    if (progressBar) progressBar.style.display = 'block'; // Show progress bar
    if (tipsBar) tipsBar.style.display = 'block'; // Show tips bar
    if (gameCharacter) gameCharacter.style.display = 'block'; // Show character

    startTipsMarquee(); // Start tips marquee
    displayCharacter('🚀', "Bienvenue, Projeteur ! Prêt à relever le défi ?", 3000); // Welcome message
    loadLevel();
    playSound('levelUp');
}

function loadLevel() {
    stopTimer();
    const levelToLoad = gameState.isBonusRound ? gameState.bonusLevelData : gameState.shuffledLevels[gameState.currentLevel];
    const quizScreen = document.getElementById('quizScreen');
    const gameScreen = document.getElementById('gameScreen');
    
    // Remove bonus-active class from all screens first
    document.querySelectorAll('.screen').forEach(screen => screen.classList.remove('bonus-active'));

    if (quizScreen) quizScreen.innerHTML = ''; // Clear previous content
    if (gameScreen) gameScreen.innerHTML = ''; // Clear previous content

    updateHeader(); // Update header including progress bar
    
    if (!levelToLoad) {
        endGame();
        return;
    }

    // Determine time limit based on level type
    let timeLimit;
    switch (levelToLoad.type) {
        case 'quiz':
            timeLimit = 30; // 30 seconds for quiz
            break;
        case 'material':
        case 'drag':
        case 'calc':
            timeLimit = 45; // 45 seconds for material, drag, calc
            break;
        case 'network':
        case 'pipe_connect': // New pipe connect game
            timeLimit = 60; // 60 seconds for network and pipe connect
            break;
        case 'scenario':
            timeLimit = 90; // 90 seconds for scenario
            break;
        case 'conflict_detection': // New bonus type
            timeLimit = 50; 
            break;
        case 'volume_calc': // New bonus type
            timeLimit = 40; 
            break;
        default:
            timeLimit = 30; // Default time
    }
    startTimer(timeLimit);

    // Render level based on type
    switch (levelToLoad.type) {
        case 'quiz':
            renderQuizLevel(levelToLoad);
            showScreen('quizScreen');
            break;
        case 'material':
            renderMaterialLevel(levelToLoad);
            showScreen('quizScreen'); // Using quizScreen for material selection
            break;
        case 'drag':
            renderDragLevel(levelToLoad);
            showScreen('gameScreen'); // Using gameScreen for drag and drop
            break;
        case 'calc':
            renderCalcLevel(levelToLoad);
            showScreen('quizScreen'); // Using quizScreen for calculation
            break;
        case 'network':
            renderNetworkLevel(levelToLoad);
            showScreen('gameScreen'); // Using gameScreen for network drawing
            break;
        case 'scenario':
            renderScenarioLevel(levelToLoad);
            showScreen('quizScreen'); // Using quizScreen for scenario
            break;
        case 'pipe_connect': // New mini-game
            renderPipeConnectLevel(levelToLoad);
            showScreen('gameScreen');
            break;
        case 'conflict_detection': // New bonus type
            renderConflictDetectionLevel(levelToLoad);
            showScreen('quizScreen');
            const quizScreenElement = document.getElementById('quizScreen');
            if (quizScreenElement) { // Added null check
                quizScreenElement.classList.add('bonus-active'); // Add bonus class
            }
            break;
        case 'volume_calc': // New bonus type
            renderVolumeCalcLevel(levelToLoad);
            showScreen('quizScreen');
            const quizScreenElement2 = document.getElementById('quizScreen');
            if (quizScreenElement2) { // Added null check
                quizScreenElement2.classList.add('bonus-active'); // Add bonus class
            }
            break;
        default:
            console.error("Unknown level type:", levelToLoad.type);
            // Fallback to a simple quiz or skip
            break;
    }
    applyFontSize(); // Apply font size after rendering new content
}

function startBonusRoundTransition() {
    playSound('bonusStart');
    displayCharacter('🌟', "NIVEAU BONUS ! Doublez vos points sur la prochaine question !", 3000); // Character announces bonus
    
    // Directly load the bonus level after a short delay for the character message
    setTimeout(() => {
        loadLevel(); // Load the bonus level
    }, 1000); // Short delay to allow character message to be seen/heard
}

function nextLevel() {
    stopTimer();

    // If the previous level was a bonus round, reset bonus state
    if (gameState.isBonusRound) {
        gameState.isBonusRound = false;
        gameState.bonusLevelData = null;
        // The bonusMultiplier is consumed by the checkAnswer function of the *next* question.
        // So we don't reset it here, it will be reset to 1 by the next regular loadLevel.
        gameState.currentLevel++; // Move to the next *regular* level
    } else {
        gameState.currentLevel++; // Move to the next *regular* level
        // Randomly decide if the *next* level should be a bonus level (20% chance)
        // Only trigger if there are still regular levels left
        if (Math.random() < 0.2 && gameState.currentLevel < gameState.shuffledLevels.length) {
            gameState.isBonusRound = true;
            gameState.bonusLevelData = bonusLevels[Math.floor(Math.random() * bonusLevels.length)];
            gameState.bonusMultiplier = 2; // Set multiplier for the *next* question
            startBonusRoundTransition(); // Start the bonus transition
            return; // Exit to prevent immediate loadLevel
        } else {
            gameState.bonusMultiplier = 1; // Ensure multiplier is 1 for regular levels
        }
    }

    if (gameState.currentLevel < gameState.shuffledLevels.length || gameState.isBonusRound) {
        loadLevel();
        playSound('levelUp');
    } else {
        endGame();
    }
}

function previousLevel() {
    if (gameState.currentLevel > 0) {
        showConfirmModal("Retour au niveau précédent", "Vous perdrez le score du niveau actuel. Continuer ?", () => {
            // If we were in a bonus round, we need to go back to the regular level before it
            if (gameState.isBonusRound) {
                gameState.isBonusRound = false;
                gameState.bonusLevelData = null;
                gameState.bonusMultiplier = 1; // Reset multiplier
                // currentLevel does not change if we were in a bonus round, as it's an interstitial level
            } else {
                gameState.currentLevel--;
            }
            
            // Remove the last answer record if going back
            if (gameState.answers.length > gameState.currentLevel) {
                const lastAnswer = gameState.answers.pop();
                // If the popped answer was correct, decrement correct count for that skill
                if (lastAnswer.isCorrect) {
                    gameState.skillScores[lastAnswer.type].correct--;
                }
                gameState.skillScores[lastAnswer.type].total--; // Always decrement total
            }
            loadLevel();
        });
    } else {
        // Optionally show a message that they are on the first level
    }
}

function confirmRestart() {
    showConfirmModal("Recommencer le jeu", "Êtes-vous sûr de vouloir recommencer du début ? Votre score sera remis à zéro.", startGame);
}

function showHelp() {
    showModal('helpModal');
    playSound('buttonClick');
}

function showSolution() {
    const pointsCost = 50;
    if (gameState.score < pointsCost) {
        displayCharacter('🤔', `Vous n'avez pas assez de points pour cela ! Il vous faut ${pointsCost} points.`, 3000);
        playSound('incorrect');
        return;
    }

    showConfirmModal("Afficher la solution", `Afficher la solution vous coûtera ${pointsCost} points. Continuer ?`, () => {
        const level = gameState.isBonusRound ? gameState.bonusLevelData : gameState.shuffledLevels[gameState.currentLevel];
        const pointsLost = pointsCost;
        gameState.score = Math.max(0, gameState.score - pointsLost); // Ensure score doesn't go below zero
        updateHeader();
        
        // Record the answer as incorrect due to solution view
        gameState.answers.push({
            levelIndex: gameState.currentLevel,
            type: level.type,
            question: level.question,
            userAnswer: "Solution affichée",
            correctAnswer: getCorrectAnswerForLevel(level),
            isCorrect: false,
            pointsEarned: -pointsLost
        });
        // Update skill score for this type as incorrect
        gameState.skillScores[level.type].total++;
        // No increment for correct as solution was viewed

        // Implement solution display based on current level type
        if (level.type === 'quiz' || level.type === 'conflict_detection' || level.type === 'scenario') {
            const buttons = document.querySelectorAll('.answer-btn');
            buttons.forEach((btn) => {
                if (btn.dataset.isCorrect === 'true') { // Check the data attribute
                    btn.classList.add('correct');
                } else {
                    btn.classList.add('incorrect');
                }
                btn.disabled = true;
            });
        } else if (level.type === 'material') {
            const cards = document.querySelectorAll('.material-card');
            cards.forEach((card) => {
                if (card.dataset.isCorrect === 'true') { // Check the data attribute
                    card.classList.add('correct');
                } else {
                    card.classList.add('incorrect');
                }
                card.style.pointerEvents = 'none'; // Disable clicks
            });
        } else if (level.type === 'calc' || level.type === 'volume_calc') { // Added volume_calc
            const input = document.getElementById('elevationInput');
            const validateBtn = document.getElementById('validateCalcBtn');
            if (input) { // Added null check
                input.value = level.answer;
                input.style.borderColor = '#4caf50';
                input.style.boxShadow = '0 0 0 3px rgba(76, 175, 80, 0.2)';
            }
            if (validateBtn) { // Added null check
                validateBtn.disabled = true;
            }
        } else if (level.type === 'drag') {
            const dropZones = document.querySelectorAll('.drop-zone');
            const correctOrder = level.items; // Use items from the current shuffled level
            dropZones.forEach((zone, index) => {
                const droppedItem = zone.querySelector('.draggable');
                if (droppedItem) droppedItem.remove(); // Remove existing items
                
                const correctItem = document.createElement('div');
                correctItem.classList.add('draggable', 'correct');
                correctItem.textContent = correctOrder[index];
                correctItem.draggable = false;
                zone.appendChild(correctItem);
                zone.style.borderColor = '#4caf50';
                zone.style.borderStyle = 'solid';
            });
            const gameScreenBtn = document.getElementById('gameScreen').querySelector('.btn');
            if (gameScreenBtn) { // Added null check
                gameScreenBtn.disabled = true;
            }
        } else if (level.type === 'network') {
            // For network, display the correct path visually
            const drawnLinesGroup = document.getElementById('drawnLines');
            if (drawnLinesGroup) { // Added null check
                drawnLinesGroup.innerHTML = ''; // Clear any user-drawn lines
            }

            // Use the nodes from the level data
            const nodes = level.nodes;
            // Use the correctPath from the level data
            const correctPath = level.correctPath; 

            if (correctPath && correctPath.length === 2) { // Added null check for correctPath
                const startNode = nodes.find(n => n.id === correctPath[0]);
                const endNode = nodes.find(n => n.id === correctPath[1]);

                if (startNode && endNode && drawnLinesGroup) { // Added null check for drawnLinesGroup
                    const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                    line.setAttribute('x1', startNode.cx);
                    line.setAttribute('y1', startNode.cy);
                    line.setAttribute('x2', endNode.cx);
                    line.setAttribute('y2', endNode.cy);
                    line.setAttribute('stroke', '#4caf50'); // Green for correct
                    line.setAttribute('stroke-width', '4');
                    line.setAttribute('marker-end', 'url(#arrow)');
                    drawnLinesGroup.appendChild(line);
                }
            }
            const gameScreenBtn = document.getElementById('gameScreen').querySelector('.btn');
            if (gameScreenBtn) { // Added null check
                gameScreenBtn.disabled = true;
            }
        } else if (level.type === 'pipe_connect') {
            // For pipe connect, display a visual representation of a possible correct solution
            const pipeGridContainer = document.getElementById('pipeGridContainer');
            if (pipeGridContainer) {
                // Clear the grid
                pipeGridContainer.innerHTML = '';
                pipeGridContainer.style.gridTemplateColumns = `repeat(${level.gridSize}, 100px)`;

                // Define a simple correct path for demonstration
                const solutionPath = [
                    {r:0, c:0, type:'start', rotation:0},
                    {r:0, c:1, type:'straight', rotation:90},
                    {r:0, c:2, type:'straight', rotation:90},
                    {r:0, c:3, type:'bend', rotation:270},
                    {r:1, c:3, type:'straight', rotation:0},
                    {r:2, c:3, type:'straight', rotation:0},
                    {r:3, c:3, type:'end', rotation:0}
                ];

                const gridCells = Array(level.gridSize).fill(0).map((_, r) =>
                    Array(level.gridSize).fill(0).map((_, c) => {
                        const cell = document.createElement('div');
                        cell.classList.add('grid-cell');
                        const solutionPiece = solutionPath.find(p => p.r === r && p.c === c);
                        if (solutionPiece) {
                            if (solutionPiece.type === 'start') {
                                cell.classList.add('start-node');
                                cell.textContent = 'Départ';
                            } else if (solutionPiece.type === 'end') {
                                cell.classList.add('end-node');
                                cell.textContent = 'Arrivée';
                            } else {
                                const pipeDiv = document.createElement('div');
                                pipeDiv.classList.add('pipe-piece-placed', 'correct-path');
                                pipeDiv.innerHTML = getPipeSVG(solutionPiece.type);
                                pipeDiv.style.transform = `rotate(${solutionPiece.rotation}deg)`;
                                cell.appendChild(pipeDiv);
                            }
                        }
                        pipeGridContainer.appendChild(cell);
                        return cell;
                    })
                );
            }
            const validateButton = document.getElementById('validatePipeConnectBtn');
            if (validateButton) validateButton.disabled = true;
        }

        setTimeout(nextLevel, 3000); // Automatically move to next level after showing solution
        playSound('incorrect'); // Play a sound indicating score loss
        displayCharacter('💡', "Pas de souci, l'apprentissage continue !", 3000); // Solution message
    });
}

function skipLevel() {
    const pointsCost = 10;
    if (gameState.score < pointsCost) {
        displayCharacter('🤔', `Vous n'avez pas assez de points pour cela ! Il vous faut ${pointsCost} points.`, 3000);
        playSound('incorrect');
        return;
    }

    showConfirmModal("Passer le niveau", `Passer ce niveau vous coûtera ${pointsCost} points. Continuer ?`, () => {
        const level = gameState.isBonusRound ? gameState.bonusLevelData : gameState.shuffledLevels[gameState.currentLevel];
        const pointsLost = pointsCost;
        gameState.score = Math.max(0, gameState.score + pointsLost);
        updateHeader();
        
        // Record the answer as skipped
        gameState.answers.push({
            levelIndex: gameState.currentLevel,
            type: level.type,
            question: level.question,
            userAnswer: "Niveau passé",
            correctAnswer: getCorrectAnswerForLevel(level),
            isCorrect: false,
            pointsEarned: -pointsLost
        });
        // Update skill score for this type as incorrect (or not attempted)
        gameState.skillScores[level.type].total++;

        nextLevel();
        playSound('incorrect'); // Play a sound indicating score loss
        displayCharacter('⏭️', "Parfois, il faut savoir passer à autre chose.", 3000); // Skip message
    });
}

function handleTimeout() {
    const level = gameState.isBonusRound ? gameState.bonusLevelData : gameState.shuffledLevels[gameState.currentLevel];
    const pointsLost = 20;
    gameState.score = Math.max(0, gameState.score + pointsLost); // Penalty for timeout
    updateHeader();
    
    // Record the answer as timeout
    gameState.answers.push({
        levelIndex: gameState.currentLevel,
        type: level.type,
        question: level.question,
        userAnswer: "Temps écoulé",
        correctAnswer: getCorrectAnswerForLevel(level),
        isCorrect: false,
        pointsEarned: pointsLost // This should be negative for penalty
    });
    // Update skill score for this type as incorrect
    gameState.skillScores[level.type].total++;

    // Visually indicate timeout, e.g., flash timer red
    const timerElement = document.querySelector('.timer-display');
    if (timerElement) { // Added null check
        timerElement.classList.add('warning');
    }
    playSound('incorrect');
    displayCharacter('⏰', "Oups, le temps est écoulé ! Plus vite la prochaine fois.", 3000); // Timeout message
    setTimeout(() => {
        if (timerElement) { // Added null check
            timerElement.classList.remove('warning');
        }
        nextLevel();
    }, 1500); // Wait a bit before moving to next level
}

function getCorrectAnswerForLevel(level) {
    // For levels that have been shuffled, we need to refer to the original level
    // to get the correct answer's text/value, as the index might have changed.
    // For bonus levels, they are not in originalLevels, so we directly use the level object.
    const sourceLevel = originalLevels.find(l => l.question === level.question) || bonusLevels.find(l => l.question === level.question) || level;

    switch (sourceLevel.type) {
        case 'quiz':
            return sourceLevel.answers[sourceLevel.correct];
        case 'material':
            return sourceLevel.materials[sourceLevel.correct];
        case 'drag':
            return sourceLevel.items.join(' > ');
        case 'calc':
            // For calc, round to 2 decimal places for consistency
            return parseFloat(sourceLevel.answer).toFixed(2);
        case 'network':
            // Use the correctPath from the sourceLevel
            const nodes = sourceLevel.nodes;
            const correctPathIds = sourceLevel.correctPath; 
            const correctPathNames = correctPathIds.map(id => nodes.find(n => n.id === id)?.id || id);
            return `Connecter: ${correctPathNames.join(' -> ')}`;
        case 'scenario':
            return sourceLevel.actions[sourceLevel.correct];
        case 'pipe_connect':
            return sourceLevel.correctSolutionDescription; // Use the descriptive solution
        case 'conflict_detection': // New bonus type
            return sourceLevel.options[sourceLevel.correct];
        case 'volume_calc': // New bonus type
            // For volume_calc, round to 2 decimal places for consistency
            return parseFloat(sourceLevel.answer).toFixed(2);
        default:
            return "N/A";
    }
}

function endGame() {
    stopTimer();
    stopTipsMarquee(); // Stop tips marquee
    clearInterval(gameState.characterTipInterval); // Stop character tip interval

    // Hide game elements
    const gameHeader = document.querySelector('.game-header');
    const controls = document.querySelector('.controls');
    const progressBar = document.querySelector('.progress-bar-chronological');
    const tipsBar = document.querySelector('.tips-bar');
    const gameCharacter = document.getElementById('gameCharacter');
    const speechBubble = document.getElementById('speechBubble');

    if (gameHeader) gameHeader.style.display = 'none';
    if (controls) controls.style.display = 'none';
    if (progressBar) progressBar.style.display = 'none'; // Hide progress bar
    if (tipsBar) tipsBar.style.display = 'none'; // Hide tips bar
    if (gameCharacter) gameCharacter.style.display = 'none'; // Hide character
    if (speechBubble) speechBubble.style.display = 'none'; // Hide speech bubble

    showScreen('finalScreen');
    const finalScreen = document.getElementById('finalScreen');
    if (finalScreen) { // Added null check
        finalScreen.innerHTML = `
            <div class="logo-icon" style="font-size: 5rem; width: 100px; height: 100px; margin-bottom: 30px;">🏆</div>
            <h1>Aventure Terminée !</h1>
            <h2 style="font-size: 1.8rem; color: #333; margin-bottom: 40px;">Félicitations, Projeteur VRD !</h2>
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-number">${gameState.score}</div>
                    <div class="stat-label">Points Totaux</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${gameState.currentLevel} / ${originalLevels.length}</div>
                    <div class="stat-label">Niveaux Complétés</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${(gameState.currentLevel > 0 ? (gameState.answers.filter(a => a.isCorrect).length / gameState.currentLevel) * 100 : 0).toFixed(0)}%</div>
                    <div class="stat-label">Précision Moyenne</div>
                </div>
            </div>
            <button class="btn" onclick="startGame()">Rejouer</button>
            <button class="btn btn-secondary mt-4" onclick="showCorrectionReport()">Voir la correction</button>
        `;
    }
    triggerConfetti();
    playSound('gameOver');
    displayCharacter('🎓', "Bravo pour cette belle performance ! Revenez vite pour de nouveaux défis.", 5000); // End game message
}

function generateCorrectionReport() {
    let reportHtml = '<h3>Performance par Compétence :</h3><ul>';
    for (const skill in gameState.skillScores) {
        const { correct, total } = gameState.skillScores[skill];
        const percentage = total > 0 ? ((correct / total) * 100).toFixed(0) : 0;
        reportHtml += `<li><strong>${skill.charAt(0).toUpperCase() + skill.slice(1)}</strong>: ${correct} / ${total} (${percentage}%)</li>`;
    }
    reportHtml += '</ul><br/><h3>Détail des Réponses :</h3><ol>';

    gameState.answers.forEach((answer, index) => {
        const status = answer.isCorrect ? '✅ Correct' : '❌ Incorrect';
        const points = answer.pointsEarned >= 0 ? `(+${answer.pointsEarned} pts)` : `(${answer.pointsEarned} pts)`;
        reportHtml += `
            <li>
                <strong>Niveau ${answer.levelIndex + 1} (${answer.type})</strong>: ${answer.question}<br/>
                Votre réponse: <em>${answer.userAnswer}</em><br/>
                Réponse correcte: <em>${answer.correctAnswer}</em><br/>
                Statut: ${status} ${points}
            </li><br/>
        `;
    });
    reportHtml += '</ol>';
    return reportHtml;
}

function showCorrectionReport() {
    const reportContent = document.getElementById('correctionReportContent');
    if (reportContent) { // Added null check
        reportContent.innerHTML = generateCorrectionReport();
    }
    showModal('correctionModal');
}

function copyCorrectionToClipboard() {
    const reportContent = document.getElementById('correctionReportContent');
    let reportText = '';
    if (reportContent) { // Added null check
        reportText = reportContent.innerText;
    }
    
    const textArea = document.createElement("textarea");
    textArea.value = reportText;
    document.body.appendChild(textArea);
    textArea.select();
    try {
        // Use document.execCommand('copy') for better compatibility in iframes
        const successful = document.execCommand('copy');
        const msg = successful ? 'Copié dans le presse-papiers !' : 'Échec de la copie.';
        // Replace alert with a custom message box if desired
        const currentAlert = document.getElementById('customAlert');
        if (currentAlert) currentAlert.remove(); // Remove previous alert

        const customAlert = document.createElement('div');
        customAlert.id = 'customAlert';
        customAlert.style.cssText = `
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: #333; color: white; padding: 15px 30px; border-radius: 10px;
            z-index: 1001; opacity: 0; transition: opacity 0.3s ease-in-out;
            font-size: 1.1rem; text-align: center;
        `;
        customAlert.textContent = msg;
        document.body.appendChild(customAlert);

        setTimeout(() => {
            customAlert.style.opacity = '1';
        }, 10); // Small delay to trigger transition

        setTimeout(() => {
            customAlert.style.opacity = '0';
            customAlert.addEventListener('transitionend', () => customAlert.remove());
        }, 2000); // Message disappears after 2 seconds

    } catch (err) {
        // Fallback for older browsers or if execCommand fails
        alert('Impossible de copier : ' + err);
    }
    document.body.removeChild(textArea);
}

// Render specific levels

// Quiz Level
function renderQuizLevel(level) {
    const quizScreen = document.getElementById('quizScreen');
    if (!quizScreen) return; // Added null check

    // Create a mutable copy of answers with their correct status
    const answersWithStatus = level.answers.map((answer, index) => ({
        text: answer,
        isCorrect: index === level.correct
    }));
    shuffleArray(answersWithStatus); // Shuffle the answers

    quizScreen.innerHTML = `
        <h2 id="questionText">${level.question}</h2>
        <div class="answer-grid">
            ${answersWithStatus.map((answer, index) => `
                <button class="answer-btn" data-original-font-size="20" 
                        data-is-correct="${answer.isCorrect}"
                        onclick="checkQuizAnswer(${index}, ${answer.isCorrect}, ${level.points}, '${answer.text.replace(/'/g, "\\'")}', '${level.type}')">
                    ${answer.text}
                </button>
            `).join('')}
        </div>
    `;
}

// Modified checkQuizAnswer to use isCorrect flag and user's answer text
function checkQuizAnswer(selectedIndex, isCorrectFlag, points, userAnswerText, levelType) {
    stopTimer();
    const buttons = document.querySelectorAll('.answer-btn');
    buttons.forEach((btn, index) => {
        btn.disabled = true;
        // The correct button is the one with the isCorrectFlag true
        if (btn.getAttribute('onclick') && btn.getAttribute('onclick').includes('true')) { // Added null check for getAttribute
            btn.classList.add('correct');
        } else if (index === selectedIndex) {
            btn.classList.add('incorrect');
        }
    });

    const level = gameState.isBonusRound ? gameState.bonusLevelData : gameState.shuffledLevels[gameState.currentLevel];
    let pointsEarned = 0;
    let basePoints = points;

    if (isCorrectFlag) {
        pointsEarned = basePoints;
        if (!gameState.isBonusRound) { // Only apply bonus multiplier for regular questions
            pointsEarned *= gameState.bonusMultiplier; 
        }
        gameState.score += pointsEarned;
        playSound('correct');
        if (gameState.bonusMultiplier > 1 && !gameState.isBonusRound) {
             displayCharacter('🎉', "BONUS ACTIVÉ ! Points doublés !", 2000);
        } else {
            displayCharacter('😊', "Super ! Bonne réponse !", 2000); // Correct message
        }
    } else {
        pointsEarned = -Math.floor(basePoints / 5); // Small penalty for incorrect
        gameState.score = Math.max(0, gameState.score + pointsEarned);
        playSound('incorrect');
        displayCharacter('😟', "Dommage, ce n'est pas ça. Mais continuez d'apprendre !", 2000); // Incorrect message
    }
    
    // Record answer
    gameState.answers.push({
        levelIndex: gameState.currentLevel,
        type: level.type, // Use level.type directly
        question: level.question,
        userAnswer: userAnswerText, // Use the actual text the user clicked
        correctAnswer: getCorrectAnswerForLevel(level), // Get original correct answer
        isCorrect: isCorrectFlag,
        pointsEarned: pointsEarned
    });
    // Update skill score
    gameState.skillScores[level.type].total++;
    if (isCorrectFlag) {
        gameState.skillScores[level.type].correct++;
    }
    
    // Reset bonus multiplier after it's used for a regular question
    if (!gameState.isBonusRound) {
        gameState.bonusMultiplier = 1;
    }

    updateHeader();
    setTimeout(nextLevel, 1500);
}

// Material Level
function renderMaterialLevel(level) {
    const quizScreen = document.getElementById('quizScreen');
    if (!quizScreen) return; // Added null check

    // Create a mutable copy of materials with their correct status and icons
    const materialsWithStatus = level.materials.map((material, index) => ({
        text: material,
        icon: level.icons[index],
        isCorrect: index === level.correct
    }));
    shuffleArray(materialsWithStatus); // Shuffle the materials

    quizScreen.innerHTML = `
        <h2 id="questionText">${level.question}</h2>
        <div class="material-grid">
            ${materialsWithStatus.map((material, index) => `
                <div class="material-card" 
                     data-is-correct="${material.isCorrect}"
                     onclick="checkMaterialAnswer(${index}, ${material.isCorrect}, ${level.points}, '${material.text.replace(/'/g, "\\'")}', '${level.type}')">
                    <span class="material-icon">${material.icon}</span>
                    <span class="material-text">${material.text}</span>
                </div>
            `).join('')}
        </div>
    `;
}

// Modified checkMaterialAnswer to use isCorrect flag and user's answer text
function checkMaterialAnswer(selectedIndex, isCorrectFlag, points, userAnswerText, levelType) {
    stopTimer();
    const cards = document.querySelectorAll('.material-card');
    cards.forEach((card, index) => {
        card.style.pointerEvents = 'none'; // Disable further clicks
        // Find the correct card based on the isCorrectFlag in its onclick attribute
        if (card.getAttribute('onclick') && card.getAttribute('onclick').includes('true')) { // Added null check for getAttribute
            card.classList.add('correct');
        } else if (index === selectedIndex) {
            card.classList.add('incorrect');
        }
    });

    const level = gameState.isBonusRound ? gameState.bonusLevelData : gameState.shuffledLevels[gameState.currentLevel];
    let pointsEarned = 0;
    let basePoints = points;

    if (isCorrectFlag) {
        pointsEarned = basePoints;
        if (!gameState.isBonusRound) { // Only apply bonus multiplier for regular questions
            pointsEarned *= gameState.bonusMultiplier; 
        }
        gameState.score += pointsEarned;
        playSound('correct');
        if (gameState.bonusMultiplier > 1 && !gameState.isBonusRound) {
             displayCharacter('🎉', "BONUS ACTIVÉ ! Points doublés !", 2000);
        } else {
            displayCharacter('😊', "Exact ! Vous avez l'œil pour les matériaux !", 2000); // Correct message
        }
    } else {
        pointsEarned = -Math.floor(basePoints / 5);
        gameState.score = Math.max(0, gameState.score + pointsEarned);
        playSound('incorrect');
        displayCharacter('😟', "Ce n'est pas le bon choix. Réfléchissez bien aux propriétés !", 2000); // Incorrect message
    }

    // Record answer
    gameState.answers.push({
        levelIndex: gameState.currentLevel,
        type: level.type,
        question: level.question,
        userAnswer: userAnswerText,
        correctAnswer: getCorrectAnswerForLevel(level),
        isCorrect: isCorrectFlag,
        pointsEarned: pointsEarned
    });
    // Update skill score
    gameState.skillScores[level.type].total++;
    if (isCorrectFlag) {
        gameState.skillScores[level.type].correct++;
    }

    // Reset bonus multiplier after it's used for a regular question
    if (!gameState.isBonusRound) {
        gameState.bonusMultiplier = 1;
    }

    updateHeader();
    setTimeout(nextLevel, 1500);
}

// Drag and Drop Level
function renderDragLevel(level) {
    const gameScreen = document.getElementById('gameScreen');
    if (!gameScreen) return; // Added null check

    const shuffledItems = [...level.items].sort(() => Math.random() - 0.5); // Shuffle for challenge
    const dropZones = level.items.map((item, index) => `<div class="drop-zone" data-index="${index}"><span class="drop-zone-text">Déposez ici</span></div>`).join('');

    gameScreen.innerHTML = `
        <h2 id="questionText">${level.question}</h2>
        <div style="display: flex; flex-wrap: wrap; justify-content: center; margin-bottom: 30px;">
            ${shuffledItems.map((item, index) => `<div class="draggable" draggable="true" data-item="${item}"><span class="draggable-text">${item}</span></div>`).join('')}
        </div>
        <div style="width: 100%; max-width: 600px;">
            ${dropZones}
        </div>
        <div class="button-center-align"> <!-- Changed to button-center-align -->
            <button class="btn" onclick="checkDragAnswer('${level.items.join(',')}', ${level.points}, '${level.type}')">Valider l'assemblage</button>
        </div>
    `;

    addDragAndDropListeners();
}

function addDragAndDropListeners() {
    const draggables = document.querySelectorAll('.draggable');
    const dropZones = document.querySelectorAll('.drop-zone');
    let draggedItem = null;

    draggables.forEach(draggable => {
        draggable.addEventListener('dragstart', (e) => {
            draggedItem = draggable;
            e.dataTransfer.setData('text/plain', draggable.dataset.item);
            setTimeout(() => draggable.classList.add('hidden'), 0); // Hide original
        });

        draggable.addEventListener('dragend', () => {
            if (draggedItem) { // Added null check
                draggedItem.classList.remove('hidden');
            }
            draggedItem = null;
        });
    });

    dropZones.forEach(zone => {
        zone.addEventListener('dragover', (e) => {
            e.preventDefault(); // Allow drop
            zone.classList.add('hover');
        });

        zone.addEventListener('dragleave', () => {
            zone.classList.remove('hover');
        });

        zone.addEventListener('drop', (e) => {
            e.preventDefault();
            zone.classList.remove('hover');
            if (zone.children.length === 0 || (zone.children.length === 1 && zone.children[0].classList.contains('drop-zone-text'))) { // Only allow one item per zone, or replace placeholder text
                const data = e.dataTransfer.getData('text/plain');
                const item = document.querySelector(`.draggable[data-item="${data}"]`);
                if (item) {
                    // Remove placeholder text if it exists
                    const placeholder = zone.querySelector('.drop-zone-text');
                    if (placeholder) placeholder.remove();

                    zone.appendChild(item);
                    item.style.position = 'static'; // Reset position if it was absolute
                    item.style.margin = '0'; // Reset margin
                    zone.classList.add('filled');
                }
            }
        });
    });
}

function checkDragAnswer(correctOrderString, points, levelType) {
    stopTimer();
    const correctOrder = correctOrderString.split(',');
    const dropZones = document.querySelectorAll('.drop-zone');
    let correctCount = 0;
    let allCorrect = true;
    let userAnswerArray = [];

    dropZones.forEach((zone, index) => {
        const droppedItem = zone.querySelector('.draggable');
        if (droppedItem) {
            userAnswerArray.push(droppedItem.dataset.item);
            if (droppedItem.dataset.item === correctOrder[index]) {
                droppedItem.classList.add('correct');
                zone.style.borderColor = '#4caf50';
                correctCount++;
            } else {
                droppedItem.classList.add('incorrect');
                zone.style.borderColor = '#f44336';
                allCorrect = false;
            }
        } else {
            userAnswerArray.push("Vide"); // Indicate an empty drop zone
            zone.style.borderColor = '#f44336';
            allCorrect = false;
        }
        zone.style.borderStyle = 'solid'; // Make border solid for feedback
    });

    const level = gameState.isBonusRound ? gameState.bonusLevelData : gameState.shuffledLevels[gameState.currentLevel];
    let pointsEarned = 0;
    let basePoints = points;

    if (allCorrect) {
        pointsEarned = basePoints;
        if (!gameState.isBonusRound) { // Only apply bonus multiplier for regular questions
            pointsEarned *= gameState.bonusMultiplier; 
        }
        gameState.score += pointsEarned;
        playSound('correct');
        if (gameState.bonusMultiplier > 1 && !gameState.isBonusRound) {
             displayCharacter('🎉', "BONUS ACTIVÉ ! Points doublés !", 2000);
        } else {
            displayCharacter('😊', "Parfait ! L'assemblage est correct !", 2000); // Correct message
        }
    } else {
        pointsEarned = -Math.floor(basePoints / 2); // Larger penalty for drag/drop
        gameState.score = Math.max(0, gameState.score + pointsEarned);
        playSound('incorrect');
        displayCharacter('😟', "Revoyez l'ordre des couches, c'est important !", 2000); // Incorrect message
    }

    // Record answer
    gameState.answers.push({
        levelIndex: gameState.currentLevel,
        type: level.type,
        question: level.question,
        userAnswer: userAnswerArray.join(' > '),
        correctAnswer: correctOrder.join(' > '),
        isCorrect: allCorrect,
        pointsEarned: pointsEarned
    });
    // Update skill score
    gameState.skillScores[level.type].total++;
    if (allCorrect) {
        gameState.skillScores[level.type].correct++;
    }

    // Reset bonus multiplier after it's used for a regular question
    if (!gameState.isBonusRound) {
        gameState.bonusMultiplier = 1;
    }

    updateHeader();
    document.querySelectorAll('.draggable').forEach(item => item.draggable = false); // Disable further dragging
    const gameScreenBtn = document.getElementById('gameScreen').querySelector('.btn');
    if (gameScreenBtn) { // Added null check
        gameScreenBtn.disabled = true;
    }
    setTimeout(nextLevel, 2000);
}

// Calculation Level
function renderCalcLevel(level) {
    const quizScreen = document.getElementById('quizScreen');
    if (!quizScreen) return; // Added null check

    quizScreen.innerHTML = `
        <h2 id="questionText">${level.question}</h2>
        <input type="number" id="elevationInput" class="elevation-input" placeholder="Entrez votre réponse" step="0.01">
        <div class="button-center-align"> <!-- Changed to button-center-align -->
            <button class="btn" id="validateCalcBtn" onclick="checkCalcAnswer(${level.answer}, ${level.points}, '${level.type}')">Valider</button>
        </div>
    `;
}

function checkCalcAnswer(correctAnswer, points, levelType) {
    stopTimer();
    const input = document.getElementById('elevationInput');
    const validateBtn = document.getElementById('validateCalcBtn');

    let userAnswer = null;
    if (input) { // Added null check
        userAnswer = parseFloat(input.value);
        input.disabled = true;
    }
    if (validateBtn) { // Added null check
        validateBtn.disabled = true;
    }

    const tolerance = 0.01; // Allow for small floating point errors

    const level = gameState.isBonusRound ? gameState.bonusLevelData : gameState.shuffledLevels[gameState.currentLevel];
    let isCorrect = false;
    let pointsEarned = 0;
    let basePoints = points;

    if (userAnswer !== null && Math.abs(userAnswer - correctAnswer) < tolerance) { // Added null check for userAnswer
        isCorrect = true;
        pointsEarned = basePoints;
        if (!gameState.isBonusRound) { // Only apply bonus multiplier for regular questions
            pointsEarned *= gameState.bonusMultiplier; 
        }
        gameState.score += pointsEarned;
        playSound('correct');
        if (gameState.bonusMultiplier > 1 && !gameState.isBonusRound) {
             displayCharacter('🎉', "BONUS ACTIVÉ ! Points doublés !", 2000);
        } else {
            displayCharacter('😊', "Calcul parfait ! Vous maîtrisez les altitudes !", 2000); // Correct message
        }
    } else {
        pointsEarned = -Math.floor(basePoints / 3);
        if (input) { // Added null check
            input.style.borderColor = '#f44336';
            input.style.boxShadow = '0 0 0 3px rgba(244, 67, 54, 0.2)';
        }
        gameState.score = Math.max(0, gameState.score + pointsEarned);
        playSound('incorrect');
        displayCharacter('😟', "Vérifiez vos calculs, la précision est clé en VRD !", 2000); // Incorrect message
    }

    // Record answer
    gameState.answers.push({
        levelIndex: gameState.currentLevel,
        type: level.type,
        question: level.question,
        userAnswer: input ? input.value : "N/A", // Added null check
        correctAnswer: correctAnswer.toFixed(2), // Format correct answer for display
        isCorrect: isCorrect,
        pointsEarned: pointsEarned
    });
    // Update skill score
    gameState.skillScores[level.type].total++;
    if (isCorrect) {
        gameState.skillScores[level.type].correct++;
    }

    // Reset bonus multiplier after it's used for a regular question
    if (!gameState.isBonusRound) {
        gameState.bonusMultiplier = 1;
    }

    updateHeader();
    setTimeout(nextLevel, 1500);
}

// Network Level
function renderNetworkLevel(level) {
    const gameScreen = document.getElementById('gameScreen');
    if (!gameScreen) return; // Added null check

    // Use the nodes from the level data
    const nodes = level.nodes;
    // Use the correctPath from the level data
    const correctPathForRender = level.correctPath || []; // Fallback if not defined

    gameScreen.innerHTML = `
        <h2 id="questionText">${level.question}</h2>
        <svg class="network-svg" viewBox="0 0 500 500">
            <defs>
                <marker id="arrow" markerWidth="10" markerHeight="10" refX="8" refY="3" orient="auto" markerUnits="strokeWidth">
                    <path d="M0,0 L0,6 L9,3 z" fill="#667eea" />
                </marker>
            </defs>
            ${nodes.map(node => `
                <circle class="network-node" id="${node.id}" cx="${node.cx}" cy="${node.cy}" r="15" fill="${node.color}" stroke="white" stroke-width="3" />
            `).join('')}
            <g id="drawnLines"></g>
        </svg>
        <div class="button-center-align"> <!-- Changed to button-center-align -->
            <button class="btn" onclick="checkNetworkAnswer(${level.points}, '${correctPathForRender.join(',')}', '${JSON.stringify(nodes).replace(/'/g, "\\'").replace(/"/g, '&quot;')}', '${level.type}')">Valider le réseau</button>
        </div>
    `;

    addNetworkListeners(nodes);
}

let networkSelectedNodes = [];
let networkDrawing = false;
let networkSvg = null;
let currentLine = null;

function addNetworkListeners(nodes) {
    networkSvg = document.querySelector('.network-svg');
    const drawnLinesGroup = document.getElementById('drawnLines');

    if (!networkSvg || !drawnLinesGroup) return; // Added null checks

    networkSvg.addEventListener('mousedown', (e) => {
        const target = e.target;
        if (target.classList.contains('network-node')) {
            networkDrawing = true;
            networkSelectedNodes = [target.id];
            
            // Start drawing a temporary line
            currentLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
            const startNode = nodes.find(n => n.id === target.id);
            if (startNode) { // Added null check
                currentLine.setAttribute('x1', startNode.cx);
                currentLine.setAttribute('y1', startNode.cy);
            }
            currentLine.setAttribute('x2', e.offsetX);
            currentLine.setAttribute('y2', e.offsetY);
            currentLine.setAttribute('stroke', '#667eea');
            currentLine.setAttribute('stroke-width', '4');
            currentLine.setAttribute('stroke-dasharray', '5,5');
            drawnLinesGroup.appendChild(currentLine);
        }
    });

    networkSvg.addEventListener('mousemove', (e) => {
        if (networkDrawing && currentLine) {
            currentLine.setAttribute('x2', e.offsetX);
            currentLine.setAttribute('y2', e.offsetY);
        }
    });

    networkSvg.addEventListener('mouseup', (e) => {
        if (networkDrawing) {
            networkDrawing = false;
            const target = e.target;
            if (target.classList.contains('network-node') && networkSelectedNodes[0] !== target.id) {
                networkSelectedNodes.push(target.id);
                const startNode = nodes.find(n => n.id === networkSelectedNodes[0]);
                const endNode = nodes.find(n => n.id === networkSelectedNodes[1]);

                // Finalize the line
                if (currentLine && endNode) { // Added null check for currentLine and endNode
                    currentLine.setAttribute('x2', endNode.cx);
                    currentLine.setAttribute('y2', endNode.cy);
                    currentLine.setAttribute('marker-end', 'url(#arrow)'); // Add arrow to the end
                }

                // Reset for next line
                networkSelectedNodes = [];
                currentLine = null;
            } else {
                // If not dropped on another node, remove the temporary line
                if (currentLine) {
                    currentLine.remove();
                }
            }
        }
    });
}


function checkNetworkAnswer(points, correctPathString, nodesJsonString, levelType) {
    stopTimer();
    const correctPath = correctPathString.split(',');
    const drawnLines = document.querySelectorAll('#drawnLines line');
    const nodes = JSON.parse(nodesJsonString.replace(/&quot;/g, '"')); // Parse nodes back from JSON string

    let allCorrect = true;
    let userAnswerPath = [];

    if (drawnLines.length === 1) {
        const line = drawnLines[0];
        const x1 = parseFloat(line.getAttribute('x1'));
        const y1 = parseFloat(line.getAttribute('y1'));
        const x2 = parseFloat(line.getAttribute('x2'));
        const y2 = parseFloat(line.getAttribute('y2'));
        
        let lineStartNodeId = null;
        let lineEndNodeId = null;

        nodes.forEach(node => {
            const nodeCx = node.cx;
            const nodeCy = node.cy;
            const nodeR = 15; // Hardcoded radius from renderNetworkLevel

            // Calculate distance from line endpoints to node center
            const distStartToNode = Math.sqrt(Math.pow(x1 - nodeCx, 2) + Math.pow(y1 - nodeCy, 2));
            const distEndToNode = Math.sqrt(Math.pow(x2 - nodeCx, 2) + Math.pow(y2 - nodeCy, 2));

            if (distStartToNode <= nodeR + 5) { // Add a small tolerance
                lineStartNodeId = node.id;
            }
            if (distEndToNode <= nodeR + 5) { // Add a small tolerance
                lineEndNodeId = node.id;
            }
        });

        if (lineStartNodeId && lineEndNodeId) {
            userAnswerPath.push(lineStartNodeId, lineEndNodeId);
            // Check if the connected nodes match the correct path (order doesn't matter for this simple check)
            const sortedUserPath = [...userAnswerPath].sort().join(',');
            const sortedCorrectPath = [...correctPath].sort().join(',');

            if (sortedUserPath === sortedCorrectPath) {
                allCorrect = true;
            } else {
                allCorrect = false;
            }
        } else {
            allCorrect = false; // Line endpoints not connected to valid nodes
        }
    } else {
        allCorrect = false; // Not exactly one line drawn
    }

    const level = gameState.isBonusRound ? gameState.bonusLevelData : gameState.shuffledLevels[gameState.currentLevel];
    let pointsEarned = 0;
    let basePoints = points;

    if (allCorrect) {
        pointsEarned = basePoints;
        if (!gameState.isBonusRound) { // Only apply bonus multiplier for regular questions
            pointsEarned *= gameState.bonusMultiplier; 
        }
        gameState.score += pointsEarned;
        playSound('correct');
        if (gameState.bonusMultiplier > 1 && !gameState.isBonusRound) {
             displayCharacter('🎉', "BONUS ACTIVÉ ! Points doublés !", 2000);
        } else {
            displayCharacter('😊', "Excellent ! Le réseau est bien tracé !", 2000); // Correct message
        }
        drawnLines.forEach(line => line.setAttribute('stroke', '#4caf50'));
    } else {
        pointsEarned = -Math.floor(basePoints / 2);
        gameState.score = Math.max(0, gameState.score + pointsEarned);
        playSound('incorrect');
        displayCharacter('😟', "Le tracé n'est pas optimal. Essayez à nouveau !", 2000); // Incorrect message
        drawnLines.forEach(line => line.setAttribute('stroke', '#f44336'));
    }

    // Record answer
    gameState.answers.push({
        levelIndex: gameState.currentLevel,
        type: level.type,
        question: level.question,
        userAnswer: userAnswerPath.length > 0 ? userAnswerPath.join(' -> ') : "Aucun tracé",
        correctAnswer: getCorrectAnswerForLevel(level),
        isCorrect: allCorrect,
        pointsEarned: pointsEarned
    });
    // Update skill score
    gameState.skillScores[level.type].total++;
    if (allCorrect) {
        gameState.skillScores[level.type].correct++;
    }

    // Reset bonus multiplier after it's used for a regular question
    if (!gameState.isBonusRound) {
        gameState.bonusMultiplier = 1;
    }

    updateHeader();
    const gameScreenBtn = document.getElementById('gameScreen').querySelector('.btn');
    if (gameScreenBtn) { // Added null check
        gameScreenBtn.disabled = true;
    }
    setTimeout(nextLevel, 2000);
}


// Scenario Level
function renderScenarioLevel(level) {
    const quizScreen = document.getElementById('quizScreen');
    if (!quizScreen) return; // Added null check

    // Create a mutable copy of actions with their correct status
    const actionsWithStatus = level.actions.map((action, index) => ({
        text: action,
        isCorrect: index === level.correct
    }));
    shuffleArray(actionsWithStatus); // Shuffle the actions

    quizScreen.innerHTML = `
        <div class="scenario-alert">
            <div class="scenario-icon">🚨</div>
            <h2 id="questionText">${level.question}</h2>
        </div>
        <div class="answer-grid">
            ${actionsWithStatus.map((action, index) => `
                <button class="answer-btn" data-original-font-size="20" 
                        data-is-correct="${action.isCorrect}"
                        onclick="checkScenarioAnswer(${index}, ${action.isCorrect}, ${level.points}, '${action.text.replace(/'/g, "\\'")}', '${level.type}')">
                    ${action.text}
                </button>
            `).join('')}
        </div>
    `;
}

// Modified checkScenarioAnswer to use isCorrect flag and user's answer text
function checkScenarioAnswer(selectedIndex, isCorrectFlag, points, userAnswerText, levelType) {
    stopTimer();
    const buttons = document.querySelectorAll('.answer-btn');
    buttons.forEach((btn, index) => {
        btn.disabled = true;
        // The correct button is the one with the isCorrectFlag true
        if (btn.getAttribute('onclick') && btn.getAttribute('onclick').includes('true')) { // Added null check for getAttribute
            btn.classList.add('correct');
        } else if (index === selectedIndex) {
            btn.classList.add('incorrect');
        }
    });

    const level = gameState.isBonusRound ? gameState.bonusLevelData : gameState.shuffledLevels[gameState.currentLevel];
    let pointsEarned = 0;
    let basePoints = points;

    if (isCorrectFlag) {
        pointsEarned = basePoints;
        if (!gameState.isBonusRound) { // Only apply bonus multiplier for regular questions
            pointsEarned *= gameState.bonusMultiplier; 
        }
        gameState.score += pointsEarned;
        playSound('correct');
        if (gameState.bonusMultiplier > 1 && !gameState.isBonusRound) {
             displayCharacter('🎉', "BONUS ACTIVÉ ! Points doublés !", 2000);
        } else {
            displayCharacter('😊', "Bonne décision ! La sécurité avant tout.", 2000); // Correct message
        }
    } else {
        pointsEarned = -Math.floor(basePoints / 4);
        gameState.score = Math.max(0, gameState.score + pointsEarned);
        playSound('incorrect');
        displayCharacter('😟', "Attention ! Une mauvaise décision peut avoir des conséquences !", 2000); // Incorrect message
    }

    // Record answer
    gameState.answers.push({
        levelIndex: gameState.currentLevel,
        type: level.type,
        question: level.question,
        userAnswer: userAnswerText,
        correctAnswer: getCorrectAnswerForLevel(level),
        isCorrect: isCorrectFlag,
        pointsEarned: pointsEarned
    });
    // Update skill score
    gameState.skillScores[level.type].total++;
    if (isCorrectFlag) {
        gameState.skillScores[level.type].correct++;
    }

    // Reset bonus multiplier after it's used for a regular question
    if (!gameState.isBonusRound) {
        gameState.bonusMultiplier = 1;
    }

    updateHeader();
    setTimeout(nextLevel, 1500);
}

// New Bonus Level Types

// Conflict Detection Level
function renderConflictDetectionLevel(level) {
    const quizScreen = document.getElementById('quizScreen');
    if (!quizScreen) return; // Added null check

    const optionsWithStatus = level.options.map((option, index) => ({
        text: option,
        isCorrect: index === level.correct
    }));
    shuffleArray(optionsWithStatus);

    quizScreen.innerHTML = `
        <div class="scenario-alert" style="background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);">
            <div class="scenario-icon">⚠️</div>
            <h2 id="questionText" style="color: #333;">${level.question}</h2>
        </div>
        <div class="answer-grid">
            ${optionsWithStatus.map((option, index) => `
                <button class="answer-btn" data-original-font-size="20" 
                        data-is-correct="${option.isCorrect}"
                        onclick="checkConflictDetectionAnswer(${index}, ${option.isCorrect}, ${level.points}, '${option.text.replace(/'/g, "\\'")}', '${level.type}')">
                    ${option.text}
                </button>
            `).join('')}
        </div>
    `;
}

function checkConflictDetectionAnswer(selectedIndex, isCorrectFlag, points, userAnswerText, levelType) {
    stopTimer();
    const buttons = document.querySelectorAll('.answer-btn');
    buttons.forEach((btn, index) => {
        btn.disabled = true;
        if (btn.getAttribute('onclick') && btn.getAttribute('onclick').includes('true')) { // Added null check for getAttribute
            btn.classList.add('correct');
        } else if (index === selectedIndex) {
            btn.classList.add('incorrect');
        }
    });

    const level = gameState.isBonusRound ? gameState.bonusLevelData : gameState.shuffledLevels[gameState.currentLevel];
    let pointsEarned = 0;
    let basePoints = points;

    if (isCorrectFlag) {
        pointsEarned = basePoints;
        // Bonus levels themselves don't get multiplied, they set the multiplier for the *next* regular question
        gameState.score += pointsEarned;
        playSound('correct');
        displayCharacter('✅', "Conflit bien identifié ! Excellente analyse !", 2000);
    } else {
        pointsEarned = -Math.floor(basePoints / 3);
        gameState.score = Math.max(0, gameState.score + pointsEarned);
        playSound('incorrect');
        displayCharacter('❌', "Attention aux détails ! Ce conflit est critique.", 2000);
    }

    gameState.answers.push({
        levelIndex: gameState.currentLevel,
        type: level.type,
        question: level.question,
        userAnswer: userAnswerText,
        correctAnswer: getCorrectAnswerForLevel(level),
        isCorrect: isCorrectFlag,
        pointsEarned: pointsEarned
    });
    gameState.skillScores[level.type].total++;
    if (isCorrectFlag) {
        gameState.skillScores[level.type].correct++;
    }

    // After a bonus round, the bonus multiplier is set for the *next* regular question.
    // We don't reset it here, it will be reset by the next regular loadLevel.

    updateHeader();
    setTimeout(nextLevel, 1500);
}

// Volume Calculation Level
function renderVolumeCalcLevel(level) {
    const quizScreen = document.getElementById('quizScreen');
    if (!quizScreen) return; // Added null check

    quizScreen.innerHTML = `
        <h2 id="questionText">${level.question}</h2>
        <input type="number" id="elevationInput" class="elevation-input" placeholder="Entrez votre réponse (m³)" step="0.01">
        <div class="button-center-align">
            <button class="btn" id="validateCalcBtn" onclick="checkVolumeCalcAnswer(${level.answer}, ${level.points}, '${level.type}')">Valider</button>
        </div>
    `;
}

function checkVolumeCalcAnswer(correctAnswer, points, levelType) {
    stopTimer();
    const input = document.getElementById('elevationInput');
    const validateBtn = document.getElementById('validateCalcBtn');

    let userAnswer = null;
    if (input) { // Added null check
        userAnswer = parseFloat(input.value);
        input.disabled = true;
    }
    if (validateBtn) { // Added null check
        validateBtn.disabled = true;
    }

    const tolerance = 0.01;

    const level = gameState.isBonusRound ? gameState.bonusLevelData : gameState.shuffledLevels[gameState.currentLevel];
    let isCorrect = false;
    let pointsEarned = 0;
    let basePoints = points;

    if (userAnswer !== null && Math.abs(userAnswer - correctAnswer) < tolerance) { // Added null check for userAnswer
        isCorrect = true;
        pointsEarned = basePoints;
        // Bonus levels themselves don't get multiplied, they set the multiplier for the *next* regular question
        gameState.score += pointsEarned;
        playSound('correct');
        displayCharacter('📈', "Calcul de volume précis ! Impressionnant !", 2000);
    } else {
        pointsEarned = -Math.floor(basePoints / 3);
        if (input) { // Added null check
            input.style.borderColor = '#f44336';
            input.style.boxShadow = '0 0 0 3px rgba(244, 67, 54, 0.2)';
        }
        gameState.score = Math.max(0, gameState.score + pointsEarned);
        playSound('incorrect');
        displayCharacter('📉', "Revoyez vos formules de volume. Chaque mètre cube compte !", 2000);
    }

    gameState.answers.push({
        levelIndex: gameState.currentLevel,
        type: level.type,
        question: level.question,
        userAnswer: input ? input.value : "N/A", // Added null check
        correctAnswer: correctAnswer.toFixed(2),
        isCorrect: isCorrect,
        pointsEarned: pointsEarned
    });
    gameState.skillScores[level.type].total++;
    if (isCorrect) {
        gameState.skillScores[level.type].correct++;
    }

    // After a bonus round, the bonus multiplier is set for the *next* regular question.
    // We don't reset it here, it will be reset by the next regular loadLevel.

    updateHeader();
    setTimeout(nextLevel, 1500);
}


// New Pipe Connect Mini-Game Functions
let currentPipeGrid = []; // Stores the state of the grid: { type: 'straight'/'bend'/'t_junction'/'cross', rotation: 0/90/180/270 }
let pipeTrayCounts = {}; // Stores counts of available pipes

// SVG definitions for pipe pieces
function getPipeSVG(type) {
    const strokeWidth = 10;
    const half = 50; // Half of 100px cell size for center
    const quarter = 25; // Quarter for offsets

    switch (type) {
        case 'straight':
            return `<svg viewBox="0 0 100 100"><path d="M${half},0 V100" stroke="currentColor" stroke-width="${strokeWidth}" fill="none" stroke-linecap="round"/></svg>`;
        case 'bend':
            return `<svg viewBox="0 0 100 100"><path d="M0,${half} H${half} V100" stroke="currentColor" stroke-width="${strokeWidth}" fill="none" stroke-linecap="round"/></svg>`;
        case 't_junction':
            return `<svg viewBox="0 0 100 100"><path d="M0,${half} H100 M${half},0 V100" stroke="currentColor" stroke-width="${strokeWidth}" fill="none" stroke-linecap="round"/></svg`;
        case 'cross':
            return `<svg viewBox="0 0 100 100"><path d="M0,${half} H100 M${half},0 V100" stroke="currentColor" stroke-width="${strokeWidth}" fill="none" stroke-linecap="round"/></svg>`;
        default:
            return '';
    }
}

function renderPipeConnectLevel(level) {
    const gameScreen = document.getElementById('gameScreen');
    if (!gameScreen) return;

    gameScreen.innerHTML = `
        <h2 id="questionText">${level.question}</h2>
        <div class="pipe-game-container">
            <div id="pipeTray" class="pipe-tray"></div>
            <div id="pipeGridContainer" class="pipe-grid-container"></div>
            <div class="button-center-align">
                <button class="btn" id="validatePipeConnectBtn" onclick="checkPipeConnectAnswer(${level.points}, ${level.gridSize}, ${level.start.row}, ${level.start.col}, ${level.end.row}, ${level.end.col}, '${level.type}')">Valider le réseau</button>
            </div>
        </div>
    `;

    const pipeTray = document.getElementById('pipeTray');
    const pipeGridContainer = document.getElementById('pipeGridContainer');

    // Initialize grid state with nulls and set up grid display
    currentPipeGrid = Array(level.gridSize).fill(0).map(() => Array(level.gridSize).fill(null));
    pipeGridContainer.style.gridTemplateColumns = `repeat(${level.gridSize}, 100px)`;

    // Render grid cells
    for (let r = 0; r < level.gridSize; r++) {
        for (let c = 0; c < level.gridSize; c++) {
            const cell = document.createElement('div');
            cell.classList.add('grid-cell');
            cell.dataset.row = r;
            cell.dataset.col = c;

            if (r === level.start.row && c === level.start.col) {
                cell.classList.add('start-node');
                cell.textContent = 'Départ';
            } else if (r === level.end.row && c === level.end.col) {
                cell.classList.add('end-node');
                cell.textContent = 'Arrivée';
            }

            cell.addEventListener('dragover', (e) => {
                e.preventDefault(); // Allow drop
                cell.classList.add('hover');
            });
            cell.addEventListener('dragleave', () => cell.classList.remove('hover'));
            cell.addEventListener('drop', (e) => handlePipeDrop(e, cell, level));
            pipeGridContainer.appendChild(cell);
        }
    }

    // Initialize pipe tray
    pipeTrayCounts = {};
    level.availablePieces.forEach(piece => {
        pipeTrayCounts[piece.type] = piece.count;
        createDraggablePipe(piece.type, pipeTray);
    });
}

function createDraggablePipe(type, container) {
    const pieceDiv = document.createElement('div');
    pieceDiv.classList.add('pipe-piece-draggable');
    pieceDiv.draggable = true;
    pieceDiv.dataset.type = type;
    pieceDiv.dataset.rotation = 0; // Initial rotation

    pieceDiv.innerHTML = getPipeSVG(type);

    const countSpan = document.createElement('span');
    countSpan.classList.add('pipe-count');
    countSpan.textContent = pipeTrayCounts[type];
    pieceDiv.appendChild(countSpan);

    pieceDiv.addEventListener('dragstart', (e) => {
        e.dataTransfer.setData('text/plain', JSON.stringify({ type: pieceDiv.dataset.type, rotation: pieceDiv.dataset.rotation }));
        e.dataTransfer.effectAllowed = 'move';
        pieceDiv.classList.add('dragging');
    });

    pieceDiv.addEventListener('dragend', () => {
        pieceDiv.classList.remove('dragging');
    });

    container.appendChild(pieceDiv);
    updatePipeTrayDisplay(); // Update counts
}

function handlePipeDrop(e, targetCell, level) {
    e.preventDefault();
    targetCell.classList.remove('hover');

    if (targetCell.classList.contains('start-node') || targetCell.classList.contains('end-node')) {
        displayCharacter('🚫', "Vous ne pouvez pas placer de tuyau sur les points de départ/arrivée !", 2000);
        return;
    }

    const data = JSON.parse(e.dataTransfer.getData('text/plain'));
    const type = data.type;
    let rotation = parseInt(data.rotation);

    const row = parseInt(targetCell.dataset.row);
    const col = parseInt(targetCell.dataset.col);

    // If there's already a pipe in the cell, remove it and return to tray
    if (currentPipeGrid[row][col]) {
        const existingPipe = currentPipeGrid[row][col];
        pipeTrayCounts[existingPipe.type]++; // Return to tray
        updatePipeTrayDisplay();
        targetCell.innerHTML = ''; // Clear cell
    }

    // Place the new pipe if available
    if (pipeTrayCounts[type] > 0) {
        pipeTrayCounts[type]--;
        currentPipeGrid[row][col] = { type: type, rotation: rotation };

        const pipeDiv = document.createElement('div');
        pipeDiv.classList.add('pipe-piece-placed');
        pipeDiv.innerHTML = getPipeSVG(type);
        pipeDiv.style.transform = `rotate(${rotation}deg)`;
        pipeDiv.dataset.type = type;
        pipeDiv.dataset.rotation = rotation; // Store current rotation

        pipeDiv.addEventListener('click', () => rotatePipe(pipeDiv, row, col));
        targetCell.appendChild(pipeDiv);
        updatePipeTrayDisplay();
    } else {
        displayCharacter('🤔', "Plus de pièces de ce type disponibles dans le plateau !", 2000);
    }
}

function rotatePipe(pipeDiv, row, col) {
    let currentRotation = parseInt(pipeDiv.dataset.rotation);
    currentRotation = (currentRotation + 90) % 360;
    pipeDiv.style.transform = `rotate(${currentRotation}deg)`;
    pipeDiv.dataset.rotation = currentRotation; // Update stored rotation

    if (currentPipeGrid[row][col]) {
        currentPipeGrid[row][col].rotation = currentRotation;
    }
    playSound('buttonClick');
}

function updatePipeTrayDisplay() {
    const pipeTray = document.getElementById('pipeTray');
    if (!pipeTray) return;

    // Clear existing draggables to re-render with updated counts
    pipeTray.innerHTML = ''; 

    for (const type in pipeTrayCounts) {
        if (pipeTrayCounts[type] > 0) {
            const pieceDiv = document.createElement('div');
            pieceDiv.classList.add('pipe-piece-draggable');
            pieceDiv.draggable = true;
            pieceDiv.dataset.type = type;
            pieceDiv.dataset.rotation = 0; // Draggable pieces always start at 0 rotation visually in tray

            pieceDiv.innerHTML = getPipeSVG(type);

            const countSpan = document.createElement('span');
            countSpan.classList.add('pipe-count');
            countSpan.textContent = pipeTrayCounts[type];
            pieceDiv.appendChild(countSpan);

            pieceDiv.addEventListener('dragstart', (e) => {
                e.dataTransfer.setData('text/plain', JSON.stringify({ type: pieceDiv.dataset.type, rotation: pieceDiv.dataset.rotation }));
                e.dataTransfer.effectAllowed = 'move';
                pieceDiv.classList.add('dragging');
            });

            pieceDiv.addEventListener('dragend', () => {
                pieceDiv.classList.remove('dragging');
            });
            pipeTray.appendChild(pieceDiv);
        }
    }
}


// Define connections for each pipe type and rotation
// Each entry maps a rotation to an array of connected sides (0=top, 1=right, 2=bottom, 3=left)
const PIPE_CONNECTIONS = {
    'straight': {
        0: [0, 2], // Vertical: top, bottom
        90: [1, 3], // Horizontal: right, left
        180: [0, 2],
        270: [1, 3]
    },
    'bend': {
        0: [0, 1], // Top-right bend
        90: [1, 2], // Right-bottom bend
        180: [2, 3], // Bottom-left bend
        270: [3, 0]  // Left-top bend
    },
    't_junction': {
        0: [0, 1, 3], // T-up: top, right, left
        90: [0, 1, 2], // T-right: top, right, bottom
        180: [1, 2, 3], // T-down: right, bottom, left
        270: [0, 2, 3]  // T-left: top, bottom, left
    },
    'cross': {
        0: [0, 1, 2, 3] // All sides connected
    }
};

function checkPipeConnectAnswer(points, gridSize, startRow, startCol, endRow, endCol, levelType) {
    stopTimer();
    const validateButton = document.getElementById('validatePipeConnectBtn');
    if (validateButton) validateButton.disabled = true;

    // Clear previous path highlights
    document.querySelectorAll('.grid-cell').forEach(cell => {
        cell.classList.remove('correct-path', 'incorrect-path');
        const pipe = cell.querySelector('.pipe-piece-placed svg');
        if (pipe) {
            pipe.style.fill = '#3b82f6'; // Reset to default blue
            pipe.style.stroke = '#1e40af';
        }
    });

    let isCorrect = false;
    let pointsEarned = 0;
    let basePoints = points;
    let userAnswerPath = "Chemin non trouvé ou incomplet.";

    // Check if all available pieces are used
    let allPiecesUsed = true;
    for (const type in pipeTrayCounts) {
        if (pipeTrayCounts[type] > 0) {
            allPiecesUsed = false;
            break;
        }
    }

    if (!allPiecesUsed) {
        displayCharacter('🤔', "Toutes les pièces ne sont pas utilisées ou le chemin est incomplet !", 3000);
        pointsEarned = -Math.floor(basePoints / 3);
        gameState.score = Math.max(0, gameState.score + pointsEarned);
        playSound('incorrect');
        recordPipeConnectAnswer(levelType, userAnswerPath, false, pointsEarned);
        setTimeout(nextLevel, 2000);
        return;
    }

    // BFS to find a path from start to end
    const queue = [{ r: startRow, c: startCol, path: [`${startRow}-${startCol}`] }];
    const visited = new Set([`${startRow}-${startCol}`]);

    while (queue.length > 0) {
        const { r, c, path } = queue.shift();

        // Check if we reached the end
        if (r === endRow && c === endCol) {
            isCorrect = true;
            userAnswerPath = path.join(' -> ');
            break;
        }

        // Determine outgoing connections from current pipe (or start node)
        let outgoingConnections = [];
        if (r === startRow && c === startCol) {
            // Start node connects to its right (assuming start is always on left edge, facing right)
            // Or, more generally, it connects to the cell (r, c+1) on its right.
            // For a start node at (0,0), it should connect to a pipe at (0,1) that has a 'left' opening.
            // This is a simplification. A more robust start/end node would have explicit "openings".
            // For now, let's assume start has an opening to the right, and end has an opening to the left.
            outgoingConnections = [1]; // Right side (for start node)
        } else {
            const pipe = currentPipeGrid[r][c];
            if (!pipe) continue; // Should not happen if all pieces are used

            outgoingConnections = PIPE_CONNECTIONS[pipe.type][pipe.rotation];
        }

        // Explore neighbors
        const neighbors = [
            { dr: -1, dc: 0, incomingSide: 2, r: r - 1, c: c }, // Top (expecting bottom connection)
            { dr: 0, dc: 1, incomingSide: 3, r: r, c: c + 1 }, // Right (expecting left connection)
            { dr: 1, dc: 0, incomingSide: 0, r: r + 1, c: c }, // Bottom (expecting top connection)
            { dr: 0, dc: -1, incomingSide: 1, r: r, c: c - 1 }  // Left (expecting right connection)
        ];

        neighbors.forEach(neighbor => {
            const nr = neighbor.r;
            const nc = neighbor.c;

            // Check bounds
            if (nr < 0 || nr >= gridSize || nc < 0 || nc >= gridSize) return;

            // Check if already visited
            if (visited.has(`${nr}-${nc}`)) return;

            // Check if current pipe connects to this neighbor
            const currentPipeHasOutgoing = outgoingConnections.includes(neighbor.incomingSide === 0 ? 2 : neighbor.incomingSide === 1 ? 3 : neighbor.incomingSide === 2 ? 0 : 1); // Map incoming to outgoing

            if (!currentPipeHasOutgoing) return;

            // Check if neighbor is the end node
            if (nr === endRow && nc === endCol) {
                // Special check for end node: it must have an opening that connects to the incoming pipe
                // Assuming end node needs an incoming connection from its left (side 3)
                // This needs to be dynamic based on end node position.
                // For now, assume end node is at (3,3) and expects connection from left (side 3) or top (side 0).
                // Simplified: if it's the end node, and we can reach it, it's a valid connection.
                 if (currentPipeHasOutgoing) { // Ensure the pipe leading to end has an opening towards end
                    queue.push({ r: nr, c: nc, path: [...path, `${nr}-${nc}`] });
                    visited.add(`${nr}-${nc}`);
                    return;
                }
            }

            // Check if neighbor cell has a pipe
            const neighborPipe = currentPipeGrid[nr][nc];
            if (!neighborPipe) return;

            // Check if neighbor pipe has an incoming connection from current pipe
            const neighborIncomingConnections = PIPE_CONNECTIONS[neighborPipe.type][neighborPipe.rotation];
            const neighborHasIncoming = neighborIncomingConnections.includes(neighbor.incomingSide);

            if (neighborHasIncoming) {
                queue.push({ r: nr, c: nc, path: [...path, `${nr}-${nc}`] });
                visited.add(`${nr}-${nc}`);
            }
        });
    }

    if (isCorrect) {
        pointsEarned = basePoints;
        if (!gameState.isBonusRound) { // Only apply bonus multiplier for regular questions
            pointsEarned *= gameState.bonusMultiplier; 
        }
        gameState.score += pointsEarned;
        playSound('correct');
        displayCharacter('🎉', "Réseau parfait ! Vous êtes un expert en plomberie VRD !", 2000);
        // Highlight correct path
        userAnswerPath.split(' -> ').forEach(coordStr => {
            const [r, c] = coordStr.split('-').map(Number);
            const cell = document.querySelector(`.grid-cell[data-row="${r}"][data-col="${c}"]`);
            if (cell) {
                cell.classList.add('correct-path');
                const pipe = cell.querySelector('.pipe-piece-placed svg');
                if (pipe) {
                    pipe.style.fill = '#10b981'; // Green fill
                    pipe.style.stroke = '#065f46'; // Darker green stroke
                }
            }
        });
    } else {
        pointsEarned = -Math.floor(basePoints / 2);
        gameState.score = Math.max(0, gameState.score + pointsEarned);
        playSound('incorrect');
        displayCharacter('😟', "Le réseau n'est pas fonctionnel. Vérifiez vos connexions !", 2000);
        // Highlight incorrect path (all placed pipes for this case)
        for (let r = 0; r < gridSize; r++) {
            for (let c = 0; c < gridSize; c++) {
                const cell = document.querySelector(`.grid-cell[data-row="${r}"][data-col="${c}"]`);
                if (cell && currentPipeGrid[r][c]) {
                    cell.classList.add('incorrect-path');
                    const pipe = cell.querySelector('.pipe-piece-placed svg');
                    if (pipe) {
                        pipe.style.fill = '#ef4444'; // Red fill
                        pipe.style.stroke = '#b91c1c'; // Darker red stroke
                    }
                }
            }
        }
    }

    recordPipeConnectAnswer(levelType, userAnswerPath, isCorrect, pointsEarned);
    setTimeout(nextLevel, 2000);
}

function recordPipeConnectAnswer(levelType, userAnswerText, isCorrect, pointsEarned) {
    const level = gameState.isBonusRound ? gameState.bonusLevelData : gameState.shuffledLevels[gameState.currentLevel];
    gameState.answers.push({
        levelIndex: gameState.currentLevel,
        type: level.type,
        question: level.question,
        userAnswer: userAnswerText,
        correctAnswer: getCorrectAnswerForLevel(level),
        isCorrect: isCorrect,
        pointsEarned: pointsEarned
    });
    gameState.skillScores[level.type].total++;
    if (isCorrect) {
        gameState.skillScores[level.type].correct++;
    }
    if (!gameState.isBonusRound) {
        gameState.bonusMultiplier = 1;
    }
    updateHeader();
}


// Font Size Adjustment Functions
function applyFontSize() {
    const root = document.documentElement;
    root.style.fontSize = `${gameState.baseFontSize}px`;

    // Elements that are always expected to be in the DOM or are handled by specific screen rendering
    // and might need scaling.
    const elementsToScale = [
        { selector: 'h1', baseRem: 3.5 }, // For general H1 (final screen)
        { selector: 'h2', baseRem: 2.5 }, // For general H2 (quiz, game, modals)
        { selector: 'p', baseRem: 1.1 }, // For general paragraphs
        { selector: '.answer-btn', baseRem: 1.2 },
        { selector: '.draggable', baseRem: 1.1 },
        { selector: '.drop-zone', baseRem: 1.1 },
        { selector: '.elevation-input', baseRem: 1.8 },
        { selector: '.material-text', baseRem: 1.0 },
        { selector: '.material-icon', baseRem: 4.0 },
        { selector: '#speechBubbleText', baseRem: 1.0 }, // Speech bubble text
        { selector: '.logo span', baseRem: 2.0 }, // Header logo text
        { selector: '.logo-icon', baseRem: 2.2 }, // Header logo icon and home screen logo icon
        { selector: '.header-item', baseRem: 1.7 }, // Header stats
        { selector: '.score-icon', baseRem: 2.0 },
        { selector: '.timer-icon', baseRem: 2.0 },
        { selector: '.progress-fill-chronological', baseRem: 0.8 },
        { selector: '.tips-bar-content', baseRem: 1.0 },
        { selector: '.control-btn', baseRem: 1.7 },
        { selector: '#homeScreen h1', baseRem: 5.5 }, // Home screen specific (updated)
        { selector: '#homeScreen p', baseRem: 1.8 }, // Home screen specific (updated)
        { selector: '#homeScreen .logo-icon', baseRem: 8.0 }, // Home screen specific (updated)
        { selector: '#homeScreen .btn', baseRem: 2.0 }, // Home screen specific (updated)
        { selector: '.home-features', baseRem: 1.2 }, // Home screen specific (updated)
        { selector: '#helpModal h2', baseRem: 1.8 },
        { selector: '#helpModal h3', baseRem: 1.4 },
        { selector: '#helpModal p', baseRem: 1.1 },
        { selector: '#confirmModal h2', baseRem: 1.8 },
        { selector: '#confirmModal p', baseRem: 1.2 },
        { selector: '#correctionModal h2', baseRem: 1.8 },
        { selector: '#correctionModal #correctionReportContent', baseRem: 1.1 },
        { selector: '.scenario-icon', baseRem: 4.0 },
        { selector: '.stat-number', baseRem: 3.2 },
        { selector: '.stat-label', baseRem: 1.1 },
        { selector: '#customAlert', baseRem: 1.1 },
        { selector: '.pipe-piece-draggable', baseRem: 1.0 },
        { selector: '.pipe-count', baseRem: 0.7 },
        { selector: '.grid-cell', baseRem: 1.0 }
    ];

    elementsToScale.forEach(item => {
        document.querySelectorAll(item.selector).forEach(el => {
            if (el) { // Check if the element exists before trying to set style
                el.style.fontSize = `${item.baseRem * (gameState.baseFontSize / 14)}rem`;
            }
        });
    });
}

function increaseFontSize() {
    if (gameState.baseFontSize < 20) { /* Adjusted max font size limit */
        gameState.baseFontSize += 2; // Increase by 2px
        localStorage.setItem('ltdSimFontSize', gameState.baseFontSize);
        applyFontSize();
        playSound('buttonClick');
    }
}

function decreaseFontSize() {
    if (gameState.baseFontSize > 10) { /* Adjusted min font size limit */
        gameState.baseFontSize -= 2; // Decrease by 2px
        localStorage.setItem('ltdSimFontSize', gameState.baseFontSize);
        applyFontSize();
        playSound('buttonClick');
    }
}

// Character and Speech Bubble Functions
function displayCharacter(emoji, message, duration = 3000) {
    const characterDiv = document.getElementById('gameCharacter');
    const speechBubble = document.getElementById('speechBubble');
    const speechBubbleText = document.getElementById('speechBubbleText');

    if (!characterDiv || !speechBubble || !speechBubbleText) return; // Ensure all elements exist

    // Stop any current tip interval
    clearInterval(gameState.characterTipInterval);

    characterDiv.textContent = emoji;
    characterDiv.style.display = 'block';
    speechBubbleText.textContent = message;
    speechBubble.classList.add('active');
    speechBubble.style.display = 'block';
    applyFontSize(); // Re-apply font size to speech bubble text

    // Set a timeout to hide the bubble and potentially restart tips
    setTimeout(() => {
        if (speechBubble) { // Added null check
            speechBubble.classList.remove('active');
        }
        // speechBubble.style.display = 'none'; // Keep hidden until next message
        // characterDiv.style.display = 'none'; // Keep character visible
        // Restart tips after a short delay if game is active
        if (document.getElementById('quizScreen').classList.contains('active') || document.getElementById('gameScreen').classList.contains('active')) {
            startCharacterTips();
        }
    }, duration);
}

function startCharacterTips() {
    // Clear any existing interval to prevent duplicates
    clearInterval(gameState.characterTipInterval); 
    gameState.characterTipInterval = setInterval(() => {
        const tip = gameTips[currentTipIndex];
        displayCharacter('🤔', tip, 5000); // Display tip for 5 seconds
        currentTipIndex = (currentTipIndex + 1) % gameTips.length;
    }, 10000); // Change tip every 10 seconds
}

// Tips Marquee Functions (kept for the bottom bar, though character will also give tips)
function startTipsMarquee() {
    const tipsBarContent = document.getElementById('tipsBarContent');
    if (!tipsBarContent) return; // Ensure element exists

    // Clear any existing animation to reset
    tipsBarContent.style.animation = 'none';
    tipsBarContent.offsetHeight; // Trigger reflow
    tipsBarContent.style.animation = null;

    tipsBarContent.textContent = gameTips[currentTipIndex];
    currentTipIndex = (currentTipIndex + 1) % gameTips.length;

    // Calculate animation duration based on content length to make speed consistent
    const textLength = tipsBarContent.textContent.length;
    const duration = Math.max(10, textLength * 0.15); // Min 10s, 0.15s per character
    tipsBarContent.style.animationDuration = `${duration}s`;

    // Restart animation on completion to cycle tips
    tipsBarContent.onanimationiteration = () => {
        tipsBarContent.textContent = gameTips[currentTipIndex];
        currentTipIndex = (currentTipIndex + 1) % gameTips.length;
        // Re-calculate duration for the new text
        const newTextLength = tipsBarContent.textContent.length;
        const newDuration = Math.max(10, newTextLength * 0.15);
        tipsBarContent.style.animationDuration = `${newDuration}s`;
    };
}

function stopTipsMarquee() {
    const tipsBarContent = document.getElementById('tipsBarContent');
    if (tipsBarContent) {
        tipsBarContent.style.animationPlayState = 'paused';
        tipsBarContent.onanimationiteration = null; // Remove event listener
    }
}

// Confetti effect (from previous versions)
function triggerConfetti() {
    const confettiCount = 100;
    for (let i = 0; i < confettiCount; i++) {
        const confetti = document.createElement('div');
        confetti.classList.add('confetti');
        confetti.style.left = Math.random() * 100 + 'vw';
        confetti.style.backgroundColor = `hsl(${Math.random() * 360}, 100%, 70%)`;
        confetti.style.animationDelay = `${Math.random() * 2}s`;
        document.body.appendChild(confetti);
        confetti.addEventListener('animationend', () => {
            confetti.remove();
        });
    }
}

// New function to check and enable/disable the finish game button
function checkFinishGameButton() {
    const finishGameBtn = document.getElementById('finishGameBtn');
    if (finishGameBtn) {
        if (gameState.score >= 1000) {
            finishGameBtn.disabled = false;
        } else {
            finishGameBtn.disabled = true;
        }
    }
}

// New function to confirm and finish the game early
function confirmFinishGame() {
    if (gameState.score >= 1000) {
        showConfirmModal(
            "Finir le jeu ?", 
            "Vous avez atteint un score de 1000 points ou plus. Voulez-vous terminer le jeu maintenant ?", 
            () => {
                endGame(); // Call endGame if confirmed
            }
        );
    } else {
        displayCharacter('🤔', "Vous devez avoir au moins 1000 points pour finir le jeu plus tôt !", 3000);
        playSound('incorrect');
    }
}


// Initialisation
window.onload = function() {
    // Load saved font size
    const savedFontSize = localStorage.getItem('ltdSimFontSize');
    if (savedFontSize) {
        gameState.baseFontSize = parseInt(savedFontSize);
    }
    applyFontSize(); // Apply initial or saved font size
};

</script>
</body>
</html>
