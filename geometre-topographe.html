<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LTD Simulateur - D√©couvre le m√©tier de g√©om√®tre-topographe</title>
    <script src="https://cdn.jsdelivr.net/npm/tone@14.7.77/build/Tone.min.js"></script>
    <style>
        /* Global styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif; /* Changed to Inter as per instructions */
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            position: relative;
        }

        /* Animated stars background */
        .star {
            position: absolute;
            background: white;
            clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%);
            animation: twinkle 3s infinite;
        }

        @keyframes twinkle {
            0%, 100% { opacity: 0; transform: scale(0.5); }
            50% { opacity: 1; transform: scale(1); }
        }

        .game-container {
            width: 95%; /* Increased width */
            max-width: 1000px; /* Increased max-width */
            background: rgba(255, 255, 255, 0.95);
            border-radius: 30px;
            box-shadow: 0 30px 80px rgba(0, 0, 0, 0.4);
            padding: 40px;
            position: relative;
            animation: bounceIn 0.8s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            max-height: 90vh; /* Limit height to enable scrolling within the container */
            overflow-y: auto; /* Enable vertical scrolling */
            padding-bottom: 80px; /* Add padding for content at the bottom */
        }

        @keyframes bounceIn {
            0% { transform: scale(0.3) rotate(10deg); opacity: 0; }
            50% { transform: scale(1.05) rotate(-5deg); }
            100% { transform: scale(1) rotate(0deg); opacity: 1; }
        }

        .screen {
            display: none;
        }

        .screen.active {
            display: block;
            animation: slideIn 0.5s ease-out;
        }

        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        /* Home screen */
        .home-screen {
            text-align: center;
        }

        .logo {
            font-size: 56px;
            font-weight: bold;
            background: linear-gradient(45deg, #667eea, #764ba2, #f093fb);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 20px;
            animation: float 3s ease-in-out infinite;
            text-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-20px); }
        }

        .mascot {
            width: 150px;
            height: 150px;
            margin: 20px auto;
            background: linear-gradient(135deg, #ffd89b 0%, #19547b 100%);
            border-radius: 50%;
            position: relative;
            animation: wobble 2s ease-in-out infinite;
        }

        .mascot::before, .mascot::after {
            content: 'üëÄ';
            position: absolute;
            font-size: 40px;
            top: 40px;
            left: 50%;
            transform: translateX(-50%);
        }

        .mascot::after {
            content: 'üìê';
            top: 70px;
            font-size: 50px;
        }

        @keyframes wobble {
            0%, 100% { transform: rotate(0deg); }
            25% { transform: rotate(-10deg); }
            75% { transform: rotate(10deg); }
        }

        .tagline {
            font-size: 28px;
            color: #333;
            margin-bottom: 30px;
            animation: typewriter 2s steps(40) 1s forwards;
            overflow: hidden;
            white-space: nowrap;
            border-right: 3px solid #764ba2;
        }

        @keyframes typewriter {
            from { width: 0; }
            to { width: 100%; }
        }

        .start-btn {
            background: linear-gradient(45deg, #f093fb 0%, #f5576c 100%);
            color: white;
            border: none;
            padding: 25px 50px;
            font-size: 24px;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 10px 30px rgba(245, 87, 108, 0.4);
            animation: pulse 2s infinite;
            position: relative;
            overflow: hidden;
        }

        .start-btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.5);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        .start-btn:hover::before {
            width: 300px;
            height: 300px;
        }

        .start-btn:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 15px 40px rgba(245, 87, 108, 0.6);
        }

        /* Progress bar */
        .progress-container {
            margin-bottom: 30px;
        }

        .level-indicator {
            text-align: center;
            font-size: 18px;
            font-weight: bold;
            color: #764ba2;
            margin-bottom: 10px;
        }

        .progress-bar {
            background: #e0e0e0;
            height: 40px;
            border-radius: 20px;
            overflow: hidden;
            position: relative;
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.1);
        }

        .progress-fill {
            background: linear-gradient(45deg, #667eea, #764ba2, #f093fb);
            background-size: 200% 200%;
            animation: gradientShift 3s ease infinite;
            height: 100%;
            width: 0%;
            transition: width 0.5s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 18px;
        }

        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        /* Quiz with animations */
        .question-container {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            padding: 30px;
            border-radius: 20px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            position: relative;
            overflow: hidden;
        }

        .question-container::before {
            content: '‚ùì';
            position: absolute;
            font-size: 100px;
            opacity: 0.1;
            right: -20px;
            top: -20px;
            animation: rotate 20s linear infinite;
        }

        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .question {
            font-size: 22px;
            color: #2c3e50;
            margin-bottom: 25px;
            animation: slideInLeft 0.5s ease-out;
        }

        @keyframes slideInLeft {
            from { transform: translateX(-50px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        .answer {
            background: white;
            padding: 20px 25px;
            margin: 15px 0;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 3px solid transparent;
            position: relative;
            overflow: hidden;
            font-size: 18px;
        }

        .answer::before {
            content: '';
            position: absolute;
            top: 50%;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(102, 126, 234, 0.4), transparent);
            transition: left 0.5s;
        }

        .answer:hover::before {
            left: 100%;
        }

        .answer:hover {
            transform: translateX(10px) scale(1.02);
            border-color: #667eea;
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.3);
        }

        .answer.correct {
            background: linear-gradient(135deg, #d4edda, #a8e6cf);
            border-color: #27ae60;
            animation: correctAnswer 0.6s ease;
        }

        @keyframes correctAnswer {
            0% { transform: scale(1); }
            50% { transform: scale(1.1) rotate(5deg); }
            100% { transform: scale(1) rotate(0deg); }
        }

        .answer.incorrect {
            background: linear-gradient(135deg, #f8d7da, #ff9a9e);
            border-color: #e74c3c;
            animation: shake 0.5s ease-in-out;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-10px); }
            75% { transform: translateX(10px); }
        }

        /* Mini-games */
        .mini-game-container {
            text-align: center;
            padding: 20px;
        }

        .game-title {
            font-size: 28px;
            color: #2c3e50;
            margin-bottom: 20px;
            animation: bounce 1s ease infinite;
            margin-top: 50px; /* Added margin-top to push title below timer/score */
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        /* Theodolite game */
        .theodolite-game {
            position: relative;
            width: 500px;
            height: 500px;
            margin: 20px auto;
            background: radial-gradient(circle, #ecf0f1, #95a5a6);
            border-radius: 50%;
            border: 8px solid #2c3e50;
            overflow: hidden;
            cursor: crosshair;
            box-shadow: 0 20px 50px rgba(0,0,0,0.3);
        }

        .theodolite-lens {
            position: absolute;
            width: 100%;
            height: 100%;
            background: 
                repeating-linear-gradient(0deg, transparent, transparent 49px, rgba(255,255,255,0.1) 49px, rgba(255,255,255,0.1) 50px),
                repeating-linear-gradient(90deg, transparent, transparent 49px, rgba(255,255,255,0.1) 49px, rgba(255,255,255,0.1) 50px);
        }

        .crosshair {
            position: absolute;
            width: 100%;
            height: 100%;
        }

        .crosshair::before,
        .crosshair::after {
            content: '';
            position: absolute;
            background: #e74c3c;
            box-shadow: 0 0 10px rgba(231, 76, 60, 0.5);
        }

        .crosshair::before {
            width: 2px;
            height: 100%;
            left: 50%;
            transform: translateX(-50%);
        }

        .crosshair::after {
            width: 100%;
            height: 2px;
            top: 50%;
            transform: translateY(-50%);
        }

        .target {
            position: absolute;
            width: 40px;
            height: 40px;
            background: radial-gradient(circle, #f39c12, #e67e22);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            animation: targetPulse 1s infinite;
            cursor: pointer;
            box-shadow: 0 0 20px rgba(243, 156, 18, 0.6);
        }

        @keyframes targetPulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); box-shadow: 0 0 20px rgba(243, 156, 18, 0.6); }
            50% { transform: translate(-50%, -50%) scale(1.2); box-shadow: 0 0 30px rgba(243, 156, 18, 0.8); }
        }

        .target.hit {
            animation: targetHit 0.5s ease forwards;
        }

        @keyframes targetHit {
            0% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(2); opacity: 0; }
        }

        /* Surface calculation game */
        .surface-game {
            width: 600px;
            height: 400px;
            margin: 20px auto;
            background: #f8f9fa;
            border: 3px solid #2c3e50;
            border-radius: 20px;
            position: relative;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .surface-grid {
            width: 100%;
            height: 100%;
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            grid-template-rows: repeat(6, 1fr);
            gap: 2px;
            padding: 10px;
        }

        .grid-cell {
            background: #ecf0f1;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .grid-cell:hover {
            background: #bdc3c7;
            transform: scale(1.1);
        }

        .grid-cell.selected {
            background: linear-gradient(135deg, #667eea, #764ba2);
            animation: cellSelect 0.3s ease;
        }

        @keyframes cellSelect {
            0% { transform: scale(1) rotateZ(0deg); }
            50% { transform: scale(1.3) rotateZ(180deg); }
            100% { transform: scale(1) rotateZ(360deg); }
        }

        /* 3D Puzzle game */
        .puzzle-game {
            width: 500px;
            height: 500px;
            margin: 20px auto;
            perspective: 1000px;
            position: relative; /* Added for absolute positioning of pieces */
        }

        .puzzle-piece {
            width: 150px;
            height: 150px;
            position: absolute;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border-radius: 20px;
            cursor: grab; /* Changed to grab */
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 60px;
            color: white;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .puzzle-piece:hover {
            transform: translateZ(50px) rotateX(10deg) rotateY(10deg);
            box-shadow: 0 20px 40px rgba(0,0,0,0.4);
        }

        .puzzle-piece.dragging {
            opacity: 0.8;
            transform: scale(1.1) rotateZ(5deg);
            z-index: 1000;
            cursor: grabbing; /* Changed to grabbing */
        }

        .drop-zone {
            width: 160px;
            height: 160px;
            border: 3px dashed #95a5a6;
            border-radius: 20px;
            position: absolute;
            background: rgba(149, 165, 166, 0.1);
            display: flex; /* Added for centering dropped pieces */
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .drop-zone.active {
            border-color: #27ae60;
            background: rgba(39, 174, 96, 0.2);
            animation: dropZonePulse 0.5s ease infinite;
        }

        @keyframes dropZonePulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        /* Score and effects */
        .score-display {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 28px;
            font-weight: bold;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: scoreGlow 2s ease infinite;
            z-index: 10; /* Ensure it's above other elements */
        }

        @keyframes scoreGlow {
            0%, 100% { filter: drop-shadow(0 0 10px rgba(102, 126, 234, 0.5)); }
            50% { filter: drop-shadow(0 0 20px rgba(118, 75, 162, 0.8)); }
        }

        .combo-display {
            position: absolute;
            top: 60px;
            right: 20px;
            font-size: 20px;
            color: #e74c3c;
            font-weight: bold;
            opacity: 0;
            animation: comboShow 1s ease forwards;
            z-index: 10; /* Ensure it's above other elements */
        }

        @keyframes comboShow {
            0% { opacity: 0; transform: scale(0.5) rotate(-180deg); }
            50% { opacity: 1; transform: scale(1.2) rotate(10deg); }
            100% { opacity: 1; transform: scale(1) rotate(0deg); }
        }

        /* Improved Timer */
        .timer {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 24px;
            font-weight: bold;
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: white;
            padding: 10px 20px;
            border-radius: 50px;
            display: flex;
            align-items: center;
            gap: 10px;
            box-shadow: 0 5px 20px rgba(231, 76, 60, 0.4);
            z-index: 10; /* Ensure it's above other elements */
        }

        .timer.warning {
            animation: timerWarning 0.5s ease infinite;
        }

        @keyframes timerWarning {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        /* Badges and rewards */
        .badge {
            display: inline-block;
            width: 80px;
            height: 80px;
            margin: 10px;
            border-radius: 50%;
            background: linear-gradient(135deg, #f093fb, #f5576c);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 40px;
            color: white;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            animation: badgeAppear 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            position: relative;
        }

        .badge::after {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: radial-gradient(circle, transparent, rgba(255,255,255,0.4));
            animation: badgeShine 2s ease infinite;
        }

        @keyframes badgeAppear {
            0% { transform: scale(0) rotate(180deg); }
            100% { transform: scale(1) rotate(360deg); }
        }

        @keyframes badgeShine {
            0%, 100% { opacity: 0; }
            50% { opacity: 1; }
        }

        /* Particles and effects */
        .particle {
            position: absolute;
            pointer-events: none;
        }

        .confetti {
            width: 10px;
            height: 10px;
            background: #f39c12;
            position: absolute;
            animation: confettiFall 3s ease-out forwards;
        }

        @keyframes confettiFall {
            0% { transform: translateY(-100vh) rotate(0deg); opacity: 1; }
            100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
        }

        .explosion {
            position: absolute;
            width: 100px;
            height: 100px;
            pointer-events: none;
        }

        .explosion-particle {
            position: absolute;
            width: 20px;
            height: 20px;
            background: radial-gradient(circle, #f39c12, #e67e22);
            border-radius: 50%;
            animation: explode 0.8s ease-out forwards;
        }

        @keyframes explode {
            0% { transform: translate(-50%, -50%) scale(0); opacity: 1; }
            100% { transform: translate(var(--x), var(--y)) scale(1); opacity: 0; }
        }

        /* Improved Final Screen */
        .final-screen {
            text-align: center;
            /* No fixed height, allow content to expand */
        }

        .final-title {
            font-size: 36px;
            color: #2c3e50;
            margin-bottom: 20px;
            animation: finalTitleAppear 1s ease-out;
        }

        @keyframes finalTitleAppear {
            0% { transform: scale(0.5) rotate(-10deg); opacity: 0; }
            50% { transform: scale(1.1) rotate(5deg); }
            100% { transform: scale(1) rotate(0deg); opacity: 1; }
        }

        .final-score {
            font-size: 80px;
            font-weight: bold;
            background: linear-gradient(45deg, #667eea, #764ba2, #f093fb);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin: 20px 0;
            animation: finalScorePulse 2s ease infinite;
        }

        @keyframes finalScorePulse {
            0%, 100% { transform: scale(1); filter: drop-shadow(0 0 20px rgba(102, 126, 234, 0.5)); }
            50% { transform: scale(1.1); filter: drop-shadow(0 0 40px rgba(118, 75, 162, 0.8)); }
        }

        .category-scores {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin: 30px 0;
        }

        .category-score {
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            padding: 20px;
            border-radius: 15px;
            border-left: 5px solid;
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .category-score:nth-child(1) { border-color: #3498db; }
        .category-score:nth-child(2) { border-color: #e74c3c; }
        .category-score:nth-child(3) { border-color: #27ae60; }
        .category-score:nth-child(4) { border-color: #f39c12; }
        .category-score:nth-child(5) { border-color: #8e44ad; } /* New color for new category */
        .category-score:nth-child(6) { border-color: #1abc9c; } /* New color for new category */
        .category-score:nth-child(7) { border-color: #e67e22; } /* New color for Coordinates Matching */
        .category-score:nth-child(8) { border-color: #9b59b6; } /* New color for Elevation Calculation */


        .category-score:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .category-score strong {
            font-size: 18px;
            display: block;
            margin-bottom: 10px;
        }

        .category-score p {
            font-size: 24px;
            font-weight: bold;
            color: #2c3e50;
        }

        /* Removed share-buttons, added copy-results-container */
        .copy-results-container {
            margin: 30px 0;
            display: flex;
            justify-content: center;
        }

        .copy-results-btn {
            background: linear-gradient(45deg, #3498db 0%, #2980b9 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 10px 30px rgba(52, 152, 219, 0.4);
            position: relative;
            overflow: hidden;
        }

        .copy-results-btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        .copy-results-btn:hover::before {
            width: 300px;
            height: 300px;
        }

        .copy-results-btn:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 15px 40px rgba(52, 152, 219, 0.6);
        }

        .apply-btn {
            background: linear-gradient(45deg, #27ae60, #2ecc71);
            color: white;
            border: none;
            padding: 25px 50px;
            font-size: 20px;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-block;
            box-shadow: 0 10px 30px rgba(46, 204, 113, 0.4);
            position: relative;
            overflow: hidden;
        }

        .apply-btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        .apply-btn:hover::before {
            width: 400px;
            height: 400px;
        }

        .apply-btn:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 15px 40px rgba(46, 204, 113, 0.6);
        }

        /* Floating instructions */
        .floating-instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px 30px;
            border-radius: 50px;
            font-size: 16px;
            animation: floatInstructions 3s ease-in-out infinite;
            z-index: 10;
        }

        @keyframes floatInstructions {
            0%, 100% { transform: translateX(-50%) translateY(0); }
            50% { transform: translateX(-50%) translateY(-10px); }
        }

        /* Visual sounds */
        .sound-wave {
            position: absolute;
            width: 50px;
            height: 50px;
            border: 3px solid #f39c12;
            border-radius: 50%;
            pointer-events: none;
            animation: soundWave 1s ease-out forwards;
        }

        @keyframes soundWave {
            0% { transform: scale(0); opacity: 1; }
            100% { transform: scale(3); opacity: 0; }
        }

        @keyframes fadeInOut {
            0% { opacity: 0; transform: translateY(20px); }
            20% { opacity: 1; transform: translateY(0); }
            80% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-20px); }
        }

        /* Responsive */
        @media (max-width: 768px) {
            .game-container {
                width: 95%;
                padding: 20px;
                max-height: 95vh; /* Adjust for smaller screens */
            }
            
            .theodolite-game,
            .surface-game,
            .puzzle-game,
            .map-reading-game, 
            .distance-calculation-game,
            .coordinates-matching-game, /* Added for responsiveness */
            .elevation-calculation-game { /* Added for responsiveness */
                width: 100%;
                height: 300px;
            }
            
            .category-scores {
                grid-template-columns: 1fr;
            }

            .logo {
                font-size: 40px;
            }

            .tagline {
                font-size: 22px;
            }

            .start-btn {
                padding: 15px 30px;
                font-size: 20px;
            }
        }

        /* Reset button specific styles */
        .reset-btn {
            background: linear-gradient(45deg, #e74c3c 0%, #c0392b 100%);
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 16px;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(192, 57, 43, 0.4);
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            display: none; /* Hidden by default */
        }

        .reset-btn:hover {
            transform: translateX(-50%) translateY(-3px) scale(1.05);
            box-shadow: 0 8px 20px rgba(192, 57, 43, 0.6);
        }

        /* New mini-game specific styles */
        .map-reading-game {
            width: 600px;
            height: 400px;
            margin: 20px auto;
            border: 3px solid #2c3e50;
            border-radius: 20px;
            background: #f8f9fa;
            position: relative;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            cursor: crosshair;
        }

        .map-target {
            position: absolute;
            width: 20px;
            height: 20px;
            background: radial-gradient(circle, #3498db, #2980b9);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            animation: targetPulse 1s infinite;
            pointer-events: none; /* Make it non-clickable directly */
        }

        .distance-calculation-game {
            text-align: center;
            padding: 20px;
        }

        .coordinates-display {
            font-size: 24px;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 20px;
        }

        .distance-input {
            padding: 10px 15px;
            font-size: 18px;
            border-radius: 10px;
            border: 2px solid #ccc;
            text-align: center;
            margin-bottom: 20px;
            width: 150px;
        }

        .distance-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 8px rgba(102, 126, 234, 0.4);
        }

        /* Coordinates Matching Game */
        .coordinates-matching-game {
            width: 600px;
            height: 400px;
            margin: 20px auto;
            border: 3px solid #2c3e50;
            border-radius: 20px;
            background: #f8f9fa;
            position: relative;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .coord-point {
            position: absolute;
            width: 25px;
            height: 25px;
            background: #e67e22;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            cursor: pointer;
            border: 2px solid #d35400;
            box-shadow: 0 0 10px rgba(230, 126, 34, 0.5);
            transition: all 0.2s ease;
        }

        .coord-point:hover {
            transform: translate(-50%, -50%) scale(1.2);
            box-shadow: 0 0 15px rgba(230, 126, 34, 0.8);
        }

        .coord-label {
            position: absolute;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 14px;
            transform: translate(-50%, -120%);
            white-space: nowrap;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .coord-point:hover .coord-label {
            opacity: 1;
        }

        /* Elevation Calculation Game */
        .elevation-calculation-game {
            text-align: center;
            padding: 20px;
        }

        .elevation-diagram {
            width: 80%;
            max-width: 500px;
            height: 200px;
            background: linear-gradient(to right, #a8e6cf, #d4edda);
            border: 2px solid #27ae60;
            border-radius: 15px;
            margin: 20px auto;
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: flex-end;
            justify-content: space-around;
            padding-bottom: 10px;
        }

        .elevation-point {
            width: 20px;
            height: 20px;
            background: #27ae60;
            border-radius: 50%;
            position: absolute;
            bottom: 8px; /* Adjust to sit on the "ground" */
            transform: translateX(-50%);
            border: 2px solid #1a8f4b;
            box-shadow: 0 0 8px rgba(39, 174, 96, 0.6);
        }

        .elevation-label {
            position: absolute;
            font-size: 14px;
            font-weight: bold;
            color: #2c3e50;
            bottom: 35px; /* Position above the point */
            transform: translateX(-50%);
            white-space: nowrap;
        }

        .elevation-input {
            padding: 10px 15px;
            font-size: 18px;
            border-radius: 10px;
            border: 2px solid #ccc;
            text-align: center;
            margin-top: 20px;
            width: 180px;
        }

        .elevation-input:focus {
            outline: none;
            border-color: #27ae60;
            box-shadow: 0 0 8px rgba(39, 174, 96, 0.4);
        }

        /* Styles for corrections and course links sections */
        #correctionsContainer, #courseLinksContainer {
            background: #f0f4f8;
            padding: 25px;
            border-radius: 20px;
            margin-bottom: 25px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.08);
            border: 1px solid #e0e0e0;
        }

        #correctionsContainer h3, #courseLinksContainer h3 {
            font-size: 24px;
            color: #2c3e50;
            margin-bottom: 20px;
            border-bottom: 2px solid #764ba2;
            padding-bottom: 10px;
        }

        #correctionsContainer p, #courseLinksContainer p {
            font-size: 16px;
            color: #555;
            line-height: 1.6;
        }

        #correctionsContainer div {
            margin-bottom: 15px;
            padding: 15px;
            border: 1px solid #dcdcdc;
            border-radius: 10px;
            background-color: #ffffff;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }

        #correctionsContainer strong {
            color: #333;
        }

        #correctionsContainer span.correct {
            color: #27ae60;
            font-weight: bold;
        }

        #correctionsContainer span.incorrect {
            color: #e74c3c;
            font-weight: bold;
        }

        #courseLinksContainer ul {
            list-style: none;
            padding: 0;
        }

        #courseLinksContainer li {
            margin-bottom: 10px;
            padding-left: 25px;
            position: relative;
        }

        #courseLinksContainer li::before {
            content: 'üìö';
            position: absolute;
            left: 0;
            top: 0;
            font-size: 18px;
        }

        #courseLinksContainer a {
            color: #3498db;
            text-decoration: none;
            font-weight: bold;
            transition: color 0.3s ease;
        }

        #courseLinksContainer a:hover {
            color: #2980b9;
            text-decoration: underline;
        }

        /* New buttons for skip/help */
        .game-controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 20px;
        }

        .game-control-btn {
            background: linear-gradient(45deg, #3498db, #2980b9);
            color: white;
            border: none;
            padding: 12px 25px;
            font-size: 16px;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(52, 152, 219, 0.4);
        }

        .game-control-btn.help {
            background: linear-gradient(45deg, #f1c40f, #f39c12);
            box-shadow: 0 5px 15px rgba(241, 196, 15, 0.4);
        }

        .game-control-btn.skip {
            background: linear-gradient(45deg, #95a5a6, #7f8c8d);
            box-shadow: 0 5px 15px rgba(149, 165, 166, 0.4);
        }

        .game-control-btn:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 8px 20px rgba(52, 152, 219, 0.6);
        }

        .game-control-btn.help:hover {
            box-shadow: 0 8px 20px rgba(243, 156, 18, 0.6);
        }

        .game-control-btn.skip:hover {
            box-shadow: 0 8px 20px rgba(127, 140, 141, 0.6);
        }

        .correction-skipped {
            background-color: #fcf8e3 !important; /* Light yellow for skipped */
            border-color: #8a6d3b !important;
        }
        .correction-helped {
            background-color: #d9edf7 !important; /* Light blue for helped */
            border-color: #31708f !important;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="score-display" style="display: none;">Score: <span id="score">0</span></div>
        <div class="combo-display" id="comboDisplay" style="display: none;">COMBO x<span id="combo">1</span>!</div>
        <div class="timer" id="timer" style="display: none;">‚è±Ô∏è <span id="timerValue">30</span>s</div>
        <button class="reset-btn" id="resetBtn">R√©initialiser le jeu</button> <!-- Reset button added -->

        <!-- Home Screen -->
        <div class="screen home-screen active" id="homeScreen">
            <h1 class="logo">LTD SIMULATEUR</h1>
            <div class="mascot"></div>
            <p class="tagline">üéØ D√©couvre le m√©tier de g√©om√®tre-topographe</p>
            <p style="color: #7f8c8d; margin-bottom: 30px; font-size: 18px;">
                üéÆ 7 mini-jeux fun ‚Ä¢ üèÜ D√©fis pro ‚Ä¢ üöÄ Animations √©piques
            </p>
            <button class="start-btn" id="startBtn">
                <span>Commencer l'aventure</span>
            </button>
        </div>

        <!-- Level Select Screen (Quiz) -->
        <div class="screen level-select-screen" id="levelSelectScreen">
            <h2 class="game-title">üéÆ Choisis ton d√©fi !</h2>
            <div class="progress-container">
                <div class="level-indicator">Niveau <span id="currentLevel">1</span> / <span id="totalLevels">5</span></div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressBarFill">0%</div>
                </div>
            </div>
            <div class="question-container">
                <p class="question" id="questionText"></p>
                <div id="answersContainer">
                    <!-- Answers will be dynamically loaded here -->
                </div>
            </div>
            <div class="floating-instructions" id="quizInstructions">Clique sur la bonne r√©ponse !</div>
            <div class="game-controls">
                <button class="game-control-btn help" id="quizHelpBtn">Aide (p√©nalit√©)</button>
                <button class="game-control-btn skip" id="quizSkipBtn">Passer (p√©nalit√©)</button>
            </div>
        </div>

        <!-- Theodolite Game Screen -->
        <div class="screen theodolite-screen" id="theodoliteScreen">
            <h2 class="game-title">üéØ Th√©odolite : Vise juste !</h2>
            <p style="color: #555; margin-bottom: 20px;">Clique sur les cibles pour les mesurer.</p>
            <div class="theodolite-game" id="theodoliteGameArea">
                <div class="theodolite-lens"></div>
                <div class="crosshair"></div>
                <!-- Targets will be dynamically added here -->
            </div>
            <div class="floating-instructions" id="theodoliteInstructions">Vise et clique sur les cibles !</div>
            <div class="game-controls">
                <button class="game-control-btn help" id="theodoliteHelpBtn">Aide (p√©nalit√©)</button>
                <button class="game-control-btn skip" id="theodoliteSkipBtn">Passer (p√©nalit√©)</button>
            </div>
        </div>

        <!-- Surface Calculation Game Screen -->
        <div class="screen surface-screen" id="surfaceScreen">
            <h2 class="game-title">üìê Calcul de Surface : D√©limite le terrain !</h2>
            <p style="color: #555; margin-bottom: 20px;">S√©lectionne les bonnes cellules pour former la surface demand√©e.</p>
            <div class="surface-game" id="surfaceGameArea">
                <div class="surface-grid" id="surfaceGrid">
                    <!-- Grid cells will be dynamically added here -->
                </div>
            </div>
            <p style="font-size: 20px; font-weight: bold; margin-top: 20px;">Surface √† trouver : <span id="targetSurface"></span> cellules</p>
            <button class="start-btn" id="checkSurfaceBtn" style="margin-top: 20px; padding: 15px 30px; font-size: 18px;">V√©rifier la surface</button>
            <div class="floating-instructions" id="surfaceInstructions">Clique pour s√©lectionner les cellules.</div>
            <div class="game-controls">
                <button class="game-control-btn help" id="surfaceHelpBtn">Aide (p√©nalit√©)</button>
                <button class="game-control-btn skip" id="surfaceSkipBtn">Passer (p√©nalit√©)</button>
            </div>
        </div>

        <!-- 3D Puzzle Game Screen -->
        <div class="screen puzzle-screen" id="puzzleScreen">
            <h2 class="game-title">üß© Puzzle 3D : Reconstruis le b√¢timent !</h2>
            <p style="color: #555; margin-bottom: 20px;">Fais glisser les pi√®ces dans les zones de d√©p√¥t correspondantes.</p>
            <div class="puzzle-game" id="puzzleGameArea">
                <!-- Puzzle pieces and drop zones will be dynamically added here -->
            </div>
            <div class="floating-instructions" id="puzzleInstructions">Glisse et d√©pose les pi√®ces.</div>
            <div class="game-controls">
                <button class="game-control-btn help" id="puzzleHelpBtn">Aide (p√©nalit√©)</button>
                <button class="game-control-btn skip" id="puzzleSkipBtn">Passer (p√©nalit√©)</button>
            </div>
        </div>

        <!-- Map Reading Game Screen -->
        <div class="screen map-reading-screen" id="mapReadingScreen">
            <h2 class="game-title">üó∫Ô∏è Lecture de Carte : Trouve le point !</h2>
            <p style="color: #555; margin-bottom: 20px;">Clique sur la carte pour localiser le point cible.</p>
            <div class="map-reading-game" id="mapReadingGameArea">
                <div class="map-target" id="mapTarget"></div>
            </div>
            <div class="floating-instructions" id="mapReadingInstructions">Clique le plus pr√®s possible du point clignotant !</div>
            <div class="game-controls">
                <button class="game-control-btn help" id="mapReadingHelpBtn">Aide (p√©nalit√©)</button>
                <button class="game-control-btn skip" id="mapReadingSkipBtn">Passer (p√©nalit√©)</button>
            </div>
        </div>

        <!-- Distance Calculation Game Screen -->
        <div class="screen distance-calculation-screen" id="distanceCalculationScreen">
            <h2 class="game-title">üìè Calcul de Distance : Pr√©cision requise !</h2>
            <p style="color: #555; margin-bottom: 20px;">Calcule la distance euclidienne entre ces deux points.</p>
            <div class="coordinates-display">
                Point A: (<span id="pointA_x"></span>, <span id="pointA_y"></span>)<br>
                Point B: (<span id="pointB_x"></span>, <span id="pointB_y"></span>)
            </div>
            <input type="number" step="0.01" class="distance-input" id="distanceInput" placeholder="Distance">
            <button class="start-btn" id="checkDistanceBtn" style="padding: 15px 30px; font-size: 18px;">V√©rifier la distance</button>
            <div class="floating-instructions" id="distanceCalculationInstructions">Entre la distance calcul√©e.</div>
            <div class="game-controls">
                <button class="game-control-btn help" id="distanceCalculationHelpBtn">Aide (p√©nalit√©)</button>
                <button class="game-control-btn skip" id="distanceCalculationSkipBtn">Passer (p√©nalit√©)</button>
            </div>
        </div>

        <!-- Coordinates Matching Game Screen -->
        <div class="screen coordinates-matching-screen" id="coordinatesMatchingScreen">
            <h2 class="game-title">üìç Association de Coordonn√©es : Relie les points !</h2>
            <p style="color: #555; margin-bottom: 20px;">Clique sur les points pour les associer √† leurs coordonn√©es correspondantes.</p>
            <div class="coordinates-matching-game" id="coordinatesMatchingGameArea">
                <!-- Points and labels will be dynamically added here -->
            </div>
            <div class="floating-instructions" id="coordinatesMatchingInstructions">Clique sur un point puis sur sa coordonn√©e.</div>
            <div class="game-controls">
                <button class="game-control-btn help" id="coordinatesMatchingHelpBtn">Aide (p√©nalit√©)</button>
                <button class="game-control-btn skip" id="coordinatesMatchingSkipBtn">Passer (p√©nalit√©)</button>
            </div>
        </div>

        <!-- Elevation Calculation Game Screen -->
        <div class="screen elevation-calculation-screen" id="elevationCalculationScreen">
            <h2 class="game-title">‚õ∞Ô∏è Calcul d'Altitude : Trouve le niveau !</h2>
            <p style="color: #555; margin-bottom: 20px;">Calcule l'altitude du point C en utilisant les altitudes de A et B.</p>
            <div class="elevation-diagram" id="elevationDiagram">
                <div class="elevation-point" id="elevationPointA" style="left: 20%;"></div>
                <span class="elevation-label" id="elevationLabelA" style="left: 20%;">A: <span id="elevationValueA"></span>m</span>
                <div class="elevation-point" id="elevationPointB" style="left: 80%;"></div>
                <span class="elevation-label" id="elevationLabelB" style="left: 80%;">B: <span id="elevationValueB"></span>m</span>
                <div class="elevation-point" id="elevationPointC" style="left: 50%;"></div>
                <span class="elevation-label" id="elevationLabelC" style="left: 50%;">C: ?</span>
            </div>
            <input type="number" step="0.1" class="elevation-input" id="elevationInput" placeholder="Altitude de C">
            <button class="start-btn" id="checkElevationBtn" style="padding: 15px 30px; font-size: 18px;">V√©rifier l'altitude</button>
            <div class="floating-instructions" id="elevationCalculationInstructions">Calcule et entre l'altitude de C.</div>
            <div class="game-controls">
                <button class="game-control-btn help" id="elevationCalculationHelpBtn">Aide (p√©nalit√©)</button>
                <button class="game-control-btn skip" id="elevationCalculationSkipBtn">Passer (p√©nalit√©)</button>
            </div>
        </div>


        <!-- Final Screen -->
        <div class="screen final-screen" id="finalScreen">
            <h2 class="final-title">üéâ Aventure termin√©e !</h2>
            <p class="final-score">Ton Score Final: <span id="finalScore">0</span></p>
            <div class="category-scores">
                <div class="category-score">
                    <strong>Connaissances G√©n√©rales</strong>
                    <p id="quizScore">0</p>
                </div>
                <div class="category-score">
                    <strong>Pr√©cision (Th√©odolite)</strong>
                    <p id="theodoliteScore">0</p>
                </div>
                <div class="category-score">
                    <strong>Logique Spatiale (Surface)</strong>
                    <p id="surfaceScore">0</p>
                </div>
                <div class="category-score">
                    <strong>Assemblage (Puzzle 3D)</strong>
                    <p id="puzzleScore">0</p>
                </div>
                <div class="category-score">
                    <strong>Lecture de Carte</strong>
                    <p id="mapReadingScore">0</p>
                </div>
                <div class="category-score">
                    <strong>Calcul de Distance</strong>
                    <p id="distanceCalculationScore">0</p>
                </div>
                <div class="category-score">
                    <strong>Association de Coordonn√©es</strong>
                    <p id="coordinatesMatchingScore">0</p>
                </div>
                <div class="category-score">
                    <strong>Calcul d'Altitude</strong>
                    <p id="elevationCalculationScore">0</p>
                </div>
            </div>
            
            <!-- New Copy Results Button -->
            <div class="copy-results-container">
                <button class="copy-results-btn" id="copyResultsBtn">Copier les r√©sultats pour un recruteur</button>
            </div>
            <!-- Hidden div to hold the text to be copied -->
            <div id="resultsToCopy" style="position: absolute; left: -9999px; top: -9999px;"></div>


            <div id="correctionsContainer" style="margin-top: 40px; text-align: left;">
                <!-- Corrections will be displayed here -->
            </div>
            <div id="courseLinksContainer" style="margin-top: 30px; text-align: left;">
                <!-- Course links will be displayed here -->
            </div>

            <a href="https://www.google.com/search?q=m%C3%A9tier+g%C3%A9om%C3%A8tre-topographe" target="_blank" class="apply-btn" style="margin-top: 40px;">
                <span>En savoir plus sur le m√©tier</span>
            </a>
            <button class="start-btn" id="restartBtn" style="margin-top: 30px; background: linear-gradient(45deg, #3498db, #2980b9);">
                <span>Rejouer</span>
            </button>
        </div>
    </div>

    <script>
        // Global game variables
        let score = 0;
        let combo = 0;
        let currentScreen = 'homeScreen';
        let currentLevel = 0;
        let gameTimer;
        let timeLeft;
        let quizScores = 0;
        let theodoliteScores = 0;
        let surfaceScores = 0;
        let puzzleScores = 0;
        let mapReadingScores = 0;
        let distanceCalculationScores = 0;
        let coordinatesMatchingScores = 0; // New score category
        let elevationCalculationScores = 0; // New score category
        let audioContextStarted = false; // Flag to ensure Tone.start() is called once

        // New array to store results of each played segment
        let gameResults = []; // Will store objects like { type: 'quiz', question: '...', correct: '...', user: '...', isCorrect: true/false, category: '...' } or { type: 'mini-game', name: '...', isCorrect: true/false, details: '...', category: '...' }


        // Sound effects using Tone.js
        const synth = new Tone.Synth().toDestination();
        const correctSound = new Tone.MembraneSynth().toDestination();
        const incorrectSound = new Tone.NoiseSynth({
            noise: { type: 'pink' },
            envelope: { attack: 0.005, decay: 0.1, sustain: 0 }
        }).toDestination();
        const clickSound = new Tone.PluckSynth().toDestination();
        const winSound = new Tone.PolySynth(Tone.Synth, {
            oscillator: { type: "triangle" },
            envelope: { attack: 0.005, decay: 0.1, sustain: 0.05, release: 0.1 }
        }).toDestination();
        const loseSound = new Tone.PolySynth(Tone.Synth, {
            oscillator: { type: "sine" },
            envelope: { attack: 0.005, decay: 0.1, sustain: 0.05, release: 0.1 }
        }).toDestination();
        const timerWarningSound = new Tone.MetalSynth().toDestination();

        // New sound for general button presses
        const buttonPressSound = new Tone.Synth({
            oscillator: { type: "sine" },
            envelope: { attack: 0.001, decay: 0.05, sustain: 0, release: 0.05 }
        }).toDestination();


        // Game data
        const quizQuestions = [
            {
                question: "Quel est le r√¥le principal d'un g√©om√®tre-topographe ?",
                answers: ["Concevoir des b√¢timents", "Mesurer et d√©limiter des terrains", "Vendre des biens immobiliers", "G√©rer des chantiers de construction"],
                correct: 1,
                category: "Connaissances G√©n√©rales"
            },
            {
                question: "Quel instrument est utilis√© pour mesurer les angles horizontaux et verticaux ?",
                answers: ["Le niveau optique", "Le GPS", "Le th√©odolite", "Le m√®tre ruban"],
                correct: 2,
                category: "Connaissances G√©n√©rales"
            },
            {
                question: "Qu'est-ce qu'un plan cadastral ?",
                answers: ["Un plan de construction", "Un document qui identifie les propri√©t√©s fonci√®res", "Une carte routi√®re", "Un plan d'urbanisme"],
                correct: 1,
                category: "Connaissances G√©n√©rales"
            },
            {
                question: "Quelle est l'unit√© de mesure principale utilis√©e en topographie pour les distances ?",
                answers: ["Le kilom√®tre", "Le centim√®tre", "Le m√®tre", "Le millim√®tre"],
                correct: 2,
                category: "Connaissances G√©n√©rales"
            },
            {
                question: "Quel est le but du bornage d'un terrain ?",
                answers: ["D√©corer le terrain", "Marquer physiquement les limites d'une propri√©t√©", "Estimer la valeur du terrain", "Pr√©parer le terrain pour la construction"],
                correct: 1,
                category: "Connaissances G√©n√©rales"
            },
            // New Quiz Questions
            {
                question: "Quelle est la science de la mesure de la Terre et de sa repr√©sentation ?",
                answers: ["La g√©ologie", "La cartographie", "La topographie", "L'astronomie"],
                correct: 2,
                category: "Connaissances G√©n√©rales"
            },
            {
                question: "Quel type de carte est utilis√© pour montrer les variations d'altitude du terrain ?",
                answers: ["Carte routi√®re", "Carte politique", "Carte topographique", "Carte climatique"],
                correct: 2,
                category: "Connaissances G√©n√©rales"
            },
            {
                question: "Qu'est-ce qu'un nivellement ?",
                answers: ["Mesurer des angles", "D√©terminer les diff√©rences d'altitude", "Calculer des surfaces", "Dessiner des plans"],
                correct: 1,
                category: "Connaissances G√©n√©rales"
            },
            {
                question: "Quel est l'objectif d'un lev√© topographique ?",
                answers: ["Cr√©er des mod√®les 3D de b√¢timents", "Repr√©senter fid√®lement le terrain et ses d√©tails", "Concevoir des r√©seaux de transport", "Analyser la composition du sol"],
                correct: 1,
                category: "Connaissances G√©n√©rales"
            },
            {
                question: "Qu'est-ce qu'une courbe de niveau sur une carte topographique ?",
                answers: ["Une ligne indiquant la limite d'une propri√©t√©", "Une ligne reliant des points de m√™me altitude", "Une ligne repr√©sentant un chemin", "Une ligne de d√©marcation entre deux zones climatiques"],
                correct: 1,
                category: "Connaissances G√©n√©rales"
            },
            {
                question: "Quel √©quipement est utilis√© pour la mesure de tr√®s grandes distances avec pr√©cision ?",
                answers: ["Le t√©l√©m√®tre laser", "Le d√©cam√®tre", "Le GPS diff√©rentiel", "Le niveau √† bulle"],
                correct: 2,
                category: "Connaissances G√©n√©rales"
            }
        ];

        const miniGames = [
            { name: "theodolite", category: "Pr√©cision (Th√©odolite)" },
            { name: "surface", category: "Logique Spatiale (Surface)" },
            { name: "puzzle", category: "Assemblage (Puzzle 3D)" },
            { name: "mapReading", category: "Lecture de Carte" },
            { name: "distanceCalculation", category: "Calcul de Distance" },
            { name: "coordinatesMatching", category: "Association de Coordonn√©es" }, // New mini-game
            { name: "elevationCalculation", category: "Calcul d'Altitude" } // New mini-game
        ];

        // Course links data (placeholders)
        const courseLinks = {
            "Connaissances G√©n√©rales": "https://www.geometre-expert.fr/le-metier/formation-et-carrieres",
            "Pr√©cision (Th√©odolite)": "https://fr.wikipedia.org/wiki/Th%C3%A9odolite",
            "Logique Spatiale (Surface)": "https://fr.wikipedia.org/wiki/Calcul_de_surface",
            "Assemblage (Puzzle 3D)": "https://fr.wikipedia.org/wiki/Mod%C3%A9lisation_3D",
            "Lecture de Carte": "https://fr.wikipedia.org/wiki/Cartographie",
            "Calcul de Distance": "https://fr.wikipedia.org/wiki/Distance_euclidienne",
            "Association de Coordonn√©es": "https://fr.wikipedia.org/wiki/Syst%C3%A8me_de_coordonn%C3%A9es_g%C3%A9ographiques",
            "Calcul d'Altitude": "https://fr.wikipedia.org/wiki/Altim%C3%A9trie"
        };


        let gameSequence = []; // Will hold quiz questions and mini-game identifiers
        let currentSequenceIndex = 0;

        // DOM elements
        const homeScreen = document.getElementById('homeScreen');
        const levelSelectScreen = document.getElementById('levelSelectScreen');
        const theodoliteScreen = document.getElementById('theodoliteScreen');
        const surfaceScreen = document.getElementById('surfaceScreen');
        const puzzleScreen = document.getElementById('puzzleScreen');
        const mapReadingScreen = document.getElementById('mapReadingScreen');
        const distanceCalculationScreen = document.getElementById('distanceCalculationScreen');
        const coordinatesMatchingScreen = document.getElementById('coordinatesMatchingScreen'); // New screen
        const elevationCalculationScreen = document.getElementById('elevationCalculationScreen'); // New screen
        const finalScreen = document.getElementById('finalScreen');

        const startBtn = document.getElementById('startBtn');
        const restartBtn = document.getElementById('restartBtn');
        const resetBtn = document.getElementById('resetBtn'); // Get the new reset button
        const scoreDisplay = document.querySelector('.score-display');
        const scoreSpan = document.getElementById('score');
        const comboDisplay = document.getElementById('comboDisplay');
        const comboSpan = document.getElementById('combo');
        const timerDisplay = document.getElementById('timer');
        const timerValueSpan = document.getElementById('timerValue');

        const currentLevelSpan = document.getElementById('currentLevel');
        const totalLevelsSpan = document.getElementById('totalLevels');
        const progressBarFill = document.getElementById('progressBarFill');
        const questionText = document.getElementById('questionText');
        const answersContainer = document.getElementById('answersContainer');
        const quizInstructions = document.getElementById('quizInstructions');

        const theodoliteGameArea = document.getElementById('theodoliteGameArea');
        const theodoliteInstructions = document.getElementById('theodoliteInstructions');
        let theodoliteTargetsHit = 0;
        let totalTheodoliteTargets = 0;

        const surfaceGameArea = document.getElementById('surfaceGameArea');
        const surfaceGrid = document.getElementById('surfaceGrid');
        const targetSurfaceSpan = document.getElementById('targetSurface');
        const checkSurfaceBtn = document.getElementById('checkSurfaceBtn');
        const surfaceInstructions = document.getElementById('surfaceInstructions');
        let selectedSurfaceCells = 0;
        let requiredSurfaceCells = 0;

        const puzzleGameArea = document.getElementById('puzzleGameArea');
        const puzzleInstructions = document.getElementById('puzzleInstructions');
        let puzzlePieces = [];
        let dropZones = [];
        let correctDrops = 0;

        const mapReadingGameArea = document.getElementById('mapReadingGameArea');
        const mapTarget = document.getElementById('mapTarget');
        const mapReadingInstructions = document.getElementById('mapReadingInstructions');
        let mapTargetPos = { x: 0, y: 0 };
        let mapAttempts = 0;
        const maxMapAttempts = 3;

        const pointA_x = document.getElementById('pointA_x');
        const pointA_y = document.getElementById('pointA_y');
        const pointB_x = document.getElementById('pointB_x');
        const pointB_y = document.getElementById('pointB_y');
        const distanceInput = document.getElementById('distanceInput');
        const checkDistanceBtn = document.getElementById('checkDistanceBtn');
        const distanceCalculationInstructions = document.getElementById('distanceCalculationInstructions');
        let trueDistance = 0;

        const coordinatesMatchingGameArea = document.getElementById('coordinatesMatchingGameArea'); // New DOM element
        const coordinatesMatchingInstructions = document.getElementById('coordinatesMatchingInstructions'); // New DOM element
        let currentSelectedPoint = null;
        let matchedPairs = 0;
        let totalPairs = 0;
        let currentCoordinatesData = []; // To store the generated points and labels for correction

        const elevationDiagram = document.getElementById('elevationDiagram'); // New DOM element
        const elevationValueA = document.getElementById('elevationValueA'); // New DOM element
        const elevationValueB = document.getElementById('elevationValueB'); // New DOM element
        const elevationInput = document.getElementById('elevationInput'); // New DOM element
        const checkElevationBtn = document.getElementById('checkElevationBtn'); // New DOM element
        const elevationCalculationInstructions = document.getElementById('elevationCalculationInstructions'); // New DOM element
        let trueElevationC = 0;


        const finalScoreSpan = document.getElementById('finalScore');
        const quizScoreSpan = document.getElementById('quizScore');
        const theodoliteScoreSpan = document.getElementById('theodoliteScore');
        const surfaceScoreSpan = document.getElementById('surfaceScore');
        const puzzleScoreSpan = document.getElementById('puzzleScore');
        const mapReadingScoreSpan = document.getElementById('mapReadingScore'); // Display rounded score
        const distanceCalculationScoreSpan = document.getElementById('distanceCalculationScore');
        const coordinatesMatchingScoreSpan = document.getElementById('coordinatesMatchingScore'); // New score span
        const elevationCalculationScoreSpan = document.getElementById('elevationCalculationScore'); // New score span

        const correctionsContainer = document.getElementById('correctionsContainer'); // New DOM element
        const courseLinksContainer = document.getElementById('courseLinksContainer'); // New DOM element
        const copyResultsBtn = document.getElementById('copyResultsBtn'); // New button
        const resultsToCopyDiv = document.getElementById('resultsToCopy'); // Hidden div for copy


        // New buttons
        const quizHelpBtn = document.getElementById('quizHelpBtn');
        const quizSkipBtn = document.getElementById('quizSkipBtn');
        const theodoliteHelpBtn = document.getElementById('theodoliteHelpBtn');
        const theodoliteSkipBtn = document.getElementById('theodoliteSkipBtn');
        const surfaceHelpBtn = document.getElementById('surfaceHelpBtn');
        const surfaceSkipBtn = document.getElementById('surfaceSkipBtn');
        const puzzleHelpBtn = document.getElementById('puzzleHelpBtn');
        const puzzleSkipBtn = document.getElementById('puzzleSkipBtn');
        mapReadingHelpBtn.addEventListener('click', showHelp);
        mapReadingSkipBtn.addEventListener('click', skipCurrentGame);
        distanceCalculationHelpBtn.addEventListener('click', showHelp);
        distanceCalculationSkipBtn.addEventListener('click', skipCurrentGame);
        coordinatesMatchingHelpBtn.addEventListener('click', showHelp);
        coordinatesMatchingSkipBtn.addEventListener('click', skipCurrentGame);
        elevationCalculationHelpBtn.addEventListener('click', showHelp);
        elevationCalculationSkipBtn.addEventListener('click', skipCurrentGame);


        // --- Utility Functions ---

        /**
         * Shows a specific screen and hides others.
         * @param {HTMLElement} screenToShow - The screen element to make active.
         */
        function showScreen(screenToShow) {
            const screens = document.querySelectorAll('.screen');
            screens.forEach(screen => screen.classList.remove('active'));
            screenToShow.classList.add('active');
            currentScreen = screenToShow.id;

            // Hide/show score, timer, and reset button based on screen
            if (screenToShow === homeScreen || screenToShow === finalScreen) {
                scoreDisplay.style.display = 'none';
                timerDisplay.style.display = 'none';
                comboDisplay.style.display = 'none';
                resetBtn.style.display = 'none'; // Hide reset button on home/final screen
            } else {
                scoreDisplay.style.display = 'block';
                timerDisplay.style.display = 'flex';
                resetBtn.style.display = 'block'; // Show reset button during gameplay
            }

            // Hide all instructions initially, then show specific ones
            document.querySelectorAll('.floating-instructions').forEach(inst => inst.style.display = 'none');
            if (screenToShow === levelSelectScreen) quizInstructions.style.display = 'block';
            if (screenToShow === theodoliteScreen) theodoliteInstructions.style.display = 'block';
            if (screenToShow === surfaceScreen) surfaceInstructions.style.display = 'block';
            if (screenToShow === puzzleScreen) puzzleInstructions.style.display = 'block';
            if (screenToShow === mapReadingScreen) mapReadingInstructions.style.display = 'block';
            if (screenToShow === distanceCalculationScreen) distanceCalculationInstructions.style.display = 'block';
            if (screenToShow === coordinatesMatchingScreen) coordinatesMatchingInstructions.style.display = 'block'; // Show for new game
            if (screenToShow === elevationCalculationScreen) elevationCalculationInstructions.style.display = 'block'; // Show for new game
        }

        /**
         * Creates a visual particle effect (explosion) at a given position.
         * @param {number} x - X coordinate.
         * @param {number} y - Y coordinate.
         * @param {string} color - CSS color for particles.
         */
        function createExplosion(x, y, color = '#f39c12') {
            const explosionDiv = document.createElement('div');
            explosionDiv.className = 'explosion';
            explosionDiv.style.left = `${x}px`;
            explosionDiv.style.top = `${y}px`;
            document.body.appendChild(explosionDiv);

            for (let i = 0; i < 10; i++) {
                const particle = document.createElement('div');
                particle.className = 'explosion-particle';
                particle.style.background = color;
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * 50 + 20;
                const endX = Math.cos(angle) * distance;
                const endY = Math.sin(angle) * distance;
                particle.style.setProperty('--x', `${endX}px`);
                particle.style.setProperty('--y', `${endY}px`);
                explosionDiv.appendChild(particle);
            }

            explosionDiv.addEventListener('animationend', () => explosionDiv.remove());
        }

        /**
         * Creates a confetti effect.
         */
        function createConfetti() {
            for (let i = 0; i < 50; i++) {
                const confetti = document.createElement('div');
                confetti.className = 'confetti';
                confetti.style.left = `${Math.random() * 100}vw`;
                confetti.style.top = `${Math.random() * 100}vh`;
                confetti.style.background = `hsl(${Math.random() * 360}, 70%, 60%)`;
                confetti.style.animationDelay = `${Math.random() * 2}s`;
                document.body.appendChild(confetti);
                confetti.addEventListener('animationend', () => confetti.remove());
            }
        }

        /**
         * Creates a sound wave animation.
         * @param {number} x - X coordinate.
         * @param {number} y - Y coordinate.
         */
        function createSoundWave(x, y) {
            const wave = document.createElement('div');
            wave.className = 'sound-wave';
            wave.style.left = `${x}px`;
            wave.style.top = `${y}px`;
            document.body.appendChild(wave);
            wave.addEventListener('animationend', () => wave.remove());
        }

        /**
         * Updates the score and combo display.
         * @param {number} points - Points to add.
         * @param {boolean} isCorrect - True if the action was correct.
         */
        function updateScore(points, isCorrect) {
            if (isCorrect) {
                combo++;
                score += points * combo;
                comboDisplay.style.display = 'block';
                comboSpan.textContent = combo;
                comboDisplay.style.animation = 'none'; // Reset animation
                void comboDisplay.offsetWidth; // Trigger reflow
                comboDisplay.style.animation = 'comboShow 1s ease forwards';
                // Schedule sound slightly in the future to avoid timing issues
                if (Tone.context.state === 'running') {
                    Tone.Transport.scheduleOnce(() => correctSound.triggerAttackRelease("C4", "8n"), Tone.now() + 0.01);
                }
            } else {
                combo = 0;
                comboDisplay.style.display = 'none';
                // Schedule sound slightly in the future to avoid timing issues
                if (Tone.context.state === 'running') {
                    Tone.Transport.scheduleOnce(() => incorrectSound.triggerAttackRelease("8n"), Tone.now() + 0.01);
                }
            }
            scoreSpan.textContent = score;
        }

        /**
         * Starts the game timer.
         * @param {number} duration - Duration in seconds.
         * @param {Function} onTimeUp - Callback function when time runs out.
         */
        function startTimer(duration, onTimeUp) {
            clearInterval(gameTimer);
            timeLeft = duration;
            timerValueSpan.textContent = timeLeft;
            timerDisplay.classList.remove('warning');

            gameTimer = setInterval(() => {
                timeLeft--;
                timerValueSpan.textContent = timeLeft;
                if (timeLeft <= 10 && timeLeft > 0) {
                    timerDisplay.classList.add('warning');
                    if (Tone.context.state === 'running') {
                        Tone.Transport.scheduleOnce(() => timerWarningSound.triggerAttackRelease("C2", "16n"), Tone.now() + 0.01);
                    }
                } else if (timeLeft <= 0) {
                    clearInterval(gameTimer);
                    timerDisplay.classList.remove('warning');
                    onTimeUp();
                }
            }, 1000);
        }

        /**
         * Stops the game timer.
         */
        function stopTimer() {
            clearInterval(gameTimer);
            timerDisplay.classList.remove('warning');
        }

        // --- Game Initialization ---

        /**
         * Initializes the game sequence (quiz questions and mini-games).
         */
        function initializeGameSequence() {
            gameSequence = [];
            
            // Shuffle quizzes and mini-games separately
            const shuffledQuizzes = [...quizQuestions].sort(() => Math.random() - 0.5);
            const shuffledMiniGames = [...miniGames].sort(() => Math.random() - 0.5);

            let quizIndex = 0;
            let miniGameIndex = 0;

            // Alternate between quiz and mini-game
            while (quizIndex < shuffledQuizzes.length || miniGameIndex < shuffledMiniGames.length) {
                if (quizIndex < shuffledQuizzes.length) {
                    gameSequence.push({ type: 'quiz', data: shuffledQuizzes[quizIndex] });
                    quizIndex++;
                }
                if (miniGameIndex < shuffledMiniGames.length) {
                    const miniGameData = shuffledMiniGames[miniGameIndex];
                    gameSequence.push({ type: 'mini-game', name: miniGameData.name, category: miniGameData.category });
                    miniGameIndex++;
                }
            }

            totalLevelsSpan.textContent = gameSequence.length;
        }

        /**
         * Starts the game, resets scores, and shows the first level.
         */
        async function startGame() { // Made async to await Tone.start()
            // Start Tone.js audio context on first user interaction
            if (!audioContextStarted) {
                await Tone.start();
                audioContextStarted = true;
                console.log('AudioContext started');
            }

            // Play a sound when the game starts
            if (Tone.context.state === 'running') {
                Tone.Transport.scheduleOnce(() => buttonPressSound.triggerAttackRelease("C5", "8n"), Tone.now());
            }

            score = 0;
            combo = 0;
            quizScores = 0;
            theodoliteScores = 0;
            surfaceScores = 0;
            puzzleScores = 0;
            mapReadingScores = 0; // Reset new score category
            distanceCalculationScores = 0; // Reset new score category
            coordinatesMatchingScores = 0; // Reset new score category
            elevationCalculationScores = 0; // Reset new score category
            currentSequenceIndex = 0;
            scoreSpan.textContent = score;
            comboDisplay.style.display = 'none';
            gameResults = []; // Reset results for a new game
            initializeGameSequence();
            showNextLevel();
        }

        /**
         * Proceeds to the next level/game in the sequence.
         */
        function showNextLevel() {
            if (currentSequenceIndex < gameSequence.length) {
                currentLevel = currentSequenceIndex + 1;
                currentLevelSpan.textContent = currentLevel;
                updateProgressBar();
                const nextItem = gameSequence[currentSequenceIndex];

                // Disable all game control buttons before showing next level
                document.querySelectorAll('.game-control-btn').forEach(btn => btn.style.display = 'none');


                if (nextItem.type === 'quiz') {
                    showScreen(levelSelectScreen);
                    loadQuestion(nextItem.data);
                    startTimer(30, () => handleQuizTimeout(nextItem.data));
                    quizHelpBtn.style.display = 'inline-block';
                    quizSkipBtn.style.display = 'inline-block';
                } else if (nextItem.type === 'mini-game') {
                    if (nextItem.name === 'theodolite') {
                        showScreen(theodoliteScreen);
                        startTheodoliteGame();
                        startTimer(45, endTheodoliteGame);
                        theodoliteHelpBtn.style.display = 'inline-block';
                        theodoliteSkipBtn.style.display = 'inline-block';
                    } else if (nextItem.name === 'surface') {
                        showScreen(surfaceScreen);
                        startSurfaceGame();
                        startTimer(60, endSurfaceGame);
                        surfaceHelpBtn.style.display = 'inline-block';
                        surfaceSkipBtn.style.display = 'inline-block';
                    } else if (nextItem.name === 'puzzle') {
                        showScreen(puzzleScreen);
                        startPuzzleGame();
                        startTimer(90, endPuzzleGame);
                        puzzleHelpBtn.style.display = 'inline-block';
                        puzzleSkipBtn.style.display = 'inline-block';
                    } else if (nextItem.name === 'mapReading') {
                        showScreen(mapReadingScreen);
                        startMapReadingGame();
                        startTimer(40, endMapReadingGame);
                        mapReadingHelpBtn.style.display = 'inline-block';
                        mapReadingSkipBtn.style.display = 'inline-block';
                    } else if (nextItem.name === 'distanceCalculation') {
                        showScreen(distanceCalculationScreen);
                        startDistanceCalculationGame();
                        startTimer(50, endDistanceCalculationGame);
                        distanceCalculationHelpBtn.style.display = 'inline-block';
                        distanceCalculationSkipBtn.style.display = 'inline-block';
                    } else if (nextItem.name === 'coordinatesMatching') { // New mini-game
                        showScreen(coordinatesMatchingScreen);
                        startCoordinatesMatchingGame();
                        startTimer(60, endCoordinatesMatchingGame);
                        coordinatesMatchingHelpBtn.style.display = 'inline-block';
                        coordinatesMatchingSkipBtn.style.display = 'inline-block';
                    } else if (nextItem.name === 'elevationCalculation') { // New mini-game
                        showScreen(elevationCalculationScreen);
                        startElevationCalculationGame();
                        startTimer(70, endElevationCalculationGame);
                        elevationCalculationHelpBtn.style.display = 'inline-block';
                        elevationCalculationSkipBtn.style.display = 'inline-block';
                    }
                }
            } else {
                endGame();
            }
        }

        /**
         * Updates the progress bar visually.
         */
        function updateProgressBar() {
            const progress = (currentSequenceIndex / gameSequence.length) * 100;
            progressBarFill.style.width = `${progress}%`;
            progressBarFill.textContent = `${Math.round(progress)}%`;
        }

        // --- Skip/Help Logic ---
        function skipCurrentGame() {
            stopTimer();
            const currentItem = gameSequence[currentSequenceIndex];
            updateScore(-200, false); // Penalty for skipping

            if (currentItem.type === 'quiz') {
                gameResults.push({
                    type: 'quiz',
                    question: currentItem.data.question,
                    correctAnswer: currentItem.data.answers[currentItem.data.correct],
                    userAnswer: "Question pass√©e",
                    isCorrect: false,
                    skipped: true,
                    category: currentItem.data.category
                });
            } else if (currentItem.type === 'mini-game') {
                let correctionDetails = `Ce mini-jeu a √©t√© pass√©.`;
                if (currentItem.name === 'theodolite') {
                    correctionDetails = `Le th√©odolite n'a pas √©t√© utilis√©. La solution √©tait de viser toutes les cibles.`;
                } else if (currentItem.name === 'surface') {
                    correctionDetails = `La surface n'a pas √©t√© calcul√©e. La surface correcte √©tait de ${requiredSurfaceCells} cellules.`;
                } else if (currentItem.name === 'puzzle') {
                    correctionDetails = `Le puzzle n'a pas √©t√© compl√©t√©. La solution √©tait de placer toutes les pi√®ces dans leurs zones correspondantes.`;
                } else if (currentItem.name === 'mapReading') {
                    correctionDetails = `Le point sur la carte n'a pas √©t√© localis√©. Le point cible √©tait √† (${Math.round(mapTargetPos.x)}, ${Math.round(mapTargetPos.y)}) pixels.`;
                } else if (currentItem.name === 'distanceCalculation') {
                    correctionDetails = `La distance n'a pas √©t√© calcul√©e. La distance correcte entre les points √©tait de ${trueDistance.toFixed(2)} unit√©s.`;
                } else if (currentItem.name === 'coordinatesMatching') {
                    correctionDetails = `Les coordonn√©es n'ont pas √©t√© associ√©es. Paires correctes : ${currentCoordinatesData.map(p => `${p.label}`).join(', ')}.`;
                } else if (currentItem.name === 'elevationCalculation') {
                    correctionDetails = `L'altitude n'a pas √©t√© calcul√©e. L'altitude correcte du point C √©tait de ${trueElevationC.toFixed(1)} m√®tres.`;
                }

                gameResults.push({
                    type: 'mini-game',
                    name: currentItem.name,
                    isCorrect: false,
                    skipped: true,
                    details: `Mini-jeu pass√©.`,
                    correction: correctionDetails,
                    category: currentItem.category
                });
            }
            currentSequenceIndex++;
            showNextLevel();
        }

        function showHelp() {
            stopTimer();
            const currentItem = gameSequence[currentSequenceIndex];
            updateScore(-150, false); // Penalty for using help

            if (currentItem.type === 'quiz') {
                const correctAns = currentItem.data.answers[currentItem.data.correct];
                const allAnswers = answersContainer.querySelectorAll('.answer');
                allAnswers.forEach(answer => {
                    answer.style.pointerEvents = 'none';
                    if (parseInt(answer.dataset.index) === currentItem.data.correct) {
                        answer.classList.add('correct'); // Highlight correct answer
                    }
                });
                gameResults.push({
                    type: 'quiz',
                    question: currentItem.data.question,
                    correctAnswer: correctAns,
                    userAnswer: "R√©ponse donn√©e par l'aide",
                    isCorrect: true, // Marked as correct because solution was provided
                    helped: true,
                    details: `La bonne r√©ponse a √©t√© affich√©e.`, // Added details for quiz help
                    correction: `La bonne r√©ponse √©tait : ${correctAns}.`, // Added correction for quiz help
                    category: currentItem.data.category
                });
                quizScores++; // Still count as correct for category score
                setTimeout(() => {
                    currentSequenceIndex++;
                    showNextLevel();
                }, 2000);
            } else if (currentItem.type === 'mini-game') {
                // For mini-games, "help" means completing it successfully with penalty
                let details = `Mini-jeu r√©solu avec l'aide.`;
                let correction = `Solution fournie.`;
                let isSuccess = true;

                if (currentItem.name === 'theodolite') {
                    theodoliteTargetsHit = totalTheodoliteTargets; // Complete all targets
                    theodoliteScores++;
                    details = `Toutes les cibles du th√©odolite ont √©t√© mesur√©es avec l'aide.`;
                    correction = `Toutes les cibles ont √©t√© mesur√©es.`;
                    // Visual update for Theodolite
                    theodoliteGameArea.querySelectorAll('.target').forEach(target => {
                        if (!target.classList.contains('hit')) {
                            target.classList.add('hit');
                            // Simulate hitting the target visually
                            createExplosion(target.getBoundingClientRect().x + target.offsetWidth / 2,
                                            target.getBoundingClientRect().y + target.offsetHeight / 2, '#f39c12');
                            createSoundWave(target.getBoundingClientRect().x + target.offsetWidth / 2,
                                            target.getBoundingClientRect().y + target.offsetHeight / 2);
                            target.addEventListener('animationend', () => target.remove());
                        }
                    });
                } else if (currentItem.name === 'surface') {
                    selectedSurfaceCells = requiredSurfaceCells; // Select correct number of cells
                    surfaceScores++;
                    details = `La surface correcte de ${requiredSurfaceCells} cellules a √©t√© trouv√©e avec l'aide.`;
                    correction = `La surface correcte √©tait de ${requiredSurfaceCells} cellules.`;
                    // Visual update for Surface
                    const cells = Array.from(surfaceGrid.querySelectorAll('.grid-cell'));
                    cells.forEach(cell => cell.classList.remove('selected')); // Clear current selection
                    for (let i = 0; i < requiredSurfaceCells; i++) {
                        let randomCell;
                        do {
                            randomCell = cells[Math.floor(Math.random() * cells.length)];
                        } while (randomCell.classList.contains('selected'));
                        randomCell.classList.add('selected');
                        randomCell.style.animation = 'cellSelect 0.3s ease';
                    }
                    surfaceGrid.querySelectorAll('.grid-cell').forEach(cell => cell.style.pointerEvents = 'none');
                    checkSurfaceBtn.disabled = true;

                } else if (currentItem.name === 'puzzle') {
                    correctDrops = puzzlePieces.length; // Complete all drops
                    puzzleScores++;
                    details = `Toutes les pi√®ces du puzzle ont √©t√© plac√©es avec l'aide.`;
                    correction = `Toutes les pi√®ces ont √©t√© correctement assembl√©es.`;
                    // Visual update for Puzzle
                    puzzlePieces.forEach(piece => {
                        if (piece.parentElement.classList.contains('drop-zone')) return; // Already placed
                        const targetGridX = parseInt(piece.dataset.targetGridX);
                        const targetGridY = parseInt(piece.dataset.targetGridY);
                        const targetDropZone = dropZones.find(zone =>
                            parseInt(zone.dataset.gridX) === targetGridX && parseInt(zone.dataset.gridY) === targetGridY
                        );
                        if (targetDropZone) {
                            piece.style.position = 'static';
                            piece.style.transform = 'none';
                            piece.draggable = false;
                            targetDropZone.appendChild(piece);
                            targetDropZone.style.border = '3px solid #27ae60';
                            targetDropZone.style.background = 'rgba(39, 174, 96, 0.4)';
                        }
                    });
                } else if (currentItem.name === 'mapReading') {
                    mapReadingScores = 1; // Mark as successful hit
                    details = `Le point sur la carte a √©t√© localis√© avec l'aide.`;
                    correction = `Le point cible √©tait √† (${Math.round(mapTargetPos.x)}, ${Math.round(mapTargetPos.y)}) pixels.`;
                    // Visual update for Map Reading
                    mapTarget.style.display = 'block'; // Ensure target is visible
                    createExplosion(mapReadingGameArea.getBoundingClientRect().left + mapTargetPos.x,
                                    mapReadingGameArea.getBoundingClientRect().top + mapTargetPos.y, '#3498db');
                } else if (currentItem.name === 'distanceCalculation') {
                    distanceCalculationScores = 1;
                    details = `La distance correcte (${trueDistance.toFixed(2)}) a √©t√© fournie avec l'aide.`;
                    correction = `La distance correcte entre les points √©tait de ${trueDistance.toFixed(2)} unit√©s.`;
                    // Visual update for Distance Calculation
                    distanceInput.value = trueDistance.toFixed(2);
                    distanceInput.disabled = true;
                    checkDistanceBtn.disabled = true;
                } else if (currentItem.name === 'coordinatesMatching') {
                    matchedPairs = totalPairs;
                    coordinatesMatchingScores++;
                    details = `Toutes les paires de coordonn√©es ont √©t√© associ√©es avec l'aide.`;
                    correction = `Paires correctes : ${currentCoordinatesData.map(p => `${p.label}`).join(', ')}.`;
                    // Visual update for Coordinates Matching
                    coordinatesMatchingGameArea.querySelectorAll('.coord-point').forEach(el => {
                        el.style.opacity = '0.3';
                        el.style.pointerEvents = 'none';
                        el.style.border = 'none';
                    });
                } else if (currentItem.name === 'elevationCalculation') {
                    elevationCalculationScores++;
                    details = `L'altitude correcte (${trueElevationC.toFixed(1)}) a √©t√© fournie avec l'aide.`;
                    correction = `L'altitude correcte du point C √©tait de ${trueElevationC.toFixed(1)} m√®tres.`;
                    // Visual update for Elevation Calculation
                    elevationInput.value = trueElevationC.toFixed(1);
                    elevationInput.disabled = true;
                    checkElevationBtn.disabled = true;
                }
                
                gameResults.push({
                    type: 'mini-game',
                    name: currentItem.name,
                    isCorrect: isSuccess,
                    helped: true,
                    details: details,
                    correction: correction,
                    category: currentItem.category
                });
                setTimeout(() => {
                    currentSequenceIndex++;
                    showNextLevel();
                }, 2000);
            }
        }


        // --- Quiz Game Logic ---

        /**
         * Loads a quiz question and its answers into the UI.
         * @param {object} qData - The question data object.
         */
        function loadQuestion(qData) {
            questionText.textContent = qData.question;
            answersContainer.innerHTML = '';
            qData.answers.forEach((answer, index) => {
                const answerDiv = document.createElement('div');
                answerDiv.classList.add('answer');
                answerDiv.textContent = answer;
                answerDiv.dataset.index = index;
                answerDiv.addEventListener('click', () => checkAnswer(answerDiv, qData.correct, qData.category));
                answersContainer.appendChild(answerDiv);
            });
        }

        /**
         * Checks if the selected answer is correct and updates game state.
         * @param {HTMLElement} selectedAnswerDiv - The clicked answer element.
         * @param {number} correctAnswerIndex - The index of the correct answer.
         * @param {string} category - The category of the question for scoring.
         */
        function checkAnswer(selectedAnswerDiv, correctAnswerIndex, category) {
            stopTimer(); // Stop timer immediately after answering
            if (Tone.context.state === 'running') {
                Tone.Transport.scheduleOnce(() => clickSound.triggerAttackRelease("C5", "16n"), Tone.now() + 0.01);
            }

            const allAnswers = answersContainer.querySelectorAll('.answer');
            allAnswers.forEach(answer => {
                answer.style.pointerEvents = 'none'; // Disable further clicks
                if (parseInt(answer.dataset.index) === correctAnswerIndex) {
                    answer.classList.add('correct');
                } else {
                    answer.classList.add('incorrect');
                }
            });

            const isCorrect = parseInt(selectedAnswerDiv.dataset.index) === correctAnswerIndex;
            updateScore(isCorrect ? 100 : -50, isCorrect); // Give points for correct, deduct for incorrect

            if (isCorrect) {
                quizScores += 1; // Increment correct quiz answers
                createExplosion(selectedAnswerDiv.getBoundingClientRect().x + selectedAnswerDiv.offsetWidth / 2,
                                selectedAnswerDiv.getBoundingClientRect().y + selectedAnswerDiv.offsetHeight / 2, '#27ae60');
            } else {
                createExplosion(selectedAnswerDiv.getBoundingClientRect().x + selectedAnswerDiv.offsetWidth / 2,
                                selectedAnswerDiv.getBoundingClientRect().y + selectedAnswerDiv.offsetHeight / 2, '#e74c3c');
            }

            gameResults.push({
                type: 'quiz',
                question: questionText.textContent,
                correctAnswer: quizQuestions.find(q => q.question === questionText.textContent).answers[correctAnswerIndex],
                userAnswer: selectedAnswerDiv.textContent,
                isCorrect: isCorrect,
                category: category
            });

            setTimeout(() => {
                currentSequenceIndex++;
                showNextLevel();
            }, 1500); // Wait a bit before moving to next question
        }

        /**
         * Handles quiz timeout.
         * @param {object} qData - The question data object.
         */
        function handleQuizTimeout(qData) {
            if (Tone.context.state === 'running') {
                Tone.Transport.scheduleOnce(() => incorrectSound.triggerAttackRelease("8n"), Tone.now() + 0.01); // Play incorrect sound for timeout
            }
            updateScore(-100, false); // Deduct points for not answering

            const allAnswers = answersContainer.querySelectorAll('.answer');
            allAnswers.forEach(answer => {
                answer.style.pointerEvents = 'none';
                if (parseInt(answer.dataset.index) === qData.correct) {
                    answer.classList.add('correct'); // Show correct answer
                }
            });

            gameResults.push({
                type: 'quiz',
                question: qData.question,
                correctAnswer: qData.answers[qData.correct],
                userAnswer: "Pas de r√©ponse (temps √©coul√©)",
                isCorrect: false,
                category: qData.category
            });

            setTimeout(() => {
                currentSequenceIndex++;
                showNextLevel();
            }, 1500);
        }

        // --- Theodolite Game Logic ---

        /**
         * Starts the Theodolite mini-game.
         */
        function startTheodoliteGame() {
            theodoliteGameArea.innerHTML = '<div class="theodolite-lens"></div><div class="crosshair"></div>'; // Clear previous targets
            theodoliteTargetsHit = 0;
            totalTheodoliteTargets = 5; // Number of targets to hit

            for (let i = 0; i < totalTheodoliteTargets; i++) {
                createTheodoliteTarget();
            }
        }

        /**
         * Creates a single target for the Theodolite game.
         */
        function createTheodoliteTarget() {
            const target = document.createElement('div');
            target.classList.add('target');
            const size = theodoliteGameArea.getBoundingClientRect();
            const x = Math.random() * (size.width - 80) + 40; // Random position within bounds
            const y = Math.random() * (size.height - 80) + 40;
            target.style.left = `${x}px`;
            target.style.top = `${y}px`;

            target.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent click on game area
                if (!target.classList.contains('hit')) {
                    target.classList.add('hit');
                    createExplosion(e.clientX, e.clientY, '#f39c12');
                    createSoundWave(e.clientX, e.clientY);
                    updateScore(200, true);
                    theodoliteScores++; // Increment theodolite score
                    theodoliteTargetsHit++;
                    if (Tone.context.state === 'running') {
                        Tone.Transport.scheduleOnce(() => synth.triggerAttackRelease("G4", "8n"), Tone.now() + 0.01); // Play hit sound
                    }

                    if (theodoliteTargetsHit === totalTheodoliteTargets) {
                        endTheodoliteGame();
                    } else {
                        // Remove hit target and create a new one instantly
                        target.addEventListener('animationend', () => {
                            target.remove();
                            createTheodoliteTarget();
                        });
                    }
                }
            });
            theodoliteGameArea.appendChild(target);
        }

        /**
         * Ends the Theodolite mini-game.
         */
        function endTheodoliteGame() {
            stopTimer();
            const minTargetsForSuccess = Math.ceil(totalTheodoliteTargets * 0.8); // e.g., 80% for success
            const isGameCorrect = theodoliteTargetsHit >= minTargetsForSuccess;
            if (!isGameCorrect && !gameResults.some(r => r.name === 'Th√©odolite' && (r.skipped || r.helped))) {
                updateScore(-100 * (totalTheodoliteTargets - theodoliteTargetsHit), false);
            }
            if (!gameResults.some(r => r.name === 'Th√©odolite')) { // Only add if not already added by help/skip
                gameResults.push({
                    type: 'mini-game',
                    name: 'Th√©odolite',
                    isCorrect: isGameCorrect,
                    details: `Vous avez touch√© ${theodoliteTargetsHit} cibles sur ${totalTheodoliteTargets}.`,
                    correction: `Visez toutes les cibles avec pr√©cision.`,
                    category: "Pr√©cision (Th√©odolite)"
                });
            }
            
            if (Tone.context.state === 'running') {
                if (isGameCorrect) {
                    Tone.Transport.scheduleOnce(() => winSound.triggerAttackRelease(["C5", "E5", "G5"], "8n"), Tone.now() + 0.01); // Play win sound
                } else {
                    Tone.Transport.scheduleOnce(() => loseSound.triggerAttackRelease(["C4", "G3"], "8n"), Tone.now() + 0.01);
                }
            }

            setTimeout(() => {
                currentSequenceIndex++;
                showNextLevel();
            }, 1500);
        }

        // --- Surface Calculation Game Logic ---

        /**
         * Starts the Surface Calculation mini-game.
         */
        function startSurfaceGame() {
            surfaceGrid.innerHTML = ''; // Clear previous grid
            selectedSurfaceCells = 0;
            requiredSurfaceCells = Math.floor(Math.random() * 20) + 10; // Random target between 10 and 29 cells
            targetSurfaceSpan.textContent = requiredSurfaceCells;

            for (let i = 0; i < 60; i++) { // 10 columns * 6 rows = 60 cells
                const cell = document.createElement('div');
                cell.classList.add('grid-cell');
                cell.dataset.index = i;
                cell.addEventListener('click', () => toggleSurfaceCell(cell));
                surfaceGrid.appendChild(cell);
            }

            checkSurfaceBtn.onclick = checkSurfaceAnswer;
        }

        /**
         * Toggles the selection state of a grid cell.
         * @param {HTMLElement} cell - The grid cell element.
         */
        function toggleSurfaceCell(cell) {
            if (Tone.context.state === 'running') {
                Tone.Transport.scheduleOnce(() => clickSound.triggerAttackRelease("D5", "16n"), Tone.now() + 0.01); // Play click sound
            }
            if (cell.classList.contains('selected')) {
                cell.classList.remove('selected');
                selectedSurfaceCells--;
            } else {
                cell.classList.add('selected');
                selectedSurfaceCells++;
            }
        }

        /**
         * Checks the user's selected surface area against the target.
         */
        function checkSurfaceAnswer() {
            if (Tone.context.state === 'running') {
                Tone.Transport.scheduleOnce(() => buttonPressSound.triggerAttackRelease("D#5", "16n"), Tone.now()); // Play sound on check
            }
            stopTimer();
            const isGameCorrect = selectedSurfaceCells === requiredSurfaceCells;
            if (isGameCorrect) {
                updateScore(300, true);
                surfaceScores++; // Increment surface score
                createConfetti();
                if (Tone.context.state === 'running') {
                    Tone.Transport.scheduleOnce(() => winSound.triggerAttackRelease(["C5", "E5", "G5"], "8n"), Tone.now() + 0.01); // Play win sound
                }
                // Add correct animation to selected cells
                surfaceGrid.querySelectorAll('.selected').forEach(cell => {
                    cell.style.animation = 'correctAnswer 0.6s ease';
                });
            } else {
                updateScore(-150, false);
                if (Tone.context.state === 'running') {
                    Tone.Transport.scheduleOnce(() => loseSound.triggerAttackRelease(["C4", "G3"], "8n"), Tone.now() + 0.01); // Play lose sound
                }
                // Add incorrect animation to all cells
                surfaceGrid.querySelectorAll('.grid-cell').forEach(cell => {
                    cell.style.animation = 'shake 0.5s ease-in-out';
                });
            }

            gameResults.push({
                type: 'mini-game',
                name: 'Calcul de Surface',
                isCorrect: isGameCorrect,
                details: `Vous avez s√©lectionn√© ${selectedSurfaceCells} cellules. La surface requise √©tait de ${requiredSurfaceCells} cellules.`,
                correction: `La surface correcte √©tait de ${requiredSurfaceCells} cellules.`,
                category: "Logique Spatiale (Surface)"
            });

            // Disable further clicks
            surfaceGrid.querySelectorAll('.grid-cell').forEach(cell => cell.style.pointerEvents = 'none');
            checkSurfaceBtn.disabled = true;

            setTimeout(() => {
                currentSequenceIndex++;
                showNextLevel();
            }, 2000);
        }

        /**
         * Ends the Surface Calculation mini-game.
         */
        function endSurfaceGame() {
            stopTimer();
            const isGameCorrect = selectedSurfaceCells === requiredSurfaceCells; // Re-evaluate if needed
            // Only add if not already added by checkSurfaceAnswer or if it was incorrect
            if (!gameResults.some(r => r.name === 'Calcul de Surface' && (r.skipped || r.helped))) {
                updateScore(-200, false);
                gameResults.push({
                    type: 'mini-game',
                    name: 'Calcul de Surface',
                    isCorrect: false,
                    details: `Le temps est √©coul√©. Vous avez s√©lectionn√© ${selectedSurfaceCells} cellules. La surface requise √©tait de ${requiredSurfaceCells} cellules.`,
                    correction: `La surface correcte √©tait de ${requiredSurfaceCells} cellules.`,
                    category: "Logique Spatiale (Surface)"
                });
            }
            if (Tone.context.state === 'running') {
                Tone.Transport.scheduleOnce(() => loseSound.triggerAttackRelease(["C4", "G3"], "8n"), Tone.now() + 0.01); // Play lose sound
            }

            setTimeout(() => {
                currentSequenceIndex++;
                showNextLevel();
            }, 1500);
        }

        // --- 3D Puzzle Game Logic ---

        /**
         * Starts the 3D Puzzle mini-game.
         */
        function startPuzzleGame() {
            puzzleGameArea.innerHTML = ''; // Clear previous elements
            puzzlePieces = [];
            dropZones = [];
            correctDrops = 0;

            const pieceData = [
                { id: 'p1', content: 'üè†', targetX: 0, targetY: 0 },
                { id: 'p2', content: 'üå≥', targetX: 1, targetY: 0 },
                { id: 'p3', content: 'üöó', targetX: 0, targetY: 1 },
                { id: 'p4', content: 'üí°', targetX: 1, targetY: 1 }
            ];

            // Define grid for drop zones (2x2 grid in this case)
            const gridPositions = [
                { x: 50, y: 50 },
                { x: 300, y: 50 },
                { x: 50, y: 300 },
                { x: 300, y: 300 }
            ];

            // Create drop zones
            gridPositions.forEach((pos, index) => {
                const dropZone = document.createElement('div');
                dropZone.classList.add('drop-zone');
                dropZone.style.left = `${pos.x}px`;
                dropZone.style.top = `${pos.y}px`;
                dropZone.dataset.gridX = index % 2;
                dropZone.dataset.gridY = Math.floor(index / 2);
                puzzleGameArea.appendChild(dropZone);
                dropZones.push(dropZone);

                dropZone.addEventListener('dragover', e => {
                    e.preventDefault();
                    dropZone.classList.add('active');
                });
                dropZone.addEventListener('dragleave', () => {
                    dropZone.classList.remove('active');
                });
                dropZone.addEventListener('drop', handlePuzzleDrop);
            });

            // Create puzzle pieces and scatter them
            pieceData.forEach(data => {
                const piece = document.createElement('div');
                piece.classList.add('puzzle-piece');
                piece.textContent = data.content;
                piece.draggable = true;
                piece.dataset.id = data.id;
                piece.dataset.targetGridX = data.targetX;
                piece.dataset.targetGridY = data.targetY;

                // Random initial position outside drop zones
                let initialX, initialY;
                const areaWidth = puzzleGameArea.offsetWidth;
                const areaHeight = puzzleGameArea.offsetHeight;
                const pieceSize = 150;

                // Simple scattering: top-left, top-right, bottom-left, bottom-right corners
                const corners = [
                    { x: 0, y: 0 },
                    { x: areaWidth - pieceSize, y: 0 },
                    { x: 0, y: areaHeight - pieceSize },
                    { x: areaWidth - pieceSize, y: areaHeight - pieceSize }
                ];
                const corner = corners.splice(Math.floor(Math.random() * corners.length), 1)[0];
                initialX = corner.x + Math.random() * 50; // Add small random offset
                initialY = corner.y + Math.random() * 50;

                piece.style.left = `${initialX}px`;
                piece.style.top = `${initialY}px`;

                piece.addEventListener('dragstart', handlePuzzleDragStart);
                piece.addEventListener('dragend', handlePuzzleDragEnd);
                puzzleGameArea.appendChild(piece);
                puzzlePieces.push(piece);
            });
        }

        let draggedPiece = null;

        /**
         * Handles the start of a drag operation for a puzzle piece.
         * @param {DragEvent} e - The drag event.
         */
        function handlePuzzleDragStart(e) {
            draggedPiece = e.target;
            draggedPiece.classList.add('dragging');
            e.dataTransfer.setData('text/plain', draggedPiece.dataset.id);
            if (Tone.context.state === 'running') {
                Tone.Transport.scheduleOnce(() => clickSound.triggerAttackRelease("E5", "16n"), Tone.now() + 0.01); // Play sound on drag start
            }
            // Set a custom drag image (optional)
            const img = new Image();
            img.src = 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs='; // Transparent 1x1 GIF
            e.dataTransfer.setDragImage(img, 0, 0);
        }

        /**
         * Handles the end of a drag operation for a puzzle piece.
         */
        function handlePuzzleDragEnd() {
            if (draggedPiece) {
                draggedPiece.classList.remove('dragging');
                draggedPiece = null;
            }
            dropZones.forEach(zone => zone.classList.remove('active'));
        }

        /**
         * Handles dropping a puzzle piece into a drop zone.
         * @param {DragEvent} e - The drag event.
         */
        function handlePuzzleDrop(e) {
            e.preventDefault();
            const dropZone = e.target.closest('.drop-zone'); // Ensure we get the drop zone itself
            if (!dropZone) return;

            dropZone.classList.remove('active');
            const pieceId = e.dataTransfer.getData('text/plain');
            const piece = document.querySelector(`.puzzle-piece[data-id="${pieceId}"]`);

            if (piece && !piece.parentElement.classList.contains('drop-zone')) { // Prevent dropping into already filled zones
                const targetGridX = parseInt(piece.dataset.targetGridX);
                const targetGridY = parseInt(piece.dataset.targetGridY);
                const dropGridX = parseInt(dropZone.dataset.gridX);
                const dropGridY = parseInt(dropZone.dataset.gridY);

                const isCorrectPlacement = (targetGridX === dropGridX && targetGridY === dropGridY);

                if (isCorrectPlacement) {
                    // Correct placement
                    piece.style.position = 'static'; // Allow it to be centered by flexbox
                    piece.style.transform = 'none'; // Reset any drag transformations
                    piece.draggable = false; // Make it non-draggable
                    dropZone.appendChild(piece);
                    dropZone.style.border = '3px solid #27ae60'; // Indicate correct placement
                    dropZone.style.background = 'rgba(39, 174, 96, 0.4)';
                    correctDrops++;
                    updateScore(400, true);
                    puzzleScores++; // Increment puzzle score
                    if (Tone.context.state === 'running') {
                        Tone.Transport.scheduleOnce(() => correctSound.triggerAttackRelease("G5", "8n"), Tone.now() + 0.01); // Play correct sound
                    }

                    if (correctDrops === puzzlePieces.length) {
                        endPuzzleGame();
                    }
                } else {
                    // Incorrect placement - snap back to original position (or just don't move it)
                    updateScore(-100, false);
                    if (Tone.context.state === 'running') {
                        Tone.Transport.scheduleOnce(() => incorrectSound.triggerAttackRelease("8n"), Tone.now() + 0.01); // Play incorrect sound
                    }
                    createExplosion(e.clientX, e.clientY, '#e74c3c');
                }
            }
        }

        /**
         * Ends the 3D Puzzle mini-game.
         */
        function endPuzzleGame() {
            stopTimer();
            const isGameCorrect = correctDrops === puzzlePieces.length;
            if (!isGameCorrect && !gameResults.some(r => r.name === 'Puzzle 3D' && (r.skipped || r.helped))) {
                updateScore(-200 * (puzzlePieces.length - correctDrops), false);
            }
            if (!gameResults.some(r => r.name === 'Puzzle 3D')) { // Only add if not already added by help/skip
                gameResults.push({
                    type: 'mini-game',
                    name: 'Puzzle 3D',
                    isCorrect: isGameCorrect,
                    details: `Vous avez plac√© ${correctDrops} pi√®ces sur ${puzzlePieces.length}.`,
                    correction: `Assurez-vous que toutes les pi√®ces sont plac√©es dans la bonne zone de d√©p√¥t.`,
                    category: "Assemblage (Puzzle 3D)"
                });
            }
            
            if (Tone.context.state === 'running') {
                if (isGameCorrect) {
                    createConfetti();
                    Tone.Transport.scheduleOnce(() => winSound.triggerAttackRelease(["C6", "E6", "G6"], "8n"), Tone.now() + 0.01); // Play win sound
                } else {
                    Tone.Transport.scheduleOnce(() => loseSound.triggerAttackRelease(["C4", "G3"], "8n"), Tone.now() + 0.01);
                }
            }

            setTimeout(() => {
                currentSequenceIndex++;
                showNextLevel();
            }, 2000);
        }

        // --- Map Reading Game Logic ---
        /**
         * Starts the Map Reading mini-game.
         */
        function startMapReadingGame() {
            mapReadingGameArea.innerHTML = '<div class="map-target" id="mapTarget"></div>'; // Clear and reset target
            mapTargetPos = { x: 0, y: 0 };
            mapAttempts = 0;
            
            // Randomly position the target
            const gameAreaRect = mapReadingGameArea.getBoundingClientRect();
            mapTargetPos.x = Math.random() * (gameAreaRect.width - 40) + 20; // 20px padding from edges
            mapTargetPos.y = Math.random() * (gameAreaRect.height - 40) + 20;

            mapTarget.style.left = `${mapTargetPos.x}px`;
            mapTarget.style.top = `${mapTargetPos.y}px`;

            mapReadingGameArea.onclick = handleMapClick;
        }

        /**
         * Handles a click event on the map reading game area.
         * @param {MouseEvent} e - The click event.
         */
        function handleMapClick(e) {
            if (mapAttempts >= maxMapAttempts) {
                return; // Prevent further clicks if attempts are exhausted
            }

            const rect = mapReadingGameArea.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;

            const distance = Math.sqrt(
                Math.pow(clickX - mapTargetPos.x, 2) +
                Math.pow(clickY - mapTargetPos.y, 2)
            );

            let points = 0;
            let isCorrect = false;

            if (distance < 20) { // Very close hit
                points = 300;
                isCorrect = true;
                mapReadingScores += 1;
                if (Tone.context.state === 'running') {
                    Tone.Transport.scheduleOnce(() => correctSound.triggerAttackRelease("G6", "8n"), Tone.now() + 0.01);
                }
            } else if (distance < 50) { // Close hit
                points = 150;
                isCorrect = true;
                mapReadingScores += 0.5; // Partial score
                if (Tone.context.state === 'running') {
                    Tone.Transport.scheduleOnce(() => synth.triggerAttackRelease("F5", "8n"), Tone.now() + 0.01);
                }
            } else { // Miss
                points = -50;
                isCorrect = false;
                if (Tone.context.state === 'running') {
                    Tone.Transport.scheduleOnce(() => incorrectSound.triggerAttackRelease("8n"), Tone.now() + 0.01);
                }
            }

            updateScore(points, isCorrect);
            createExplosion(e.clientX, e.clientY, isCorrect ? '#3498db' : '#e74c3c');
            createSoundWave(e.clientX, e.clientY);

            mapAttempts++;

            if (mapAttempts >= maxMapAttempts || isCorrect) { // End game if max attempts reached or correct hit
                endMapReadingGame();
            }
        }

        /**
         * Ends the Map Reading mini-game.
         */
        function endMapReadingGame() {
            stopTimer();
            mapReadingGameArea.onclick = null; // Disable further clicks
            mapTarget.style.display = 'none'; // Hide target

            const isGameCorrect = mapReadingScores >= 1; // At least one good hit
            if (!isGameCorrect && !gameResults.some(r => r.name === 'Lecture de Carte' && (r.skipped || r.helped))) {
                updateScore(-200, false);
            }
            if (!gameResults.some(r => r.name === 'Lecture de Carte')) { // Only add if not already added by help/skip
                gameResults.push({
                    type: 'mini-game',
                    name: 'Lecture de Carte',
                    isCorrect: isGameCorrect,
                    details: `Votre score de pr√©cision √©tait de ${mapReadingScores} sur ${maxMapAttempts} tentatives.`,
                    correction: `Le point cible √©tait √† (${Math.round(mapTargetPos.x)}, ${Math.round(mapTargetPos.y)}) pixels. Entra√Ænez votre pr√©cision.`,
                    category: "Lecture de Carte"
                });
            }
            

            if (Tone.context.state === 'running') {
                if (isGameCorrect) {
                    Tone.Transport.scheduleOnce(() => winSound.triggerAttackRelease(["C5", "E5", "G5"], "8n"), Tone.now() + 0.01);
                } else {
                    Tone.Transport.scheduleOnce(() => loseSound.triggerAttackRelease(["C4", "G3"], "8n"), Tone.now() + 0.01);
                }
            }

            setTimeout(() => {
                currentSequenceIndex++;
                showNextLevel();
            }, 1500);
        }

        // --- Distance Calculation Game Logic ---
        /**
         * Starts the Distance Calculation mini-game.
         */
        function startDistanceCalculationGame() {
            distanceInput.value = ''; // Clear previous input
            distanceInput.disabled = false;
            checkDistanceBtn.disabled = false;

            // Generate random coordinates (e.g., between 0 and 100)
            const pA = { x: Math.round(Math.random() * 100), y: Math.round(Math.random() * 100) };
            const pB = { x: Math.round(Math.random() * 100), y: Math.round(Math.random() * 100) };

            pointA_x.textContent = pA.x;
            pointA_y.textContent = pA.y;
            pointB_x.textContent = pB.x;
            pointB_y.textContent = pB.y;

            trueDistance = Math.sqrt(
                Math.pow(pA.x - pB.x, 2) +
                Math.pow(pA.y - pB.y, 2)
            );

            checkDistanceBtn.onclick = checkDistanceAnswer;
        }

        /**
         * Checks the user's entered distance against the true distance.
         */
        function checkDistanceAnswer() {
            if (Tone.context.state === 'running') {
                Tone.Transport.scheduleOnce(() => buttonPressSound.triggerAttackRelease("F5", "16n"), Tone.now()); // Play sound on check
            }
            stopTimer();
            distanceInput.disabled = true;
            checkDistanceBtn.disabled = true;

            const userAnswer = parseFloat(distanceInput.value);
            const tolerance = 1.0; // Allow a small margin of error

            let isCorrect = false;
            let points = 0;

            if (!isNaN(userAnswer) && Math.abs(userAnswer - trueDistance) < tolerance) {
                isCorrect = true;
                points = 500;
                distanceCalculationScores += 1;
                if (Tone.context.state === 'running') {
                    Tone.Transport.scheduleOnce(() => winSound.triggerAttackRelease(["C6", "E6", "G6"], "8n"), Tone.now() + 0.01);
                }
            } else {
                isCorrect = false;
                points = -150;
                if (Tone.context.state === 'running') {
                    Tone.Transport.scheduleOnce(() => loseSound.triggerAttackRelease(["C4", "G3"], "8n"), Tone.now() + 0.01);
                }
            }

            updateScore(points, isCorrect);
            gameResults.push({
                type: 'mini-game',
                name: 'Calcul de Distance',
                isCorrect: isCorrect,
                details: `Votre r√©ponse : ${userAnswer}. Distance correcte : ${trueDistance.toFixed(2)}.`,
                correction: `La distance correcte entre les points √©tait de ${trueDistance.toFixed(2)} unit√©s.`,
                category: "Calcul de Distance"
            });

            setTimeout(() => {
                currentSequenceIndex++;
                showNextLevel();
            }, 2000);
        }

        /**
         * Ends the Distance Calculation mini-game.
         */
        function endDistanceCalculationGame() {
            stopTimer();
            distanceInput.disabled = true;
            checkDistanceBtn.disabled = true;

            // If time runs out and no answer, or incorrect, deduct points
            if (distanceInput.value === '' || Math.abs(parseFloat(distanceInput.value) - trueDistance) >= 1.0) {
                if (!gameResults.some(r => r.name === 'Calcul de Distance' && (r.skipped || r.helped))) { // Avoid duplicates
                    updateScore(-200, false);
                    gameResults.push({
                        type: 'mini-game',
                        name: 'Calcul de Distance',
                        isCorrect: false,
                        details: `Le temps est √©coul√©. Votre r√©ponse : ${distanceInput.value}. Distance correcte : ${trueDistance.toFixed(2)}.`,
                        correction: `La distance correcte entre les points √©tait de ${trueDistance.toFixed(2)} unit√©s.`,
                        category: "Calcul de Distance"
                    });
                }
            }

            setTimeout(() => {
                currentSequenceIndex++;
                showNextLevel();
            }, 1500);
        }

        // --- Coordinates Matching Game Logic ---
        /**
         * Starts the Coordinates Matching mini-game.
         */
        function startCoordinatesMatchingGame() {
            coordinatesMatchingGameArea.innerHTML = ''; // Clear previous elements
            currentSelectedPoint = null;
            matchedPairs = 0;
            totalPairs = 3; // Number of coordinate pairs to match
            currentCoordinatesData = []; // Reset for new game

            const pointsData = [];
            const labelsData = [];

            // Generate 3 random points and their corresponding labels
            for (let i = 0; i < totalPairs; i++) {
                const x = Math.round(Math.random() * 500) + 50; // Random X within bounds
                const y = Math.round(Math.random() * 300) + 50; // Random Y within bounds
                const id = `point-${i}`;
                const label = `(${x}, ${y})`;
                pointsData.push({ id: id, x: x, y: y, label: label });
                labelsData.push({ id: id, label: label });
            }
            currentCoordinatesData = [...pointsData]; // Store for corrections

            // Shuffle labels to ensure they are not in order
            labelsData.sort(() => Math.random() - 0.5);

            // Create point elements
            pointsData.forEach(data => {
                const pointDiv = document.createElement('div');
                pointDiv.classList.add('coord-point');
                pointDiv.style.left = `${data.x}px`;
                pointDiv.style.top = `${data.y}px`;
                pointDiv.dataset.id = data.id;
                pointDiv.dataset.type = 'point';
                pointDiv.dataset.label = data.label; // Store label for matching
                pointDiv.innerHTML = `<span class="coord-label">${data.label}</span>`; // Hidden label
                pointDiv.addEventListener('click', handleCoordinatesClick);
                coordinatesMatchingGameArea.appendChild(pointDiv);
            });

            // Create label elements (scattered)
            labelsData.forEach(data => {
                const labelDiv = document.createElement('div');
                labelDiv.classList.add('coord-point'); // Reusing style for visual consistency
                labelDiv.classList.add('coord-label-display'); // Specific class for labels
                labelDiv.textContent = data.label;
                labelDiv.dataset.id = data.id;
                labelDiv.dataset.type = 'label';
                
                // Random position for labels
                let labelX = Math.random() * 500 + 50;
                let labelY = Math.random() * 300 + 50;
                labelDiv.style.left = `${labelX}px`;
                labelDiv.style.top = `${labelY}px`;

                labelDiv.addEventListener('click', handleCoordinatesClick);
                coordinatesMatchingGameArea.appendChild(labelDiv);
            });
        }

        /**
         * Handles a click on a coordinate point or label.
         * @param {MouseEvent} e - The click event.
         */
        function handleCoordinatesClick(e) {
            const clickedElement = e.target.closest('.coord-point');
            if (!clickedElement) return;

            if (Tone.context.state === 'running') {
                Tone.Transport.scheduleOnce(() => clickSound.triggerAttackRelease("C5", "16n"), Tone.now() + 0.01);
            }

            if (currentSelectedPoint === null) {
                // First click: select a point/label
                currentSelectedPoint = clickedElement;
                currentSelectedPoint.style.border = '2px solid #f39c12'; // Highlight selected
            } else {
                // Second click: attempt to match
                if (currentSelectedPoint === clickedElement) {
                    // Clicking the same element again deselects it
                    currentSelectedPoint.style.border = '2px solid #d35400';
                    currentSelectedPoint = null;
                    return;
                }

                const type1 = currentSelectedPoint.dataset.type;
                const id1 = currentSelectedPoint.dataset.id;
                const type2 = clickedElement.dataset.type;
                const id2 = clickedElement.dataset.id;

                // Check if one is a point and the other is a label, and their IDs match
                if ((type1 === 'point' && type2 === 'label' && id1 === id2) ||
                    (type1 === 'label' && type2 === 'point' && id1 === id2)) {
                    // Match found!
                    matchedPairs++;
                    updateScore(250, true);
                    coordinatesMatchingScores++;

                    currentSelectedPoint.style.opacity = '0.3'; // Fade out matched elements
                    clickedElement.style.opacity = '0.3';
                    currentSelectedPoint.style.pointerEvents = 'none'; // Disable further clicks
                    clickedElement.style.pointerEvents = 'none';

                    // Remove highlight
                    currentSelectedPoint.style.border = 'none';
                    clickedElement.style.border = 'none';

                    createExplosion(e.clientX, e.clientY, '#8e44ad');
                    createSoundWave(e.clientX, e.clientY);

                    if (matchedPairs === totalPairs) {
                        endCoordinatesMatchingGame();
                    }
                } else {
                    // Incorrect match
                    updateScore(-75, false);
                    createExplosion(e.clientX, e.clientY, '#e74c3c');
                }

                // Reset selection
                currentSelectedPoint.style.border = '2px solid #d35400'; // Reset border for previous selection
                currentSelectedPoint = null;
            }
        }

        /**
         * Ends the Coordinates Matching mini-game.
         */
        function endCoordinatesMatchingGame() {
            stopTimer();
            coordinatesMatchingGameArea.onclick = null; // Disable further clicks
            
            const isGameCorrect = matchedPairs === totalPairs;
            if (!isGameCorrect && !gameResults.some(r => r.name === 'Association de Coordonn√©es' && (r.skipped || r.helped))) {
                updateScore(-100 * (totalPairs - matchedPairs), false);
            }
            if (!gameResults.some(r => r.name === 'Association de Coordonn√©es')) { // Only add if not already added by help/skip
                gameResults.push({
                    type: 'mini-game',
                    name: 'Association de Coordonn√©es',
                    isCorrect: isGameCorrect,
                    details: `Vous avez associ√© ${matchedPairs} paires sur ${totalPairs}.`,
                    correction: `Paires correctes : ${currentCoordinatesData.map(p => `${p.label}`).join(', ')}.`,
                    category: "Association de Coordonn√©es"
                });
            }
            

            if (Tone.context.state === 'running') {
                if (isGameCorrect) {
                    createConfetti();
                    Tone.Transport.scheduleOnce(() => winSound.triggerAttackRelease(["C5", "E5", "G5"], "8n"), Tone.now() + 0.01);
                } else {
                    Tone.Transport.scheduleOnce(() => loseSound.triggerAttackRelease(["C4", "G3"], "8n"), Tone.now() + 0.01);
                }
            }

            setTimeout(() => {
                currentSequenceIndex++;
                showNextLevel();
            }, 1500);
        }

        // --- Elevation Calculation Game Logic ---
        /**
         * Starts the Elevation Calculation mini-game.
         */
        function startElevationCalculationGame() {
            elevationInput.value = ''; // Clear previous input
            elevationInput.disabled = false;
            checkElevationBtn.disabled = false;

            // Generate random altitudes for A and B
            const elevA = Math.round(Math.random() * 100) + 50; // 50-150m
            const elevB = Math.round(Math.random() * 100) + 50; // 50-150m

            elevationValueA.textContent = elevA;
            elevationValueB.textContent = elevB;

            // C is halfway between A and B for simplicity
            trueElevationC = (elevA + elevB) / 2;

            checkElevationBtn.onclick = checkElevationAnswer;
        }

        /**
         * Checks the user's entered elevation against the true elevation.
         */
        function checkElevationAnswer() {
            if (Tone.context.state === 'running') {
                Tone.Transport.scheduleOnce(() => buttonPressSound.triggerAttackRelease("G5", "16n"), Tone.now()); // Play sound on check
            }
            stopTimer();
            elevationInput.disabled = true;
            checkElevationBtn.disabled = true;

            const userAnswer = parseFloat(elevationInput.value);
            const tolerance = 0.5; // Allow a small margin of error (0.5m)

            let isCorrect = false;
            let points = 0;

            if (!isNaN(userAnswer) && Math.abs(userAnswer - trueElevationC) < tolerance) {
                isCorrect = true;
                points = 500;
                elevationCalculationScores += 1;
                if (Tone.context.state === 'running') {
                    Tone.Transport.scheduleOnce(() => winSound.triggerAttackRelease(["C6", "E6", "G6"], "8n"), Tone.now() + 0.01);
                }
            } else {
                isCorrect = false;
                points = -150;
                if (Tone.context.state === 'running') {
                    Tone.Transport.scheduleOnce(() => loseSound.triggerAttackRelease(["C4", "G3"], "8n"), Tone.now() + 0.01);
                }
            }

            updateScore(points, isCorrect);
            gameResults.push({
                type: 'mini-game',
                name: 'Calcul d\'Altitude',
                isCorrect: isCorrect,
                details: `Votre r√©ponse : ${userAnswer}. Altitude correcte : ${trueElevationC.toFixed(1)}.`,
                correction: `L'altitude correcte du point C √©tait de ${trueElevationC.toFixed(1)} m√®tres.`,
                category: "Calcul d'Altitude"
            });

            setTimeout(() => {
                currentSequenceIndex++;
                showNextLevel();
            }, 2000);
        }

        /**
         * Ends the Elevation Calculation mini-game.
         */
        function endElevationCalculationGame() {
            stopTimer();
            elevationInput.disabled = true;
            checkElevationBtn.disabled = true;

            // If time runs out and no answer, or incorrect, deduct points
            if (elevationInput.value === '' || Math.abs(parseFloat(elevationInput.value) - trueElevationC) >= 0.5) {
                if (!gameResults.some(r => r.name === 'Calcul d\'Altitude' && (r.skipped || r.helped))) { // Avoid duplicates
                    updateScore(-200, false);
                    gameResults.push({
                        type: 'mini-game',
                        name: 'Calcul d\'Altitude',
                        isCorrect: false,
                        details: `Le temps est √©coul√©. Votre r√©ponse : ${elevationInput.value}. Altitude correcte : ${trueElevationC.toFixed(1)}.`,
                        correction: `L'altitude correcte du point C √©tait de ${trueElevationC.toFixed(1)} m√®tres.`,
                        category: "Calcul d'Altitude"
                    });
                }
            }

            setTimeout(() => {
                currentSequenceIndex++;
                showNextLevel();
            }, 1500);
        }

        // --- Final Screen Logic ---

        /**
         * Displays the final score and category breakdown.
         */
        function endGame() {
            showScreen(finalScreen);
            finalScoreSpan.textContent = score;
            quizScoreSpan.textContent = quizScores;
            theodoliteScoreSpan.textContent = theodoliteScores;
            surfaceScoreSpan.textContent = surfaceScores;
            puzzleScoreSpan.textContent = puzzleScores;
            mapReadingScoreSpan.textContent = Math.round(mapReadingScores); // Display rounded score
            distanceCalculationScoreSpan.textContent = distanceCalculationScores;
            coordinatesMatchingScoreSpan.textContent = coordinatesMatchingScores; // Display new score
            elevationCalculationScoreSpan.textContent = elevationCalculationScores; // Display new score
            createConfetti(); // Grand finale confetti

            displayCorrectionsAndLinks();
            // Populate the hidden div with results for copying
            resultsToCopyDiv.textContent = generateResultsTextForRecruiter();
        }

        /**
         * Generates a comprehensive text string of game results for a recruiter.
         * @returns {string} The formatted results text.
         */
        function generateResultsTextForRecruiter() {
            let text = `--- Mes R√©sultats au LTD Simulateur ---\n\n`;
            text += `Score Final : ${score}\n\n`;
            text += `Scores par Cat√©gorie :\n`;
            text += `- Connaissances G√©n√©rales : ${quizScores}\n`;
            text += `- Pr√©cision (Th√©odolite) : ${theodoliteScores}\n`;
            text += `- Logique Spatiale (Surface) : ${surfaceScores}\n`;
            text += `- Assemblage (Puzzle 3D) : ${puzzleScores}\n`;
            text += `- Lecture de Carte : ${Math.round(mapReadingScores)}\n`;
            text += `- Calcul de Distance : ${distanceCalculationScores}\n`;
            text += `- Association de Coordonn√©es : ${coordinatesMatchingScores}\n`;
            text += `- Calcul d'Altitude : ${elevationCalculationScores}\n\n`;

            text += `--- R√©sultats D√©taill√©s des D√©fis ---\n\n`;

            gameResults.forEach((result, index) => {
                text += `D√©fis ${index + 1} : ${result.type === 'quiz' ? 'Question' : 'Mini-jeu'}\n`;
                text += `Titre : ${result.type === 'quiz' ? result.question : result.name}\n`;

                if (result.skipped) {
                    text += `Statut : Pass√© (P√©nalit√© appliqu√©e)\n`;
                    text += `Correction : ${result.correction}\n`;
                } else if (result.helped) {
                    text += `Statut : R√©ussi avec aide (P√©nalit√© appliqu√©e)\n`;
                    text += `D√©tails : ${result.details}\n`;
                    text += `Correction : ${result.correction}\n`;
                } else {
                    text += `Statut : ${result.isCorrect ? 'Correct' : 'Incorrect'}\n`;
                    if (result.type === 'quiz') {
                        text += `Votre r√©ponse : ${result.userAnswer}\n`;
                        text += `Bonne r√©ponse : ${result.correctAnswer}\n`;
                    } else if (result.type === 'mini-game') {
                        text += `D√©tails : ${result.details}\n`;
                        text += `Correction : ${result.correction}\n`;
                    }
                }
                text += `Cat√©gorie : ${result.category}\n\n`;
            });

            text += `--- Fin des R√©sultats ---\n`;
            text += `Pour en savoir plus sur le m√©tier de g√©om√®tre-topographe : https://www.google.com/search?q=m%C3%A9tier+g%C3%A9om%C3%A8tre-topographe\n`;

            return text;
        }

        /**
         * Copies the generated results text to the clipboard.
         */
        function copyResultsToClipboard() {
            const textToCopy = resultsToCopyDiv.textContent;
            if (textToCopy) {
                const tempTextArea = document.createElement('textarea');
                tempTextArea.value = textToCopy;
                document.body.appendChild(tempTextArea);
                tempTextArea.select();
                try {
                    document.execCommand('copy');
                    // Provide user feedback
                    const feedbackDiv = document.createElement('div');
                    feedbackDiv.textContent = "R√©sultats copi√©s dans le presse-papiers !";
                    feedbackDiv.style.cssText = `
                        position: fixed;
                        bottom: 100px;
                        left: 50%;
                        transform: translateX(-50%);
                        background: rgba(46, 204, 113, 0.9);
                        color: white;
                        padding: 10px 20px;
                        border-radius: 5px;
                        z-index: 9999;
                        opacity: 0;
                        animation: fadeInOut 3s forwards;
                    `;
                    document.body.appendChild(feedbackDiv);
                    setTimeout(() => feedbackDiv.remove(), 3000); // Remove after 3 seconds

                } catch (err) {
                    console.error('Erreur lors de la copie: ', err);
                    const feedbackDiv = document.createElement('div');
                    feedbackDiv.textContent = "√âchec de la copie. Veuillez copier manuellement.";
                    feedbackDiv.style.cssText = `
                        position: fixed;
                        bottom: 100px;
                        left: 50%;
                        transform: translateX(-50%);
                        background: rgba(231, 76, 60, 0.9);
                        color: white;
                        padding: 10px 20px;
                        border-radius: 5px;
                        z-index: 9999;
                        opacity: 0;
                        animation: fadeInOut 3s forwards;
                    `;
                    document.body.appendChild(feedbackDiv);
                    setTimeout(() => feedbackDiv.remove(), 3000); // Remove after 3 seconds
                } finally {
                    document.body.removeChild(tempTextArea);
                }
            }
        }


        /**
         * Displays corrections for incorrect answers and links to relevant courses.
         */
        function displayCorrectionsAndLinks() {
            correctionsContainer.innerHTML = '<h3>Corrections et pistes d\'am√©lioration</h3>';
            courseLinksContainer.innerHTML = '<h3>Ressources pour r√©viser</h3>';

            let categoriesToReview = new Set();
            let hasIncorrectAnswers = false;

            gameResults.forEach((result, index) => {
                if (!result.isCorrect || result.skipped || result.helped) {
                    hasIncorrectAnswers = true; // Mark that there's at least one item to review
                    let correctionHtml = `<div style="margin-bottom: 15px; padding: 10px; border-radius: 8px;">`;
                    
                    if (result.skipped) {
                        correctionHtml += `<p><strong>√âl√©ment ${index + 1} (Pass√©):</strong> ${result.type === 'quiz' ? result.question : result.name}</p>`;
                        correctionHtml += `<p>Statut : <span class="incorrect">Pass√©</span></p>`;
                        correctionHtml += `<p>Correction : <span class="correct">${result.correction}</span></p>`;
                        correctionHtml = correctionHtml.replace('div style=', 'div class="correction-skipped" style=');
                    } else if (result.helped) {
                        correctionHtml += `<p><strong>√âl√©ment ${index + 1} (Aide utilis√©e):</strong> ${result.type === 'quiz' ? result.question : result.name}</p>`;
                        correctionHtml += `<p>Statut : <span class="correct">R√©ussi avec aide</span></p>`;
                        correctionHtml += `<p>D√©tails : ${result.details}</p>`;
                        correctionHtml += `<p>Correction : <span class="correct">${result.correction}</span></p>`;
                        correctionHtml = correctionHtml.replace('div style=', 'div class="correction-helped" style=');
                    } else { // Incorrect answer
                        correctionHtml += `<p><strong>√âl√©ment ${index + 1} (Incorrect):</strong> ${result.type === 'quiz' ? result.question : result.name}</p>`;
                        if (result.type === 'quiz') {
                            correctionHtml += `<p>Votre r√©ponse : <span class="incorrect">${result.userAnswer}</span></p>`;
                            correctionHtml += `<p>Bonne r√©ponse : <span class="correct">${result.correctAnswer}</span></p>`;
                        } else if (result.type === 'mini-game') {
                            correctionHtml += `<p>D√©tails : ${result.details}</p>`;
                            correctionHtml += `<p>Correction : <span class="correct">${result.correction}</span></p>`;
                        }
                        correctionHtml = correctionHtml.replace('div style=', 'div style="border: 1px solid #e74c3c; background-color: #fcecec;" style=');
                    }
                    
                    correctionHtml += `</div>`;
                    correctionsContainer.innerHTML += correctionHtml;
                    categoriesToReview.add(result.category);
                }
            });

            if (!hasIncorrectAnswers) {
                correctionsContainer.innerHTML += `<p>Excellent travail ! Aucune correction n√©cessaire. Vous √™tes un pro !</p>`;
            }

            if (categoriesToReview.size > 0) {
                courseLinksContainer.innerHTML += `<p>Pour am√©liorer vos comp√©tences dans les domaines o√π vous avez rencontr√© des difficult√©s, explorez ces ressources :</p><ul>`;
                categoriesToReview.forEach(category => {
                    const link = courseLinks[category];
                    if (link) {
                        courseLinksContainer.innerHTML += `<li><strong>${category} :</strong> <a href="${link}" target="_blank" style="color: #3498db; text-decoration: underline;">Cours sur ${category}</a></li>`;
                    }
                });
                courseLinksContainer.innerHTML += `</ul>`;
            } else {
                courseLinksContainer.innerHTML += `<p>F√©licitations ! Vous avez tout r√©ussi, continuez √† explorer le monde du g√©om√®tre-topographe !</p>`;
            }
        }

        // --- Background Stars Animation ---
        function createStars() {
            const numStars = 50;
            for (let i = 0; i < numStars; i++) {
                const star = document.createElement('div');
                star.className = 'star';
                star.style.width = `${Math.random() * 5 + 2}px`;
                star.style.height = star.style.width;
                star.style.left = `${Math.random() * 100}vw`;
                star.style.top = `${Math.random() * 100}vh`;
                star.style.animationDuration = `${Math.random() * 3 + 2}s`;
                star.style.animationDelay = `${Math.random() * 2}s`;
                document.body.appendChild(star);
            }
            // Update the count of mini-games in the tagline
            document.querySelector('.tagline').previousElementSibling.innerHTML = `üéÆ ${miniGames.length + quizQuestions.length} mini-jeux fun ‚Ä¢ üèÜ D√©fis pro ‚Ä¢ üöÄ Animations √©piques`;
        }

        // --- Event Listeners ---
        startBtn.addEventListener('click', startGame);
        restartBtn.addEventListener('click', startGame);
        resetBtn.addEventListener('click', startGame); // Add event listener for the reset button
        copyResultsBtn.addEventListener('click', copyResultsToClipboard); // Add event listener for the copy button

        // Attach skip/help button listeners
        quizHelpBtn.addEventListener('click', showHelp);
        quizSkipBtn.addEventListener('click', skipCurrentGame);
        theodoliteHelpBtn.addEventListener('click', showHelp);
        theodoliteSkipBtn.addEventListener('click', skipCurrentGame);
        surfaceHelpBtn.addEventListener('click', showHelp);
        surfaceSkipBtn.addEventListener('click', skipCurrentGame);
        puzzleHelpBtn.addEventListener('click', showHelp);
        puzzleSkipBtn.addEventListener('click', skipCurrentGame);
        mapReadingHelpBtn.addEventListener('click', showHelp);
        mapReadingSkipBtn.addEventListener('click', skipCurrentGame);
        distanceCalculationHelpBtn.addEventListener('click', showHelp);
        distanceCalculationSkipBtn.addEventListener('click', skipCurrentGame);
        coordinatesMatchingHelpBtn.addEventListener('click', showHelp);
        coordinatesMatchingSkipBtn.addEventListener('click', skipCurrentGame);
        elevationCalculationHelpBtn.addEventListener('click', showHelp);
        elevationCalculationSkipBtn.addEventListener('click', skipCurrentGame);


        // Initial setup
        window.onload = function() {
            createStars();
            showScreen(homeScreen);
        };

    </script>
</body>
</html>
